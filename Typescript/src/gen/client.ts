//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class ActualValuesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Actual values for requested places
     */
    getActualValues(placeIds: number[], cancelToken?: CancelToken | undefined): Promise<ActualValues> {
        let url_ = this.baseUrl + "/actual-values?";
        if (placeIds === undefined || placeIds === null)
            throw new Error("The parameter 'placeIds' must be defined and cannot be null.");
        else
            placeIds && placeIds.forEach(item => { url_ += "placeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActualValues(_response);
        });
    }

    protected processGetActualValues(response: AxiosResponse): Promise<ActualValues> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActualValues.fromJS(resultData200);
            return Promise.resolve<ActualValues>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActualValues>(null as any);
    }
}

export class AlarmsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Page of alarms
     */
    getAlarms(type: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<AlarmPage> {
        let url_ = this.baseUrl + "/alarms?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlarms(_response);
        });
    }

    protected processGetAlarms(response: AxiosResponse): Promise<AlarmPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmPage.fromJS(resultData200);
            return Promise.resolve<AlarmPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmPage>(null as any);
    }
}

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return OK
     */
    alarms_acknowledged(alarmIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/alarms/acknowledge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(alarmIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlarms_acknowledged(_response);
        });
    }

    protected processAlarms_acknowledged(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    alarms_annotated(annotation: AlarmsAnnotation, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/alarms/annotate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(annotation);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlarms_annotated(_response);
        });
    }

    protected processAlarms_annotated(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    user_logOff( cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/auth/logoff";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUser_logOff(_response);
        });
    }

    protected processUser_logOff(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    start_Communication_Test(guid: string, connectionNumber: string, connectionType: number, deviceDriverId: number, deviceParameters: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/test/start?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        if (connectionNumber === undefined || connectionNumber === null)
            throw new Error("The parameter 'connectionNumber' must be defined and cannot be null.");
        else
            url_ += "connectionNumber=" + encodeURIComponent("" + connectionNumber) + "&";
        if (connectionType === undefined || connectionType === null)
            throw new Error("The parameter 'connectionType' must be defined and cannot be null.");
        else
            url_ += "connectionType=" + encodeURIComponent("" + connectionType) + "&";
        if (deviceDriverId === undefined || deviceDriverId === null)
            throw new Error("The parameter 'deviceDriverId' must be defined and cannot be null.");
        else
            url_ += "deviceDriverId=" + encodeURIComponent("" + deviceDriverId) + "&";
        if (deviceParameters === undefined || deviceParameters === null)
            throw new Error("The parameter 'deviceParameters' must be defined and cannot be null.");
        else
            url_ += "deviceParameters=" + encodeURIComponent("" + deviceParameters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStart_Communication_Test(_response);
        });
    }

    protected processStart_Communication_Test(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_Communication_Test(guid: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/test/cancel?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_Communication_Test(_response);
        });
    }

    protected processCancel_Communication_Test(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    run_DataPump_with_GUID(dataPumpGuid: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/data/pumps/{dataPumpGuid}/run";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRun_DataPump_with_GUID(_response);
        });
    }

    protected processRun_DataPump_with_GUID(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    save_Device_data(placeId: number, rows: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/data/storage/{placeId}?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (rows === undefined || rows === null)
            throw new Error("The parameter 'rows' must be defined and cannot be null.");
        else
            url_ += "rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave_Device_data(_response);
        });
    }

    protected processSave_Device_data(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    validate_Data(validationRequest: DataValidationRequest, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/data/validation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(validationRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate_Data(_response);
        });
    }

    protected processValidate_Data(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_Data_Validation(validationRequest: DataValidationRequest, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/data/validation/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(validationRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_Data_Validation(_response);
        });
    }

    protected processCancel_Data_Validation(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    server_forced_to_restart(serverId: number, reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/diagnostics/servers/{serverId}/restart?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServer_forced_to_restart(_response);
        });
    }

    protected processServer_forced_to_restart(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    servers_forced_to_restart(serverIds: number[], reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/diagnostics/servers/restart?";
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(serverIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServers_forced_to_restart(_response);
        });
    }

    protected processServers_forced_to_restart(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    server_forced_to_update(serverId: number, reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/diagnostics/servers/{serverId}/update?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServer_forced_to_update(_response);
        });
    }

    protected processServer_forced_to_update(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    servers_forced_to_update(serverIds: number[], reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/diagnostics/servers/update?";
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(serverIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServers_forced_to_update(_response);
        });
    }

    protected processServers_forced_to_update(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    save_KeyValue_pair(collection: string, key: string, value: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/key-value-store/{collection}/{key}?";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined and cannot be null.");
        else
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave_KeyValue_pair(_response);
        });
    }

    protected processSave_KeyValue_pair(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    delete_KeyValue_pair(collection: string, key: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/key-value-store/{collection}/{key}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete_KeyValue_pair(_response);
        });
    }

    protected processDelete_KeyValue_pair(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_profile(profileId: number, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/profiles/{profileId}/read";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_profile(_response);
        });
    }

    protected processRead_profile(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_profiles(profileIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/profiles/read?";
        if (profileIds === undefined || profileIds === null)
            throw new Error("The parameter 'profileIds' must be defined and cannot be null.");
        else
            profileIds && profileIds.forEach(item => { url_ += "profileIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_profiles(_response);
        });
    }

    protected processRead_profiles(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param useCommonDeviceDriver (optional)
     * @param boostPriority (optional)
     * @param isLimitedReadWriteOperation (optional)
     * @return OK
     */
    create_reading_request_for_places(placeIds: number[], connectionOption: ConnectionOption, readWriteOperationType: ReadWriteOperationType, deviceDriverId: number, useCommonDeviceDriver: boolean | null | undefined, boostPriority: boolean | null | undefined, isLimitedReadWriteOperation: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/read?";
        if (placeIds === undefined || placeIds === null)
            throw new Error("The parameter 'placeIds' must be defined and cannot be null.");
        else
            placeIds && placeIds.forEach(item => { url_ += "placeIds=" + encodeURIComponent("" + item) + "&"; });
        if (connectionOption === undefined || connectionOption === null)
            throw new Error("The parameter 'connectionOption' must be defined and cannot be null.");
        else
            url_ += "connectionOption=" + encodeURIComponent("" + connectionOption) + "&";
        if (readWriteOperationType === undefined || readWriteOperationType === null)
            throw new Error("The parameter 'readWriteOperationType' must be defined and cannot be null.");
        else
            url_ += "readWriteOperationType=" + encodeURIComponent("" + readWriteOperationType) + "&";
        if (deviceDriverId === undefined || deviceDriverId === null)
            throw new Error("The parameter 'deviceDriverId' must be defined and cannot be null.");
        else
            url_ += "deviceDriverId=" + encodeURIComponent("" + deviceDriverId) + "&";
        if (useCommonDeviceDriver !== undefined && useCommonDeviceDriver !== null)
            url_ += "useCommonDeviceDriver=" + encodeURIComponent("" + useCommonDeviceDriver) + "&";
        if (boostPriority !== undefined && boostPriority !== null)
            url_ += "boostPriority=" + encodeURIComponent("" + boostPriority) + "&";
        if (isLimitedReadWriteOperation !== undefined && isLimitedReadWriteOperation !== null)
            url_ += "isLimitedReadWriteOperation=" + encodeURIComponent("" + isLimitedReadWriteOperation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate_reading_request_for_places(_response);
        });
    }

    protected processCreate_reading_request_for_places(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_reading_request(readRequestGuids: string[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/read/cancel?";
        if (readRequestGuids === undefined || readRequestGuids === null)
            throw new Error("The parameter 'readRequestGuids' must be defined and cannot be null.");
        else
            readRequestGuids && readRequestGuids.forEach(item => { url_ += "readRequestGuids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_reading_request(_response);
        });
    }

    protected processCancel_reading_request(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_schedulers(schedulerIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/schedulers/read?";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_schedulers(_response);
        });
    }

    protected processRead_schedulers(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    shift_schedulers_execution_time(minutesToAdd: number, schedulerIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/schedulers/shift?";
        if (minutesToAdd === undefined || minutesToAdd === null)
            throw new Error("The parameter 'minutesToAdd' must be defined and cannot be null.");
        else
            url_ += "minutesToAdd=" + encodeURIComponent("" + minutesToAdd) + "&";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShift_schedulers_execution_time(_response);
        });
    }

    protected processShift_schedulers_execution_time(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    saves_a_system_event(eventLog: SystemEventLog, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/system/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventLog);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaves_a_system_event(_response);
        });
    }

    protected processSaves_a_system_event(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    users_disconnected(encodedSessions: SessionIds, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/users/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(encodedSessions);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsers_disconnected(_response);
        });
    }

    protected processUsers_disconnected(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }
}

export class AuthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return User logged on
     */
    logon(login: Login, cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite> {
        let url_ = this.baseUrl + "/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogon(_response);
        });
    }

    protected processLogon(response: AxiosResponse): Promise<ConnectedUserLite> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConnectedUserLite.fromJS(resultData200);
            return Promise.resolve<ConnectedUserLite>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User not logged on", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite>(null as any);
    }
}

export class CallStatisticsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get Call Statistics paged
     */
    getCallStatistics(from: Date, to: Date, placeId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallStatisticPage> {
        let url_ = this.baseUrl + "/statistics?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallStatistics(_response);
        });
    }

    protected processGetCallStatistics(response: AxiosResponse): Promise<CallStatisticPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallStatisticPage.fromJS(resultData200);
            return Promise.resolve<CallStatisticPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallStatisticPage>(null as any);
    }

    /**
     * @return Get Call Statistics chart data
     */
    getCallStatisticsChartData(placeId: number, dataRange: number, chartType: number, cancelToken?: CancelToken | undefined): Promise<ChartData> {
        let url_ = this.baseUrl + "/statistics/chart-data?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        if (chartType === undefined || chartType === null)
            throw new Error("The parameter 'chartType' must be defined and cannot be null.");
        else
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallStatisticsChartData(_response);
        });
    }

    protected processGetCallStatisticsChartData(response: AxiosResponse): Promise<ChartData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChartData.fromJS(resultData200);
            return Promise.resolve<ChartData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData>(null as any);
    }

    /**
     * @return Get Call Statistics logs
     */
    getCallLogs(placeId: number, readingStart: Date, cancelToken?: CancelToken | undefined): Promise<CallLogs> {
        let url_ = this.baseUrl + "/statistics/logs?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (readingStart === undefined || readingStart === null)
            throw new Error("The parameter 'readingStart' must be defined and cannot be null.");
        else
            url_ += "readingStart=" + encodeURIComponent(readingStart ? "" + readingStart.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallLogs(_response);
        });
    }

    protected processGetCallLogs(response: AxiosResponse): Promise<CallLogs> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogs.fromJS(resultData200);
            return Promise.resolve<CallLogs>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogs>(null as any);
    }
}

export class CommunicationTestClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get Communication Test Progress
     */
    getCommunicationTestProgress(guid: string, cancelToken?: CancelToken | undefined): Promise<CommunicationTestProgress> {
        let url_ = this.baseUrl + "/test/progress?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommunicationTestProgress(_response);
        });
    }

    protected processGetCommunicationTestProgress(response: AxiosResponse): Promise<CommunicationTestProgress> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommunicationTestProgress.fromJS(resultData200);
            return Promise.resolve<CommunicationTestProgress>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunicationTestProgress>(null as any);
    }
}

export class ConnectedUserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Connected user
     */
    getConnectedUser( cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite> {
        let url_ = this.baseUrl + "/users/connected-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectedUser(_response);
        });
    }

    protected processGetConnectedUser(response: AxiosResponse): Promise<ConnectedUserLite> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConnectedUserLite.fromJS(resultData200);
            return Promise.resolve<ConnectedUserLite>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite>(null as any);
    }

    /**
     * @return Password changed
     */
    changePassword(changePassword: ChangePassword, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/connected-user/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePassword);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Username updated
     */
    updateUserName(newUserName: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/connected-user/username";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserName);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserName(_response);
        });
    }

    protected processUpdateUserName(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Username not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Email updated
     */
    updateEmail(newEmail: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/connected-user/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEmail);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEmail(_response);
        });
    }

    protected processUpdateEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Email not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Phone updated
     */
    updatePhone(newPhone: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/users/connected-user/phone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newPhone);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePhone(_response);
        });
    }

    protected processUpdatePhone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Phone not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DashboardClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Dashboard
     */
    getDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string, cancelToken?: CancelToken | undefined): Promise<DashboardRoot> {
        let url_ = this.baseUrl + "/dashboard?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        if (dealerId === undefined || dealerId === null)
            throw new Error("The parameter 'dealerId' must be defined and cannot be null.");
        else
            url_ += "dealerId=" + encodeURIComponent("" + dealerId) + "&";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (truncateData === undefined || truncateData === null)
            throw new Error("The parameter 'truncateData' must be defined and cannot be null.");
        else
            url_ += "truncateData=" + encodeURIComponent("" + truncateData) + "&";
        if (withDaylightSavingTime === undefined || withDaylightSavingTime === null)
            throw new Error("The parameter 'withDaylightSavingTime' must be defined and cannot be null.");
        else
            url_ += "withDaylightSavingTime=" + encodeURIComponent("" + withDaylightSavingTime) + "&";
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined and cannot be null.");
        else
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (dataType === undefined || dataType === null)
            throw new Error("The parameter 'dataType' must be defined and cannot be null.");
        else
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        if (mainDeviceGuidFilter === undefined || mainDeviceGuidFilter === null)
            throw new Error("The parameter 'mainDeviceGuidFilter' must be defined and cannot be null.");
        else
            url_ += "mainDeviceGuidFilter=" + encodeURIComponent("" + mainDeviceGuidFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: AxiosResponse): Promise<DashboardRoot> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardRoot.fromJS(resultData200);
            return Promise.resolve<DashboardRoot>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardRoot>(null as any);
    }

    /**
     * @return Dashboard variables
     */
    getDashboardVariables( cancelToken?: CancelToken | undefined): Promise<DashboardVariables> {
        let url_ = this.baseUrl + "/dashboard/variables";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardVariables(_response);
        });
    }

    protected processGetDashboardVariables(response: AxiosResponse): Promise<DashboardVariables> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardVariables.fromJS(resultData200);
            return Promise.resolve<DashboardVariables>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardVariables>(null as any);
    }

    /**
     * @return Dashboard main devices
     */
    getDashboardMainDevices(regionId: number, cancelToken?: CancelToken | undefined): Promise<DashboardMainDevices> {
        let url_ = this.baseUrl + "/dashboard/devices?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardMainDevices(_response);
        });
    }

    protected processGetDashboardMainDevices(response: AxiosResponse): Promise<DashboardMainDevices> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardMainDevices.fromJS(resultData200);
            return Promise.resolve<DashboardMainDevices>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardMainDevices>(null as any);
    }

    /**
     * @return Dashboard export in .xlsx
     */
    exportDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/dashboard/export?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        if (dealerId === undefined || dealerId === null)
            throw new Error("The parameter 'dealerId' must be defined and cannot be null.");
        else
            url_ += "dealerId=" + encodeURIComponent("" + dealerId) + "&";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (truncateData === undefined || truncateData === null)
            throw new Error("The parameter 'truncateData' must be defined and cannot be null.");
        else
            url_ += "truncateData=" + encodeURIComponent("" + truncateData) + "&";
        if (withDaylightSavingTime === undefined || withDaylightSavingTime === null)
            throw new Error("The parameter 'withDaylightSavingTime' must be defined and cannot be null.");
        else
            url_ += "withDaylightSavingTime=" + encodeURIComponent("" + withDaylightSavingTime) + "&";
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined and cannot be null.");
        else
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (dataType === undefined || dataType === null)
            throw new Error("The parameter 'dataType' must be defined and cannot be null.");
        else
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        if (mainDeviceGuidFilter === undefined || mainDeviceGuidFilter === null)
            throw new Error("The parameter 'mainDeviceGuidFilter' must be defined and cannot be null.");
        else
            url_ += "mainDeviceGuidFilter=" + encodeURIComponent("" + mainDeviceGuidFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportDashboard(_response);
        });
    }

    protected processExportDashboard(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DataExportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return List of Export types
     */
    getExportTypes( cancelToken?: CancelToken | undefined): Promise<DataExportType> {
        let url_ = this.baseUrl + "/data/export/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportTypes(_response);
        });
    }

    protected processGetExportTypes(response: AxiosResponse): Promise<DataExportType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataExportType.fromJS(resultData200);
            return Promise.resolve<DataExportType>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataExportType>(null as any);
    }

    /**
     * @return List of Export templates
     */
    getExportTemplates( cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/data/export/templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportTemplates(_response);
        });
    }

    protected processGetExportTemplates(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param exportFileParameters_dateFrom (optional)
     * @param exportFileParameters_dateTo (optional)
     * @param exportFileParameters_leaveDateAsItIs (optional)
     * @param exportFileParameters_placesIds (optional)
     * @param exportFileParameters_profilesIds (optional)
     * @param exportFileParameters_internetAveExportType (optional)
     * @param exportFileParameters_exportType (optional)
     * @param exportFileParameters_truncateData (optional)
     * @param exportFileParameters_withDaylightSavingTime (optional)
     * @param exportFileParameters_templateFile_fileName (optional)
     * @param exportFileParameters_templateFile_contentBase64 (optional)
     * @param exportFileParameters_deviceGroupName (optional)
     * @param exportFileParameters_clientOutputFileName (optional)
     * @return Export file
     */
    getExportFile(exportFileParameters_dateFrom: Date | null | undefined, exportFileParameters_dateTo: Date | null | undefined, exportFileParameters_leaveDateAsItIs: boolean | null | undefined, exportFileParameters_placesIds: number[] | null | undefined, exportFileParameters_profilesIds: number[] | null | undefined, exportFileParameters_internetAveExportType: string | null | undefined, exportFileParameters_exportType: number | null | undefined, exportFileParameters_truncateData: boolean | null | undefined, exportFileParameters_withDaylightSavingTime: boolean | null | undefined, exportFileParameters_templateFile_fileName: string | null | undefined, exportFileParameters_templateFile_contentBase64: string | null | undefined, exportFileParameters_deviceGroupName: string | null | undefined, exportFileParameters_clientOutputFileName: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/data/export/file?";
        if (exportFileParameters_dateFrom !== undefined && exportFileParameters_dateFrom !== null)
            url_ += "exportFileParameters.dateFrom=" + encodeURIComponent(exportFileParameters_dateFrom ? "" + exportFileParameters_dateFrom.toISOString() : "") + "&";
        if (exportFileParameters_dateTo !== undefined && exportFileParameters_dateTo !== null)
            url_ += "exportFileParameters.dateTo=" + encodeURIComponent(exportFileParameters_dateTo ? "" + exportFileParameters_dateTo.toISOString() : "") + "&";
        if (exportFileParameters_leaveDateAsItIs !== undefined && exportFileParameters_leaveDateAsItIs !== null)
            url_ += "exportFileParameters.leaveDateAsItIs=" + encodeURIComponent("" + exportFileParameters_leaveDateAsItIs) + "&";
        if (exportFileParameters_placesIds !== undefined && exportFileParameters_placesIds !== null)
            exportFileParameters_placesIds && exportFileParameters_placesIds.forEach(item => { url_ += "exportFileParameters.placesIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportFileParameters_profilesIds !== undefined && exportFileParameters_profilesIds !== null)
            exportFileParameters_profilesIds && exportFileParameters_profilesIds.forEach(item => { url_ += "exportFileParameters.profilesIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportFileParameters_internetAveExportType !== undefined && exportFileParameters_internetAveExportType !== null)
            url_ += "exportFileParameters.internetAveExportType=" + encodeURIComponent("" + exportFileParameters_internetAveExportType) + "&";
        if (exportFileParameters_exportType !== undefined && exportFileParameters_exportType !== null)
            url_ += "exportFileParameters.exportType=" + encodeURIComponent("" + exportFileParameters_exportType) + "&";
        if (exportFileParameters_truncateData !== undefined && exportFileParameters_truncateData !== null)
            url_ += "exportFileParameters.truncateData=" + encodeURIComponent("" + exportFileParameters_truncateData) + "&";
        if (exportFileParameters_withDaylightSavingTime !== undefined && exportFileParameters_withDaylightSavingTime !== null)
            url_ += "exportFileParameters.withDaylightSavingTime=" + encodeURIComponent("" + exportFileParameters_withDaylightSavingTime) + "&";
        if (exportFileParameters_templateFile_fileName !== undefined && exportFileParameters_templateFile_fileName !== null)
            url_ += "exportFileParameters.templateFile.fileName=" + encodeURIComponent("" + exportFileParameters_templateFile_fileName) + "&";
        if (exportFileParameters_templateFile_contentBase64 !== undefined && exportFileParameters_templateFile_contentBase64 !== null)
            url_ += "exportFileParameters.templateFile.contentBase64=" + encodeURIComponent("" + exportFileParameters_templateFile_contentBase64) + "&";
        if (exportFileParameters_deviceGroupName !== undefined && exportFileParameters_deviceGroupName !== null)
            url_ += "exportFileParameters.deviceGroupName=" + encodeURIComponent("" + exportFileParameters_deviceGroupName) + "&";
        if (exportFileParameters_clientOutputFileName !== undefined && exportFileParameters_clientOutputFileName !== null)
            url_ += "exportFileParameters.clientOutputFileName=" + encodeURIComponent("" + exportFileParameters_clientOutputFileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFile(_response);
        });
    }

    protected processGetExportFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DataPumpsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get DataPumps
     */
    getDataPumps(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DataPumpLite[]> {
        let url_ = this.baseUrl + "/data/pumps?";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumps(_response);
        });
    }

    protected processGetDataPumps(response: AxiosResponse): Promise<DataPumpLite[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataPumpLite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DataPumpLite[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataPumpLite[]>(null as any);
    }

    /**
     * @param briefSummary (optional)
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get summary for DataPump with GUID
     */
    getDataPumpSummary(dataPumpGuid: string, dateFrom: Date, dateTo: Date, briefSummary: boolean | null | undefined, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DataPumpSummary> {
        let url_ = this.baseUrl + "/data/pumps/{dataPumpGuid}/summary?";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (briefSummary !== undefined && briefSummary !== null)
            url_ += "briefSummary=" + encodeURIComponent("" + briefSummary) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpSummary(_response);
        });
    }

    protected processGetDataPumpSummary(response: AxiosResponse): Promise<DataPumpSummary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataPumpSummary.fromJS(resultData200);
            return Promise.resolve<DataPumpSummary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataPumpSummary>(null as any);
    }

    /**
     * @return Get statistics chart data for DataPump with GUID
     */
    getDataPumpStatisticsChartData(dataPumpGuid: string, dataRange: number, chartType: number, cancelToken?: CancelToken | undefined): Promise<ChartData1> {
        let url_ = this.baseUrl + "/data/pumps/{dataPumpGuid}/statistics/chart-data?";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        if (chartType === undefined || chartType === null)
            throw new Error("The parameter 'chartType' must be defined and cannot be null.");
        else
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpStatisticsChartData(_response);
        });
    }

    protected processGetDataPumpStatisticsChartData(response: AxiosResponse): Promise<ChartData1> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChartData1.fromJS(resultData200);
            return Promise.resolve<ChartData1>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData1>(null as any);
    }

    /**
     * @return Get DataPumpSettings
     */
    getDataPumpSettings(dataPumpGuid: string, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/data/pumps/{dataPumpGuid}/settings";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpSettings(_response);
        });
    }

    protected processGetDataPumpSettings(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get DataPumpProfiles
     */
    getDataPumpProfiles(dataPumpIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/data/pumps/profiles?";
        if (dataPumpIds === undefined || dataPumpIds === null)
            throw new Error("The parameter 'dataPumpIds' must be defined and cannot be null.");
        else
            dataPumpIds && dataPumpIds.forEach(item => { url_ += "dataPumpIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpProfiles(_response);
        });
    }

    protected processGetDataPumpProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }
}

export class DataStorageClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param parameters_fieldNames (optional)
     * @param parameters_dateFrom (optional)
     * @param parameters_dateTo (optional)
     * @param parameters_dataType (optional)
     * @param parameters_truncateData (optional)
     * @param parameters_withDaylightSavingTime (optional)
     * @param parameters_timeFormat (optional)
     * @param parameters_cultureName (optional)
     * @param parameters_line (optional)
     * @param parameters_group (optional)
     * @return Get Device data
     */
    getDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SerializableDataTableContainer> {
        let url_ = this.baseUrl + "/data/storage/{placeId}?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceData(_response);
        });
    }

    protected processGetDeviceData(response: AxiosResponse): Promise<SerializableDataTableContainer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SerializableDataTableContainer.fromJS(resultData200);
            return Promise.resolve<SerializableDataTableContainer>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SerializableDataTableContainer>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional)
     * @param parameters_dateFrom (optional)
     * @param parameters_dateTo (optional)
     * @param parameters_dataType (optional)
     * @param parameters_truncateData (optional)
     * @param parameters_withDaylightSavingTime (optional)
     * @param parameters_timeFormat (optional)
     * @param parameters_cultureName (optional)
     * @param parameters_line (optional)
     * @param parameters_group (optional)
     * @return Get Device chart data
     */
    getDeviceChartData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DeviceChartData> {
        let url_ = this.baseUrl + "/data/storage/{placeId}/chart?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceChartData(_response);
        });
    }

    protected processGetDeviceChartData(response: AxiosResponse): Promise<DeviceChartData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceChartData.fromJS(resultData200);
            return Promise.resolve<DeviceChartData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceChartData>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional)
     * @param parameters_dateFrom (optional)
     * @param parameters_dateTo (optional)
     * @param parameters_dataType (optional)
     * @param parameters_truncateData (optional)
     * @param parameters_withDaylightSavingTime (optional)
     * @param parameters_timeFormat (optional)
     * @param parameters_cultureName (optional)
     * @param parameters_line (optional)
     * @param parameters_group (optional)
     * @return Get MiniWebClient Device chart data
     */
    getMiniWebClientDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<MiniWebClientDeviceData> {
        let url_ = this.baseUrl + "/data/storage/{placeId}/mini-web-client?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMiniWebClientDeviceData(_response);
        });
    }

    protected processGetMiniWebClientDeviceData(response: AxiosResponse): Promise<MiniWebClientDeviceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MiniWebClientDeviceData.fromJS(resultData200);
            return Promise.resolve<MiniWebClientDeviceData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MiniWebClientDeviceData>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional)
     * @param parameters_dateFrom (optional)
     * @param parameters_dateTo (optional)
     * @param parameters_dataType (optional)
     * @param parameters_truncateData (optional)
     * @param parameters_withDaylightSavingTime (optional)
     * @param parameters_timeFormat (optional)
     * @param parameters_cultureName (optional)
     * @param parameters_line (optional)
     * @param parameters_group (optional)
     * @return Get AveDroid Device data
     */
    getAveDroidDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<AveDroidDeviceData> {
        let url_ = this.baseUrl + "/data/storage/{placeId}/ave-droid?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAveDroidDeviceData(_response);
        });
    }

    protected processGetAveDroidDeviceData(response: AxiosResponse): Promise<AveDroidDeviceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AveDroidDeviceData.fromJS(resultData200);
            return Promise.resolve<AveDroidDeviceData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AveDroidDeviceData>(null as any);
    }
}

export class DealersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get dealers
     */
    getDealers( cancelToken?: CancelToken | undefined): Promise<Dealer[]> {
        let url_ = this.baseUrl + "/dealers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDealers(_response);
        });
    }

    protected processGetDealers(response: AxiosResponse): Promise<Dealer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dealer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Dealer[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dealer[]>(null as any);
    }
}

export class DeviceDriversClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get list of driver communication channels for server
     */
    getDriverCommunicationChannels(serverId: number, cancelToken?: CancelToken | undefined): Promise<DriverCommunicationChannel[]> {
        let url_ = this.baseUrl + "/devices/drivers/{serverId}/channels";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDriverCommunicationChannels(_response);
        });
    }

    protected processGetDriverCommunicationChannels(response: AxiosResponse): Promise<DriverCommunicationChannel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DriverCommunicationChannel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DriverCommunicationChannel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DriverCommunicationChannel[]>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @return Get driver communication channel logs
     */
    getCommunicationChannelLogs(serverId: number, channelGuid: string, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallLogsPage> {
        let url_ = this.baseUrl + "/devices/drivers/{serverId}/channels/{channelGuid}/logs?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (channelGuid === undefined || channelGuid === null)
            throw new Error("The parameter 'channelGuid' must be defined.");
        url_ = url_.replace("{channelGuid}", encodeURIComponent("" + channelGuid));
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommunicationChannelLogs(_response);
        });
    }

    protected processGetCommunicationChannelLogs(response: AxiosResponse): Promise<CallLogsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogsPage.fromJS(resultData200);
            return Promise.resolve<CallLogsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogsPage>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @return Get driver logs
     */
    getDriverLogs(serverId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallLogsPage> {
        let url_ = this.baseUrl + "/devices/drivers/{serverId}/logs?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDriverLogs(_response);
        });
    }

    protected processGetDriverLogs(response: AxiosResponse): Promise<CallLogsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogsPage.fromJS(resultData200);
            return Promise.resolve<CallLogsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogsPage>(null as any);
    }
}

export class DevicesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return List of device tags
     */
    getTags(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceTagItem[]> {
        let url_ = this.baseUrl + "/devices/tags/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTags(_response);
        });
    }

    protected processGetTags(response: AxiosResponse): Promise<DeviceTagItem[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceTagItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceTagItem[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceTagItem[]>(null as any);
    }

    /**
     * @return List of device tag groups
     */
    getTagGroups( cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/devices/tags/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTagGroups(_response);
        });
    }

    protected processGetTagGroups(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return List of device alarms
     */
    getAlarms(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceAlarmItem[]> {
        let url_ = this.baseUrl + "/devices/alarms/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlarms(_response);
        });
    }

    protected processGetAlarms(response: AxiosResponse): Promise<DeviceAlarmItem[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAlarmItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceAlarmItem[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAlarmItem[]>(null as any);
    }

    /**
     * @return List of device reading parameters
     */
    getReadingParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<ReadingParameters> {
        let url_ = this.baseUrl + "/devices/reading/params/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReadingParameters(_response);
        });
    }

    protected processGetReadingParameters(response: AxiosResponse): Promise<ReadingParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReadingParameters.fromJS(resultData200);
            return Promise.resolve<ReadingParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReadingParameters>(null as any);
    }

    /**
     * @return List of device reading info
     */
    getLastReadingInfo(placeId: number, cancelToken?: CancelToken | undefined): Promise<LastReadingInfo> {
        let url_ = this.baseUrl + "/devices/reading/info/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLastReadingInfo(_response);
        });
    }

    protected processGetLastReadingInfo(response: AxiosResponse): Promise<LastReadingInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LastReadingInfo.fromJS(resultData200);
            return Promise.resolve<LastReadingInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LastReadingInfo>(null as any);
    }

    /**
     * @return List of time windows
     */
    getTimeWindows(placeId: number, cancelToken?: CancelToken | undefined): Promise<TimeWindows> {
        let url_ = this.baseUrl + "/devices/time_windows/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeWindows(_response);
        });
    }

    protected processGetTimeWindows(response: AxiosResponse): Promise<TimeWindows> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeWindows.fromJS(resultData200);
            return Promise.resolve<TimeWindows>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeWindows>(null as any);
    }

    /**
     * @return List of battery info
     */
    getBatteryStatus(placeId: number, cancelToken?: CancelToken | undefined): Promise<BatteryStatus> {
        let url_ = this.baseUrl + "/devices/battery/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBatteryStatus(_response);
        });
    }

    protected processGetBatteryStatus(response: AxiosResponse): Promise<BatteryStatus> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryStatus.fromJS(resultData200);
            return Promise.resolve<BatteryStatus>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryStatus>(null as any);
    }

    /**
     * @return List of device parameters
     */
    getDeviceParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceParameters> {
        let url_ = this.baseUrl + "/devices/params/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceParameters(_response);
        });
    }

    protected processGetDeviceParameters(response: AxiosResponse): Promise<DeviceParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceParameters.fromJS(resultData200);
            return Promise.resolve<DeviceParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceParameters>(null as any);
    }

    /**
     * @return List of device runtime parameters
     */
    getDeviceRuntimeParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceRuntimeParameters> {
        let url_ = this.baseUrl + "/devices/params/runtime/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceRuntimeParameters(_response);
        });
    }

    protected processGetDeviceRuntimeParameters(response: AxiosResponse): Promise<DeviceRuntimeParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceRuntimeParameters.fromJS(resultData200);
            return Promise.resolve<DeviceRuntimeParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceRuntimeParameters>(null as any);
    }

    /**
     * @return List of device runtime parameters as xlsx file
     */
    getDeviceRuntimeParametersXlsx(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceRuntimeParameters> {
        let url_ = this.baseUrl + "/devices/params/runtime/{placeId}/xlsx";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceRuntimeParametersXlsx(_response);
        });
    }

    protected processGetDeviceRuntimeParametersXlsx(response: AxiosResponse): Promise<DeviceRuntimeParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceRuntimeParameters.fromJS(resultData200);
            return Promise.resolve<DeviceRuntimeParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceRuntimeParameters>(null as any);
    }

    /**
     * @return Device gas composition
     */
    getGasComposition(placeId: number, cancelToken?: CancelToken | undefined): Promise<GasComposition> {
        let url_ = this.baseUrl + "/devices/gas/composition?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGasComposition(_response);
        });
    }

    protected processGetGasComposition(response: AxiosResponse): Promise<GasComposition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GasComposition.fromJS(resultData200);
            return Promise.resolve<GasComposition>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GasComposition>(null as any);
    }

    /**
     * @return List of connection types
     */
    getConnectionTypes( cancelToken?: CancelToken | undefined): Promise<ConnectionType[]> {
        let url_ = this.baseUrl + "/devices/connection/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectionTypes(_response);
        });
    }

    protected processGetConnectionTypes(response: AxiosResponse): Promise<ConnectionType[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConnectionType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ConnectionType[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectionType[]>(null as any);
    }
}

export class DiagnosticsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get servers info
     */
    getServerInfos( cancelToken?: CancelToken | undefined): Promise<ServerInfos> {
        let url_ = this.baseUrl + "/diagnostics/servers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerInfos(_response);
        });
    }

    protected processGetServerInfos(response: AxiosResponse): Promise<ServerInfos> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerInfos.fromJS(resultData200);
            return Promise.resolve<ServerInfos>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerInfos>(null as any);
    }

    /**
     * @return Get server monitoring data
     */
    getServerMonitoringItems(serverId: number, dataRange: DataRange, cancelToken?: CancelToken | undefined): Promise<ServerMonitoringItems> {
        let url_ = this.baseUrl + "/diagnostics/servers/{serverId}/monitoring?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerMonitoringItems(_response);
        });
    }

    protected processGetServerMonitoringItems(response: AxiosResponse): Promise<ServerMonitoringItems> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerMonitoringItems.fromJS(resultData200);
            return Promise.resolve<ServerMonitoringItems>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerMonitoringItems>(null as any);
    }

    /**
     * @return Get server monitoring chart data
     */
    getServerMonitoringChartData(serverId: number, dataRange: DataRange2, cancelToken?: CancelToken | undefined): Promise<ChartData_1[]> {
        let url_ = this.baseUrl + "/diagnostics/servers/{serverId}/monitoring/chart-data?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerMonitoringChartData(_response);
        });
    }

    protected processGetServerMonitoringChartData(response: AxiosResponse): Promise<ChartData_1[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartData_1.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChartData_1[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData_1[]>(null as any);
    }
}

export class ExportsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Page of export schedulers
     */
    getExportSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<Page_1> {
        let url_ = this.baseUrl + "/export?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportSchedulers(_response);
        });
    }

    protected processGetExportSchedulers(response: AxiosResponse): Promise<Page_1> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Page_1.fromJS(resultData200);
            return Promise.resolve<Page_1>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Page_1>(null as any);
    }

    /**
     * @return Export scheduler run successfully
     */
    runExportScheduler(exportSchedulerId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/export/{exportSchedulerId}/run";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRunExportScheduler(_response);
        });
    }

    protected processRunExportScheduler(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Page of export files
     */
    getExportFiles(exportSchedulerId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<Page_11> {
        let url_ = this.baseUrl + "/export/{exportSchedulerId}/files?";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFiles(_response);
        });
    }

    protected processGetExportFiles(response: AxiosResponse): Promise<Page_11> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Page_11.fromJS(resultData200);
            return Promise.resolve<Page_11>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Page_11>(null as any);
    }

    /**
     * @return Export file
     */
    getExportFile(exportSchedulerId: number, fileName: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/export/{exportSchedulerId}/files/{fileName}";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFile(_response);
        });
    }

    protected processGetExportFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class KeyValueStoreClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get Key-Value collection
     */
    getKeyValueCollection(collection: string, cancelToken?: CancelToken | undefined): Promise<KeyValueCommandResponse> {
        let url_ = this.baseUrl + "/key-value-store/{collection}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetKeyValueCollection(_response);
        });
    }

    protected processGetKeyValueCollection(response: AxiosResponse): Promise<KeyValueCommandResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyValueCommandResponse.fromJS(resultData200);
            return Promise.resolve<KeyValueCommandResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Key-Value collection does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyValueCommandResponse>(null as any);
    }

    /**
     * @return Get Key-Value pair
     */
    getKeyValue(collection: string, key: string, cancelToken?: CancelToken | undefined): Promise<KeyValuePair_2> {
        let url_ = this.baseUrl + "/key-value-store/{collection}/{key}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetKeyValue(_response);
        });
    }

    protected processGetKeyValue(response: AxiosResponse): Promise<KeyValuePair_2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyValuePair_2.fromJS(resultData200);
            return Promise.resolve<KeyValuePair_2>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Key-Value pair does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyValuePair_2>(null as any);
    }
}

export class PlacesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Page of places
     */
    getPlaces(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/places?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPlaces(_response);
        });
    }

    protected processGetPlaces(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }

    /**
     * @return Place Data deleted
     */
    deletePlaceData(placeId: number, timestamps: Date[], cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/places/{placeId}/data";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(timestamps);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletePlaceData(_response);
        });
    }

    protected processDeletePlaceData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ProfilesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get profiles paged
     */
    getProfiles(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/profiles?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get profile places paged
     */
    getProfilePlaces(profileId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/profiles/{profileId}/places?";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfilePlaces(_response);
        });
    }

    protected processGetProfilePlaces(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get places for multiple profiles paged
     */
    getProfilePlaces2(profileIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/profiles/places?";
        if (profileIds === undefined || profileIds === null)
            throw new Error("The parameter 'profileIds' must be defined and cannot be null.");
        else
            profileIds && profileIds.forEach(item => { url_ += "profileIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfilePlaces2(_response);
        });
    }

    protected processGetProfilePlaces2(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }
}

export class ReadingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get reading requests paged
     */
    getReadingRequests(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ReadRequestPage> {
        let url_ = this.baseUrl + "/read/requests?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReadingRequests(_response);
        });
    }

    protected processGetReadingRequests(response: AxiosResponse): Promise<ReadRequestPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReadRequestPage.fromJS(resultData200);
            return Promise.resolve<ReadRequestPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReadRequestPage>(null as any);
    }
}

export class SchedulersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get schedulers
     */
    getSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SchedulerPage> {
        let url_ = this.baseUrl + "/schedulers?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchedulers(_response);
        });
    }

    protected processGetSchedulers(response: AxiosResponse): Promise<SchedulerPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SchedulerPage.fromJS(resultData200);
            return Promise.resolve<SchedulerPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchedulerPage>(null as any);
    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Get schedulers profiles
     */
    getSchedulerProfiles(schedulerIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/schedulers/profiles?";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchedulerProfiles(_response);
        });
    }

    protected processGetSchedulerProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }
}

export class SystemClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Returns system info
     */
    getSystemInfo( cancelToken?: CancelToken | undefined): Promise<SystemInfo> {
        let url_ = this.baseUrl + "/system/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemInfo(_response);
        });
    }

    protected processGetSystemInfo(response: AxiosResponse): Promise<SystemInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemInfo.fromJS(resultData200);
            return Promise.resolve<SystemInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemInfo>(null as any);
    }

    /**
     * @return Returns regions
     */
    getRegions( cancelToken?: CancelToken | undefined): Promise<ServerRegion[]> {
        let url_ = this.baseUrl + "/system/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegions(_response);
        });
    }

    protected processGetRegions(response: AxiosResponse): Promise<ServerRegion[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerRegion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerRegion[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerRegion[]>(null as any);
    }

    /**
     * @return Returns server time
     */
    getServerTime( cancelToken?: CancelToken | undefined): Promise<ServerTime> {
        let url_ = this.baseUrl + "/system/server-time";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerTime(_response);
        });
    }

    protected processGetServerTime(response: AxiosResponse): Promise<ServerTime> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerTime.fromJS(resultData200);
            return Promise.resolve<ServerTime>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerTime>(null as any);
    }

    /**
     * @return Returns server version
     */
    getServerVersion( cancelToken?: CancelToken | undefined): Promise<ServerVersion> {
        let url_ = this.baseUrl + "/system/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerVersion(_response);
        });
    }

    protected processGetServerVersion(response: AxiosResponse): Promise<ServerVersion> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerVersion.fromJS(resultData200);
            return Promise.resolve<ServerVersion>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerVersion>(null as any);
    }

    /**
     * @return Returns echo
     */
    echo(echo: string, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/system/echo?";
        if (echo === undefined || echo === null)
            throw new Error("The parameter 'echo' must be defined and cannot be null.");
        else
            url_ += "echo=" + encodeURIComponent("" + echo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEcho(_response);
        });
    }

    protected processEcho(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Returns pong
     */
    ping( cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/system/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class SystemEventsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional)
     * @param limit (optional)
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Returns system events
     */
    getSystemEvents(eventType: number, eventId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SystemEventPage[]> {
        let url_ = this.baseUrl + "/system/events?";
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined and cannot be null.");
        else
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined and cannot be null.");
        else
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemEvents(_response);
        });
    }

    protected processGetSystemEvents(response: AxiosResponse): Promise<SystemEventPage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SystemEventPage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SystemEventPage[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemEventPage[]>(null as any);
    }
}

export class UsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param sort (optional)
     * @param direction (optional)
     * @param filter (optional)
     * @return Connected users
     */
    getConnectedUsers(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite[]> {
        let url_ = this.baseUrl + "/users/connected?";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectedUsers(_response);
        });
    }

    protected processGetConnectedUsers(response: AxiosResponse): Promise<ConnectedUserLite[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConnectedUserLite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ConnectedUserLite[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite[]>(null as any);
    }
}

export class ActualValues implements IActualValues {
    items?: ActualValue[] | undefined;
    count?: number | undefined;

    constructor(data?: IActualValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ActualValue.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): ActualValues {
        data = typeof data === 'object' ? data : {};
        let result = new ActualValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface IActualValues {
    items?: ActualValue[] | undefined;
    count?: number | undefined;
}

export class ActualValue implements IActualValue {
    placeId?: number | undefined;
    mark?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    units?: string | undefined;
    state?: string | undefined;
    status?: string | undefined;
    address?: number | undefined;
    tagName?: string | undefined;
    tagFieldName?: string | undefined;
    tagDescription?: string | undefined;
    addressEx?: string | undefined;
    tagGroupName?: string | undefined;
    tagHasBindingToAlarm?: boolean | undefined;
    alarmEntry?: AlarmEntry | undefined;
    readonly valueAsObject?: any | undefined;

    constructor(data?: IActualValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["PlaceId"];
            this.mark = _data["Mark"];
            this.name = _data["Name"];
            this.value = _data["Value"];
            this.valueType = _data["ValueType"];
            this.units = _data["Units"];
            this.state = _data["State"];
            this.status = _data["Status"];
            this.address = _data["Address"];
            this.tagName = _data["TagName"];
            this.tagFieldName = _data["TagFieldName"];
            this.tagDescription = _data["TagDescription"];
            this.addressEx = _data["AddressEx"];
            this.tagGroupName = _data["TagGroupName"];
            this.tagHasBindingToAlarm = _data["TagHasBindingToAlarm"];
            this.alarmEntry = _data["AlarmEntry"] ? AlarmEntry.fromJS(_data["AlarmEntry"]) : <any>undefined;
            (<any>this).valueAsObject = _data["ValueAsObject"];
        }
    }

    static fromJS(data: any): ActualValue {
        data = typeof data === 'object' ? data : {};
        let result = new ActualValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PlaceId"] = this.placeId;
        data["Mark"] = this.mark;
        data["Name"] = this.name;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        data["Units"] = this.units;
        data["State"] = this.state;
        data["Status"] = this.status;
        data["Address"] = this.address;
        data["TagName"] = this.tagName;
        data["TagFieldName"] = this.tagFieldName;
        data["TagDescription"] = this.tagDescription;
        data["AddressEx"] = this.addressEx;
        data["TagGroupName"] = this.tagGroupName;
        data["TagHasBindingToAlarm"] = this.tagHasBindingToAlarm;
        data["AlarmEntry"] = this.alarmEntry ? this.alarmEntry.toJSON() : <any>undefined;
        data["ValueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IActualValue {
    placeId?: number | undefined;
    mark?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    units?: string | undefined;
    state?: string | undefined;
    status?: string | undefined;
    address?: number | undefined;
    tagName?: string | undefined;
    tagFieldName?: string | undefined;
    tagDescription?: string | undefined;
    addressEx?: string | undefined;
    tagGroupName?: string | undefined;
    tagHasBindingToAlarm?: boolean | undefined;
    alarmEntry?: AlarmEntry | undefined;
    valueAsObject?: any | undefined;
}

export class AlarmEntry implements IAlarmEntry {
    guid?: string | undefined;
    timeGenerated?: Date | undefined;
    timeTerminated?: Date | undefined;
    timeWritten?: Date | undefined;
    timeAcknowledged?: Date | undefined;
    timeAnnotated?: Date | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
    itemId?: number | undefined;
    place?: ConsumptionPlace | undefined;
    readonly timeAnnotatedAsText?: string | undefined;
    readonly timeAcknowledgedAsText?: string | undefined;
    readonly timeTerminatedAsText?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: AlarmEntryObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IAlarmEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["Guid"];
            this.timeGenerated = _data["TimeGenerated"] ? new Date(_data["TimeGenerated"].toString()) : <any>undefined;
            this.timeTerminated = _data["TimeTerminated"] ? new Date(_data["TimeTerminated"].toString()) : <any>undefined;
            this.timeWritten = _data["TimeWritten"] ? new Date(_data["TimeWritten"].toString()) : <any>undefined;
            this.timeAcknowledged = _data["TimeAcknowledged"] ? new Date(_data["TimeAcknowledged"].toString()) : <any>undefined;
            this.timeAnnotated = _data["TimeAnnotated"] ? new Date(_data["TimeAnnotated"].toString()) : <any>undefined;
            this.alarmID = _data["AlarmID"];
            this.source = _data["Source"];
            this.category = _data["Category"];
            this.acknowledgeUser = _data["AcknowledgeUser"];
            this.annotationUser = _data["AnnotationUser"];
            this.device = _data["Device"];
            this.tagName = _data["TagName"];
            this.tagValue = _data["TagValue"];
            this.message = _data["Message"];
            this.data = _data["Data"];
            this.note = _data["Note"];
            this.acknowledgementRequired = _data["AcknowledgementRequired"];
            this.acknowledged = _data["Acknowledged"];
            this.isActive = _data["IsActive"];
            this.regionId = _data["RegionId"];
            this.region = _data["Region"];
            this.itemId = _data["ItemId"];
            this.place = _data["Place"] ? ConsumptionPlace.fromJS(_data["Place"]) : <any>undefined;
            (<any>this).timeAnnotatedAsText = _data["TimeAnnotatedAsText"];
            (<any>this).timeAcknowledgedAsText = _data["TimeAcknowledgedAsText"];
            (<any>this).timeTerminatedAsText = _data["TimeTerminatedAsText"];
            (<any>this).id = _data["Id"];
            this.tag = _data["Tag"];
            (<any>this).syncRoot = _data["SyncRoot"];
            if (Array.isArray(_data["Parent"])) {
                this.parent = [] as any;
                for (let item of _data["Parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["IsDirty"];
            (<any>this).isNew = _data["IsNew"];
            (<any>this).isDeleted = _data["IsDeleted"];
            this.isEdited = _data["IsEdited"];
            (<any>this).objectState = _data["ObjectState"];
            if (Array.isArray(_data["Rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["Rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["IsValid"];
            (<any>this).isInError = _data["IsInError"];
            (<any>this).error = _data["Error"];
            (<any>this).isDirtyHashCode = _data["IsDirtyHashCode"];
        }
    }

    static fromJS(data: any): AlarmEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["TimeGenerated"] = this.timeGenerated ? this.timeGenerated.toISOString() : <any>undefined;
        data["TimeTerminated"] = this.timeTerminated ? this.timeTerminated.toISOString() : <any>undefined;
        data["TimeWritten"] = this.timeWritten ? this.timeWritten.toISOString() : <any>undefined;
        data["TimeAcknowledged"] = this.timeAcknowledged ? this.timeAcknowledged.toISOString() : <any>undefined;
        data["TimeAnnotated"] = this.timeAnnotated ? this.timeAnnotated.toISOString() : <any>undefined;
        data["AlarmID"] = this.alarmID;
        data["Source"] = this.source;
        data["Category"] = this.category;
        data["AcknowledgeUser"] = this.acknowledgeUser;
        data["AnnotationUser"] = this.annotationUser;
        data["Device"] = this.device;
        data["TagName"] = this.tagName;
        data["TagValue"] = this.tagValue;
        data["Message"] = this.message;
        data["Data"] = this.data;
        data["Note"] = this.note;
        data["AcknowledgementRequired"] = this.acknowledgementRequired;
        data["Acknowledged"] = this.acknowledged;
        data["IsActive"] = this.isActive;
        data["RegionId"] = this.regionId;
        data["Region"] = this.region;
        data["ItemId"] = this.itemId;
        data["Place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["TimeAnnotatedAsText"] = this.timeAnnotatedAsText;
        data["TimeAcknowledgedAsText"] = this.timeAcknowledgedAsText;
        data["TimeTerminatedAsText"] = this.timeTerminatedAsText;
        data["Id"] = this.id;
        data["Tag"] = this.tag;
        data["SyncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["Parent"] = [];
            for (let item of this.parent)
                data["Parent"].push(item);
        }
        data["IsDirty"] = this.isDirty;
        data["IsNew"] = this.isNew;
        data["IsDeleted"] = this.isDeleted;
        data["IsEdited"] = this.isEdited;
        data["ObjectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["Rules"] = [];
            for (let item of this.rules)
                data["Rules"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["IsInError"] = this.isInError;
        data["Error"] = this.error;
        data["IsDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IAlarmEntry {
    guid?: string | undefined;
    timeGenerated?: Date | undefined;
    timeTerminated?: Date | undefined;
    timeWritten?: Date | undefined;
    timeAcknowledged?: Date | undefined;
    timeAnnotated?: Date | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
    itemId?: number | undefined;
    place?: ConsumptionPlace | undefined;
    timeAnnotatedAsText?: string | undefined;
    timeAcknowledgedAsText?: string | undefined;
    timeTerminatedAsText?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: AlarmEntryObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class ConsumptionPlace implements IConsumptionPlace {
    readonly formatedPlaceNumber?: string | undefined;
    readonly descriptionWithId?: string | undefined;
    readonly description?: string | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    placeEic?: string | undefined;
    scadaId?: string | undefined;
    regionId?: number | undefined;
    placeId?: string | undefined;
    name?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    payerId?: string | undefined;
    payerName?: string | undefined;
    payerStreet?: string | undefined;
    payerCity?: string | undefined;
    payerZipCode?: string | undefined;
    payerIdentificationNumber?: string | undefined;
    contractNumber?: string | undefined;
    dealerIdentification?: string | undefined;
    purchaseCategory?: number | undefined;
    connectionMethod?: number | undefined;
    readingCategory?: number | undefined;
    consumptionTerminated?: boolean | undefined;
    automaticallyImported?: boolean | undefined;
    exportToCis?: boolean | undefined;
    useAlternativeValues?: boolean | undefined;
    created?: Date | undefined;
    modified?: Date | undefined;
    note?: string | undefined;
    group?: string | undefined;
    state?: number | undefined;
    lastDataTimestamp?: Date | undefined;
    lastReadingTimestamp?: Date | undefined;
    workPlace?: string | undefined;
    dataShardId?: number | undefined;
    annualConsumptionMonths?: number | undefined;
    annualConsumptionVolume?: number | undefined;
    annualConsumptionInMwh?: number | undefined;
    deviceSize?: string | undefined;
    validatedTill?: Date | undefined;
    readonly isDataValidated?: boolean | undefined;
    validatedBy?: string | undefined;
    readonly manuallyImported?: boolean | undefined;
    customer?: Customer | undefined;
    validationNote?: string | undefined;
    parentPlaceGuid?: string | undefined;
    payerNote?: string | undefined;
    string1?: string | undefined;
    string2?: string | undefined;
    int1?: number | undefined;
    int2?: number | undefined;
    extendedProperties?: ExtendedProperty[] | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    device?: BaseDevice | undefined;
    readonly deviceSerialNumber?: string | undefined;
    readonly dataTableName?: string | undefined;
    readonly lastReadingTimestampDescription?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: ConsumptionPlaceObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IConsumptionPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).formatedPlaceNumber = _data["FormatedPlaceNumber"];
            (<any>this).descriptionWithId = _data["DescriptionWithId"];
            (<any>this).description = _data["Description"];
            this.itemId = _data["ItemId"];
            this.guid = _data["Guid"];
            this.placeEic = _data["PlaceEic"];
            this.scadaId = _data["ScadaId"];
            this.regionId = _data["RegionId"];
            this.placeId = _data["PlaceId"];
            this.name = _data["Name"];
            this.street = _data["Street"];
            this.city = _data["City"];
            this.zipCode = _data["ZipCode"];
            this.payerId = _data["PayerId"];
            this.payerName = _data["PayerName"];
            this.payerStreet = _data["PayerStreet"];
            this.payerCity = _data["PayerCity"];
            this.payerZipCode = _data["PayerZipCode"];
            this.payerIdentificationNumber = _data["PayerIdentificationNumber"];
            this.contractNumber = _data["ContractNumber"];
            this.dealerIdentification = _data["DealerIdentification"];
            this.purchaseCategory = _data["PurchaseCategory"];
            this.connectionMethod = _data["ConnectionMethod"];
            this.readingCategory = _data["ReadingCategory"];
            this.consumptionTerminated = _data["ConsumptionTerminated"];
            this.automaticallyImported = _data["AutomaticallyImported"];
            this.exportToCis = _data["ExportToCis"];
            this.useAlternativeValues = _data["UseAlternativeValues"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.modified = _data["Modified"] ? new Date(_data["Modified"].toString()) : <any>undefined;
            this.note = _data["Note"];
            this.group = _data["Group"];
            this.state = _data["State"];
            this.lastDataTimestamp = _data["LastDataTimestamp"] ? new Date(_data["LastDataTimestamp"].toString()) : <any>undefined;
            this.lastReadingTimestamp = _data["LastReadingTimestamp"] ? new Date(_data["LastReadingTimestamp"].toString()) : <any>undefined;
            this.workPlace = _data["WorkPlace"];
            this.dataShardId = _data["DataShardId"];
            this.annualConsumptionMonths = _data["AnnualConsumptionMonths"];
            this.annualConsumptionVolume = _data["AnnualConsumptionVolume"];
            this.annualConsumptionInMwh = _data["AnnualConsumptionInMwh"];
            this.deviceSize = _data["DeviceSize"];
            this.validatedTill = _data["ValidatedTill"] ? new Date(_data["ValidatedTill"].toString()) : <any>undefined;
            (<any>this).isDataValidated = _data["IsDataValidated"];
            this.validatedBy = _data["ValidatedBy"];
            (<any>this).manuallyImported = _data["ManuallyImported"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.validationNote = _data["ValidationNote"];
            this.parentPlaceGuid = _data["ParentPlaceGuid"];
            this.payerNote = _data["PayerNote"];
            this.string1 = _data["String1"];
            this.string2 = _data["String2"];
            this.int1 = _data["Int1"];
            this.int2 = _data["Int2"];
            if (Array.isArray(_data["ExtendedProperties"])) {
                this.extendedProperties = [] as any;
                for (let item of _data["ExtendedProperties"])
                    this.extendedProperties!.push(ExtendedProperty.fromJS(item));
            }
            this.createdBy = _data["CreatedBy"];
            this.modifiedBy = _data["ModifiedBy"];
            this.device = _data["Device"] ? BaseDevice.fromJS(_data["Device"]) : <any>undefined;
            (<any>this).deviceSerialNumber = _data["DeviceSerialNumber"];
            (<any>this).dataTableName = _data["DataTableName"];
            (<any>this).lastReadingTimestampDescription = _data["LastReadingTimestampDescription"];
            (<any>this).id = _data["Id"];
            this.tag = _data["Tag"];
            (<any>this).syncRoot = _data["SyncRoot"];
            if (Array.isArray(_data["Parent"])) {
                this.parent = [] as any;
                for (let item of _data["Parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["IsDirty"];
            (<any>this).isNew = _data["IsNew"];
            (<any>this).isDeleted = _data["IsDeleted"];
            this.isEdited = _data["IsEdited"];
            (<any>this).objectState = _data["ObjectState"];
            if (Array.isArray(_data["Rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["Rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["IsValid"];
            (<any>this).isInError = _data["IsInError"];
            (<any>this).error = _data["Error"];
            (<any>this).isDirtyHashCode = _data["IsDirtyHashCode"];
        }
    }

    static fromJS(data: any): ConsumptionPlace {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FormatedPlaceNumber"] = this.formatedPlaceNumber;
        data["DescriptionWithId"] = this.descriptionWithId;
        data["Description"] = this.description;
        data["ItemId"] = this.itemId;
        data["Guid"] = this.guid;
        data["PlaceEic"] = this.placeEic;
        data["ScadaId"] = this.scadaId;
        data["RegionId"] = this.regionId;
        data["PlaceId"] = this.placeId;
        data["Name"] = this.name;
        data["Street"] = this.street;
        data["City"] = this.city;
        data["ZipCode"] = this.zipCode;
        data["PayerId"] = this.payerId;
        data["PayerName"] = this.payerName;
        data["PayerStreet"] = this.payerStreet;
        data["PayerCity"] = this.payerCity;
        data["PayerZipCode"] = this.payerZipCode;
        data["PayerIdentificationNumber"] = this.payerIdentificationNumber;
        data["ContractNumber"] = this.contractNumber;
        data["DealerIdentification"] = this.dealerIdentification;
        data["PurchaseCategory"] = this.purchaseCategory;
        data["ConnectionMethod"] = this.connectionMethod;
        data["ReadingCategory"] = this.readingCategory;
        data["ConsumptionTerminated"] = this.consumptionTerminated;
        data["AutomaticallyImported"] = this.automaticallyImported;
        data["ExportToCis"] = this.exportToCis;
        data["UseAlternativeValues"] = this.useAlternativeValues;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["Modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["Note"] = this.note;
        data["Group"] = this.group;
        data["State"] = this.state;
        data["LastDataTimestamp"] = this.lastDataTimestamp ? this.lastDataTimestamp.toISOString() : <any>undefined;
        data["LastReadingTimestamp"] = this.lastReadingTimestamp ? this.lastReadingTimestamp.toISOString() : <any>undefined;
        data["WorkPlace"] = this.workPlace;
        data["DataShardId"] = this.dataShardId;
        data["AnnualConsumptionMonths"] = this.annualConsumptionMonths;
        data["AnnualConsumptionVolume"] = this.annualConsumptionVolume;
        data["AnnualConsumptionInMwh"] = this.annualConsumptionInMwh;
        data["DeviceSize"] = this.deviceSize;
        data["ValidatedTill"] = this.validatedTill ? this.validatedTill.toISOString() : <any>undefined;
        data["IsDataValidated"] = this.isDataValidated;
        data["ValidatedBy"] = this.validatedBy;
        data["ManuallyImported"] = this.manuallyImported;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ValidationNote"] = this.validationNote;
        data["ParentPlaceGuid"] = this.parentPlaceGuid;
        data["PayerNote"] = this.payerNote;
        data["String1"] = this.string1;
        data["String2"] = this.string2;
        data["Int1"] = this.int1;
        data["Int2"] = this.int2;
        if (Array.isArray(this.extendedProperties)) {
            data["ExtendedProperties"] = [];
            for (let item of this.extendedProperties)
                data["ExtendedProperties"].push(item.toJSON());
        }
        data["CreatedBy"] = this.createdBy;
        data["ModifiedBy"] = this.modifiedBy;
        data["Device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["DeviceSerialNumber"] = this.deviceSerialNumber;
        data["DataTableName"] = this.dataTableName;
        data["LastReadingTimestampDescription"] = this.lastReadingTimestampDescription;
        data["Id"] = this.id;
        data["Tag"] = this.tag;
        data["SyncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["Parent"] = [];
            for (let item of this.parent)
                data["Parent"].push(item);
        }
        data["IsDirty"] = this.isDirty;
        data["IsNew"] = this.isNew;
        data["IsDeleted"] = this.isDeleted;
        data["IsEdited"] = this.isEdited;
        data["ObjectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["Rules"] = [];
            for (let item of this.rules)
                data["Rules"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["IsInError"] = this.isInError;
        data["Error"] = this.error;
        data["IsDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IConsumptionPlace {
    formatedPlaceNumber?: string | undefined;
    descriptionWithId?: string | undefined;
    description?: string | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    placeEic?: string | undefined;
    scadaId?: string | undefined;
    regionId?: number | undefined;
    placeId?: string | undefined;
    name?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    payerId?: string | undefined;
    payerName?: string | undefined;
    payerStreet?: string | undefined;
    payerCity?: string | undefined;
    payerZipCode?: string | undefined;
    payerIdentificationNumber?: string | undefined;
    contractNumber?: string | undefined;
    dealerIdentification?: string | undefined;
    purchaseCategory?: number | undefined;
    connectionMethod?: number | undefined;
    readingCategory?: number | undefined;
    consumptionTerminated?: boolean | undefined;
    automaticallyImported?: boolean | undefined;
    exportToCis?: boolean | undefined;
    useAlternativeValues?: boolean | undefined;
    created?: Date | undefined;
    modified?: Date | undefined;
    note?: string | undefined;
    group?: string | undefined;
    state?: number | undefined;
    lastDataTimestamp?: Date | undefined;
    lastReadingTimestamp?: Date | undefined;
    workPlace?: string | undefined;
    dataShardId?: number | undefined;
    annualConsumptionMonths?: number | undefined;
    annualConsumptionVolume?: number | undefined;
    annualConsumptionInMwh?: number | undefined;
    deviceSize?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validatedBy?: string | undefined;
    manuallyImported?: boolean | undefined;
    customer?: Customer | undefined;
    validationNote?: string | undefined;
    parentPlaceGuid?: string | undefined;
    payerNote?: string | undefined;
    string1?: string | undefined;
    string2?: string | undefined;
    int1?: number | undefined;
    int2?: number | undefined;
    extendedProperties?: ExtendedProperty[] | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    device?: BaseDevice | undefined;
    deviceSerialNumber?: string | undefined;
    dataTableName?: string | undefined;
    lastReadingTimestampDescription?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: ConsumptionPlaceObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class BusinessRule implements IBusinessRule {
    readonly description?: string | undefined;
    readonly propertyName?: string | undefined;

    constructor(data?: IBusinessRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["Description"];
            (<any>this).propertyName = _data["PropertyName"];
        }
    }

    static fromJS(data: any): BusinessRule {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Description"] = this.description;
        data["PropertyName"] = this.propertyName;
        return data;
    }
}

export interface IBusinessRule {
    description?: string | undefined;
    propertyName?: string | undefined;
}

export class Customer implements ICustomer {
    itemId?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    consumerId?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    phone?: string | undefined;
    note?: string | undefined;
    comment?: string | undefined;
    contactPerson?: string | undefined;
    email?: string | undefined;
    vatPlace?: string | undefined;
    vatNumber?: string | undefined;
    meterNumber?: string | undefined;
    customerNumber?: string | undefined;
    networkNumber?: string | undefined;
    consumerType?: string | undefined;
    bankInfo?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: CustomerObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["ItemId"];
            this.guid = _data["Guid"];
            this.name = _data["Name"];
            this.consumerId = _data["ConsumerId"];
            this.street = _data["Street"];
            this.city = _data["City"];
            this.zipCode = _data["ZipCode"];
            this.phone = _data["Phone"];
            this.note = _data["Note"];
            this.comment = _data["Comment"];
            this.contactPerson = _data["ContactPerson"];
            this.email = _data["Email"];
            this.vatPlace = _data["VatPlace"];
            this.vatNumber = _data["VatNumber"];
            this.meterNumber = _data["MeterNumber"];
            this.customerNumber = _data["CustomerNumber"];
            this.networkNumber = _data["NetworkNumber"];
            this.consumerType = _data["ConsumerType"];
            this.bankInfo = _data["BankInfo"];
            (<any>this).id = _data["Id"];
            this.tag = _data["Tag"];
            (<any>this).syncRoot = _data["SyncRoot"];
            if (Array.isArray(_data["Parent"])) {
                this.parent = [] as any;
                for (let item of _data["Parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["IsDirty"];
            (<any>this).isNew = _data["IsNew"];
            (<any>this).isDeleted = _data["IsDeleted"];
            this.isEdited = _data["IsEdited"];
            (<any>this).objectState = _data["ObjectState"];
            if (Array.isArray(_data["Rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["Rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["IsValid"];
            (<any>this).isInError = _data["IsInError"];
            (<any>this).error = _data["Error"];
            (<any>this).isDirtyHashCode = _data["IsDirtyHashCode"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemId"] = this.itemId;
        data["Guid"] = this.guid;
        data["Name"] = this.name;
        data["ConsumerId"] = this.consumerId;
        data["Street"] = this.street;
        data["City"] = this.city;
        data["ZipCode"] = this.zipCode;
        data["Phone"] = this.phone;
        data["Note"] = this.note;
        data["Comment"] = this.comment;
        data["ContactPerson"] = this.contactPerson;
        data["Email"] = this.email;
        data["VatPlace"] = this.vatPlace;
        data["VatNumber"] = this.vatNumber;
        data["MeterNumber"] = this.meterNumber;
        data["CustomerNumber"] = this.customerNumber;
        data["NetworkNumber"] = this.networkNumber;
        data["ConsumerType"] = this.consumerType;
        data["BankInfo"] = this.bankInfo;
        data["Id"] = this.id;
        data["Tag"] = this.tag;
        data["SyncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["Parent"] = [];
            for (let item of this.parent)
                data["Parent"].push(item);
        }
        data["IsDirty"] = this.isDirty;
        data["IsNew"] = this.isNew;
        data["IsDeleted"] = this.isDeleted;
        data["IsEdited"] = this.isEdited;
        data["ObjectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["Rules"] = [];
            for (let item of this.rules)
                data["Rules"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["IsInError"] = this.isInError;
        data["Error"] = this.error;
        data["IsDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface ICustomer {
    itemId?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    consumerId?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    phone?: string | undefined;
    note?: string | undefined;
    comment?: string | undefined;
    contactPerson?: string | undefined;
    email?: string | undefined;
    vatPlace?: string | undefined;
    vatNumber?: string | undefined;
    meterNumber?: string | undefined;
    customerNumber?: string | undefined;
    networkNumber?: string | undefined;
    consumerType?: string | undefined;
    bankInfo?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: CustomerObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class ExtendedProperty implements IExtendedProperty {
    isEdited?: boolean | undefined;
    placeId?: number | undefined;
    visualPosition?: number | undefined;
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    isReadonly?: boolean | undefined;
    valueAsObject?: any | undefined;

    constructor(data?: IExtendedProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEdited = _data["IsEdited"];
            this.placeId = _data["PlaceId"];
            this.visualPosition = _data["VisualPosition"];
            this.key = _data["Key"];
            this.name = _data["Name"];
            this.value = _data["Value"];
            this.valueType = _data["ValueType"];
            this.isReadonly = _data["IsReadonly"];
            this.valueAsObject = _data["ValueAsObject"];
        }
    }

    static fromJS(data: any): ExtendedProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsEdited"] = this.isEdited;
        data["PlaceId"] = this.placeId;
        data["VisualPosition"] = this.visualPosition;
        data["Key"] = this.key;
        data["Name"] = this.name;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        data["IsReadonly"] = this.isReadonly;
        data["ValueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IExtendedProperty {
    isEdited?: boolean | undefined;
    placeId?: number | undefined;
    visualPosition?: number | undefined;
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    isReadonly?: boolean | undefined;
    valueAsObject?: any | undefined;
}

export class BaseDevice implements IBaseDevice {
    batteryCapacityFieldNames?: string[] | undefined;
    batteryVoltageFieldNames?: string[] | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    readonly tags?: any[] | undefined;
    readonly alarms?: any[] | undefined;
    readonly alarmCount?: number | undefined;
    readonly tagCount?: number | undefined;
    consumptionPlaceGuid?: string | undefined;
    serialNumber?: string | undefined;
    identificationNumber?: string | undefined;
    location?: string | undefined;
    gpsCoordinates?: string | undefined;
    type?: BaseDeviceType | undefined;
    readonly deviceTypeName?: string | undefined;
    deviceTypeDescriptionId?: number | undefined;
    typeDescription?: DeviceTypeDescription | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    useSecondaryConnection?: boolean | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    convertCoefficient?: number | undefined;
    gasDayBegin?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    note?: string | undefined;
    readProcessState?: BaseDeviceReadProcessState | undefined;
    readonly readProcessStateText?: string | undefined;
    logCommunication?: boolean | undefined;
    callRepeat?: number | undefined;
    chromatographGuid?: string | undefined;
    chromatographPeriod?: BaseDeviceChromatographPeriod | undefined;
    chromatograph?: string | undefined;
    firmwareVersion?: string | undefined;
    softwareVersion?: string | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    kind?: BaseDeviceKind | undefined;
    readonly hasConnectedChromatograph?: boolean | undefined;
    chromatographFieldName?: string | undefined;
    readProgress?: number | undefined;
    readProcessDescription?: string | undefined;
    readConnectionDescription?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
    fireAlarmOnReadingFailure?: boolean | undefined;
    readingFailureAlarmId?: number | undefined;
    consumptionPlaceName?: string | undefined;
    readPriority?: number | undefined;
    configurationRequired?: boolean | undefined;
    parentDeviceGuid?: string | undefined;
    childProperties?: string | undefined;
    serializedTags?: string | undefined;
    serializedAlarms?: string | undefined;
    loadDataFromChannel?: number | undefined;
    negativeValuesEnabled?: boolean | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    sourceDataPeriod?: BaseDeviceSourceDataPeriod | undefined;
    readonly hasNonstandardSourceDataPeriod?: boolean | undefined;
    afterReadingErrorWaitTimeout?: number | undefined;
    valveAction?: BaseDeviceValveAction | undefined;
    valveState?: BaseDeviceValveState | undefined;
    readAllChannels?: boolean | undefined;
    readonly readingFailure?: boolean | undefined;
    readonly readingDone?: boolean | undefined;
    readonly checkNewDataTimeStamp?: boolean | undefined;
    readonly newDataMaxTimeStampDivergence?: number | undefined;
    readonly isBackwardCallSupported?: boolean | undefined;
    readonly archiveDataOverlay?: number | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: BaseDeviceObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IBaseDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["BatteryCapacityFieldNames"])) {
                this.batteryCapacityFieldNames = [] as any;
                for (let item of _data["BatteryCapacityFieldNames"])
                    this.batteryCapacityFieldNames!.push(item);
            }
            if (Array.isArray(_data["BatteryVoltageFieldNames"])) {
                this.batteryVoltageFieldNames = [] as any;
                for (let item of _data["BatteryVoltageFieldNames"])
                    this.batteryVoltageFieldNames!.push(item);
            }
            this.itemId = _data["ItemId"];
            this.guid = _data["Guid"];
            if (Array.isArray(_data["Tags"])) {
                (<any>this).tags = [] as any;
                for (let item of _data["Tags"])
                    (<any>this).tags!.push(item);
            }
            if (Array.isArray(_data["Alarms"])) {
                (<any>this).alarms = [] as any;
                for (let item of _data["Alarms"])
                    (<any>this).alarms!.push(item);
            }
            (<any>this).alarmCount = _data["AlarmCount"];
            (<any>this).tagCount = _data["TagCount"];
            this.consumptionPlaceGuid = _data["ConsumptionPlaceGuid"];
            this.serialNumber = _data["SerialNumber"];
            this.identificationNumber = _data["IdentificationNumber"];
            this.location = _data["Location"];
            this.gpsCoordinates = _data["GpsCoordinates"];
            this.type = _data["Type"];
            (<any>this).deviceTypeName = _data["DeviceTypeName"];
            this.deviceTypeDescriptionId = _data["DeviceTypeDescriptionId"];
            this.typeDescription = _data["TypeDescription"] ? DeviceTypeDescription.fromJS(_data["TypeDescription"]) : <any>undefined;
            this.primaryConnectionNumber = _data["PrimaryConnectionNumber"];
            this.secondaryConnectionNumber = _data["SecondaryConnectionNumber"];
            this.useSecondaryConnection = _data["UseSecondaryConnection"];
            this.primaryConnectionType = _data["PrimaryConnectionType"];
            this.secondaryConnectionType = _data["SecondaryConnectionType"];
            this.convertCoefficient = _data["ConvertCoefficient"];
            this.gasDayBegin = _data["GasDayBegin"];
            this.primaryDeviceDriverId = _data["PrimaryDeviceDriverId"];
            this.secondaryDeviceDriverId = _data["SecondaryDeviceDriverId"];
            this.note = _data["Note"];
            this.readProcessState = _data["ReadProcessState"];
            (<any>this).readProcessStateText = _data["ReadProcessStateText"];
            this.logCommunication = _data["LogCommunication"];
            this.callRepeat = _data["CallRepeat"];
            this.chromatographGuid = _data["ChromatographGuid"];
            this.chromatographPeriod = _data["ChromatographPeriod"];
            this.chromatograph = _data["Chromatograph"];
            this.firmwareVersion = _data["FirmwareVersion"];
            this.softwareVersion = _data["SoftwareVersion"];
            this.batteryCapacity = _data["BatteryCapacity"];
            this.batteryVoltage = _data["BatteryVoltage"];
            this.maxReadingTimeInMinutes = _data["MaxReadingTimeInMinutes"];
            this.kind = _data["Kind"];
            (<any>this).hasConnectedChromatograph = _data["HasConnectedChromatograph"];
            this.chromatographFieldName = _data["ChromatographFieldName"];
            this.readProgress = _data["ReadProgress"];
            this.readProcessDescription = _data["ReadProcessDescription"];
            this.readConnectionDescription = _data["ReadConnectionDescription"];
            this.schedulerName = _data["SchedulerName"];
            this.schedulerTime = _data["SchedulerTime"] ? new Date(_data["SchedulerTime"].toString()) : <any>undefined;
            this.manualReadingTime = _data["ManualReadingTime"] ? new Date(_data["ManualReadingTime"].toString()) : <any>undefined;
            this.fireAlarmOnReadingFailure = _data["FireAlarmOnReadingFailure"];
            this.readingFailureAlarmId = _data["ReadingFailureAlarmId"];
            this.consumptionPlaceName = _data["ConsumptionPlaceName"];
            this.readPriority = _data["ReadPriority"];
            this.configurationRequired = _data["ConfigurationRequired"];
            this.parentDeviceGuid = _data["ParentDeviceGuid"];
            this.childProperties = _data["ChildProperties"];
            this.serializedTags = _data["SerializedTags"];
            this.serializedAlarms = _data["SerializedAlarms"];
            this.loadDataFromChannel = _data["LoadDataFromChannel"];
            this.negativeValuesEnabled = _data["NegativeValuesEnabled"];
            this.primaryChannelGuid = _data["PrimaryChannelGuid"];
            this.secondaryChannelGuid = _data["SecondaryChannelGuid"];
            this.sourceDataPeriod = _data["SourceDataPeriod"];
            (<any>this).hasNonstandardSourceDataPeriod = _data["HasNonstandardSourceDataPeriod"];
            this.afterReadingErrorWaitTimeout = _data["AfterReadingErrorWaitTimeout"];
            this.valveAction = _data["ValveAction"];
            this.valveState = _data["ValveState"];
            this.readAllChannels = _data["ReadAllChannels"];
            (<any>this).readingFailure = _data["ReadingFailure"];
            (<any>this).readingDone = _data["ReadingDone"];
            (<any>this).checkNewDataTimeStamp = _data["CheckNewDataTimeStamp"];
            (<any>this).newDataMaxTimeStampDivergence = _data["NewDataMaxTimeStampDivergence"];
            (<any>this).isBackwardCallSupported = _data["IsBackwardCallSupported"];
            (<any>this).archiveDataOverlay = _data["ArchiveDataOverlay"];
            (<any>this).id = _data["Id"];
            this.tag = _data["Tag"];
            (<any>this).syncRoot = _data["SyncRoot"];
            if (Array.isArray(_data["Parent"])) {
                this.parent = [] as any;
                for (let item of _data["Parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["IsDirty"];
            (<any>this).isNew = _data["IsNew"];
            (<any>this).isDeleted = _data["IsDeleted"];
            this.isEdited = _data["IsEdited"];
            (<any>this).objectState = _data["ObjectState"];
            if (Array.isArray(_data["Rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["Rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["IsValid"];
            (<any>this).isInError = _data["IsInError"];
            (<any>this).error = _data["Error"];
            (<any>this).isDirtyHashCode = _data["IsDirtyHashCode"];
        }
    }

    static fromJS(data: any): BaseDevice {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.batteryCapacityFieldNames)) {
            data["BatteryCapacityFieldNames"] = [];
            for (let item of this.batteryCapacityFieldNames)
                data["BatteryCapacityFieldNames"].push(item);
        }
        if (Array.isArray(this.batteryVoltageFieldNames)) {
            data["BatteryVoltageFieldNames"] = [];
            for (let item of this.batteryVoltageFieldNames)
                data["BatteryVoltageFieldNames"].push(item);
        }
        data["ItemId"] = this.itemId;
        data["Guid"] = this.guid;
        if (Array.isArray(this.tags)) {
            data["Tags"] = [];
            for (let item of this.tags)
                data["Tags"].push(item);
        }
        if (Array.isArray(this.alarms)) {
            data["Alarms"] = [];
            for (let item of this.alarms)
                data["Alarms"].push(item);
        }
        data["AlarmCount"] = this.alarmCount;
        data["TagCount"] = this.tagCount;
        data["ConsumptionPlaceGuid"] = this.consumptionPlaceGuid;
        data["SerialNumber"] = this.serialNumber;
        data["IdentificationNumber"] = this.identificationNumber;
        data["Location"] = this.location;
        data["GpsCoordinates"] = this.gpsCoordinates;
        data["Type"] = this.type;
        data["DeviceTypeName"] = this.deviceTypeName;
        data["DeviceTypeDescriptionId"] = this.deviceTypeDescriptionId;
        data["TypeDescription"] = this.typeDescription ? this.typeDescription.toJSON() : <any>undefined;
        data["PrimaryConnectionNumber"] = this.primaryConnectionNumber;
        data["SecondaryConnectionNumber"] = this.secondaryConnectionNumber;
        data["UseSecondaryConnection"] = this.useSecondaryConnection;
        data["PrimaryConnectionType"] = this.primaryConnectionType;
        data["SecondaryConnectionType"] = this.secondaryConnectionType;
        data["ConvertCoefficient"] = this.convertCoefficient;
        data["GasDayBegin"] = this.gasDayBegin;
        data["PrimaryDeviceDriverId"] = this.primaryDeviceDriverId;
        data["SecondaryDeviceDriverId"] = this.secondaryDeviceDriverId;
        data["Note"] = this.note;
        data["ReadProcessState"] = this.readProcessState;
        data["ReadProcessStateText"] = this.readProcessStateText;
        data["LogCommunication"] = this.logCommunication;
        data["CallRepeat"] = this.callRepeat;
        data["ChromatographGuid"] = this.chromatographGuid;
        data["ChromatographPeriod"] = this.chromatographPeriod;
        data["Chromatograph"] = this.chromatograph;
        data["FirmwareVersion"] = this.firmwareVersion;
        data["SoftwareVersion"] = this.softwareVersion;
        data["BatteryCapacity"] = this.batteryCapacity;
        data["BatteryVoltage"] = this.batteryVoltage;
        data["MaxReadingTimeInMinutes"] = this.maxReadingTimeInMinutes;
        data["Kind"] = this.kind;
        data["HasConnectedChromatograph"] = this.hasConnectedChromatograph;
        data["ChromatographFieldName"] = this.chromatographFieldName;
        data["ReadProgress"] = this.readProgress;
        data["ReadProcessDescription"] = this.readProcessDescription;
        data["ReadConnectionDescription"] = this.readConnectionDescription;
        data["SchedulerName"] = this.schedulerName;
        data["SchedulerTime"] = this.schedulerTime ? this.schedulerTime.toISOString() : <any>undefined;
        data["ManualReadingTime"] = this.manualReadingTime ? this.manualReadingTime.toISOString() : <any>undefined;
        data["FireAlarmOnReadingFailure"] = this.fireAlarmOnReadingFailure;
        data["ReadingFailureAlarmId"] = this.readingFailureAlarmId;
        data["ConsumptionPlaceName"] = this.consumptionPlaceName;
        data["ReadPriority"] = this.readPriority;
        data["ConfigurationRequired"] = this.configurationRequired;
        data["ParentDeviceGuid"] = this.parentDeviceGuid;
        data["ChildProperties"] = this.childProperties;
        data["SerializedTags"] = this.serializedTags;
        data["SerializedAlarms"] = this.serializedAlarms;
        data["LoadDataFromChannel"] = this.loadDataFromChannel;
        data["NegativeValuesEnabled"] = this.negativeValuesEnabled;
        data["PrimaryChannelGuid"] = this.primaryChannelGuid;
        data["SecondaryChannelGuid"] = this.secondaryChannelGuid;
        data["SourceDataPeriod"] = this.sourceDataPeriod;
        data["HasNonstandardSourceDataPeriod"] = this.hasNonstandardSourceDataPeriod;
        data["AfterReadingErrorWaitTimeout"] = this.afterReadingErrorWaitTimeout;
        data["ValveAction"] = this.valveAction;
        data["ValveState"] = this.valveState;
        data["ReadAllChannels"] = this.readAllChannels;
        data["ReadingFailure"] = this.readingFailure;
        data["ReadingDone"] = this.readingDone;
        data["CheckNewDataTimeStamp"] = this.checkNewDataTimeStamp;
        data["NewDataMaxTimeStampDivergence"] = this.newDataMaxTimeStampDivergence;
        data["IsBackwardCallSupported"] = this.isBackwardCallSupported;
        data["ArchiveDataOverlay"] = this.archiveDataOverlay;
        data["Id"] = this.id;
        data["Tag"] = this.tag;
        data["SyncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["Parent"] = [];
            for (let item of this.parent)
                data["Parent"].push(item);
        }
        data["IsDirty"] = this.isDirty;
        data["IsNew"] = this.isNew;
        data["IsDeleted"] = this.isDeleted;
        data["IsEdited"] = this.isEdited;
        data["ObjectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["Rules"] = [];
            for (let item of this.rules)
                data["Rules"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["IsInError"] = this.isInError;
        data["Error"] = this.error;
        data["IsDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IBaseDevice {
    batteryCapacityFieldNames?: string[] | undefined;
    batteryVoltageFieldNames?: string[] | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    tags?: any[] | undefined;
    alarms?: any[] | undefined;
    alarmCount?: number | undefined;
    tagCount?: number | undefined;
    consumptionPlaceGuid?: string | undefined;
    serialNumber?: string | undefined;
    identificationNumber?: string | undefined;
    location?: string | undefined;
    gpsCoordinates?: string | undefined;
    type?: BaseDeviceType | undefined;
    deviceTypeName?: string | undefined;
    deviceTypeDescriptionId?: number | undefined;
    typeDescription?: DeviceTypeDescription | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    useSecondaryConnection?: boolean | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    convertCoefficient?: number | undefined;
    gasDayBegin?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    note?: string | undefined;
    readProcessState?: BaseDeviceReadProcessState | undefined;
    readProcessStateText?: string | undefined;
    logCommunication?: boolean | undefined;
    callRepeat?: number | undefined;
    chromatographGuid?: string | undefined;
    chromatographPeriod?: BaseDeviceChromatographPeriod | undefined;
    chromatograph?: string | undefined;
    firmwareVersion?: string | undefined;
    softwareVersion?: string | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    kind?: BaseDeviceKind | undefined;
    hasConnectedChromatograph?: boolean | undefined;
    chromatographFieldName?: string | undefined;
    readProgress?: number | undefined;
    readProcessDescription?: string | undefined;
    readConnectionDescription?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
    fireAlarmOnReadingFailure?: boolean | undefined;
    readingFailureAlarmId?: number | undefined;
    consumptionPlaceName?: string | undefined;
    readPriority?: number | undefined;
    configurationRequired?: boolean | undefined;
    parentDeviceGuid?: string | undefined;
    childProperties?: string | undefined;
    serializedTags?: string | undefined;
    serializedAlarms?: string | undefined;
    loadDataFromChannel?: number | undefined;
    negativeValuesEnabled?: boolean | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    sourceDataPeriod?: BaseDeviceSourceDataPeriod | undefined;
    hasNonstandardSourceDataPeriod?: boolean | undefined;
    afterReadingErrorWaitTimeout?: number | undefined;
    valveAction?: BaseDeviceValveAction | undefined;
    valveState?: BaseDeviceValveState | undefined;
    readAllChannels?: boolean | undefined;
    readingFailure?: boolean | undefined;
    readingDone?: boolean | undefined;
    checkNewDataTimeStamp?: boolean | undefined;
    newDataMaxTimeStampDivergence?: number | undefined;
    isBackwardCallSupported?: boolean | undefined;
    archiveDataOverlay?: number | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: BaseDeviceObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class DeviceTypeDescription implements IDeviceTypeDescription {
    itemId?: number | undefined;
    code?: number | undefined;
    textCode?: string | undefined;
    description?: string | undefined;
    type?: DeviceTypeDescriptionType | undefined;
    isRecounter?: boolean | undefined;
    readonly title?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: DeviceTypeDescriptionObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IDeviceTypeDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["ItemId"];
            this.code = _data["Code"];
            this.textCode = _data["TextCode"];
            this.description = _data["Description"];
            this.type = _data["Type"];
            this.isRecounter = _data["IsRecounter"];
            (<any>this).title = _data["Title"];
            (<any>this).id = _data["Id"];
            this.tag = _data["Tag"];
            (<any>this).syncRoot = _data["SyncRoot"];
            if (Array.isArray(_data["Parent"])) {
                this.parent = [] as any;
                for (let item of _data["Parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["IsDirty"];
            (<any>this).isNew = _data["IsNew"];
            (<any>this).isDeleted = _data["IsDeleted"];
            this.isEdited = _data["IsEdited"];
            (<any>this).objectState = _data["ObjectState"];
            if (Array.isArray(_data["Rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["Rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["IsValid"];
            (<any>this).isInError = _data["IsInError"];
            (<any>this).error = _data["Error"];
            (<any>this).isDirtyHashCode = _data["IsDirtyHashCode"];
        }
    }

    static fromJS(data: any): DeviceTypeDescription {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTypeDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ItemId"] = this.itemId;
        data["Code"] = this.code;
        data["TextCode"] = this.textCode;
        data["Description"] = this.description;
        data["Type"] = this.type;
        data["IsRecounter"] = this.isRecounter;
        data["Title"] = this.title;
        data["Id"] = this.id;
        data["Tag"] = this.tag;
        data["SyncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["Parent"] = [];
            for (let item of this.parent)
                data["Parent"].push(item);
        }
        data["IsDirty"] = this.isDirty;
        data["IsNew"] = this.isNew;
        data["IsDeleted"] = this.isDeleted;
        data["IsEdited"] = this.isEdited;
        data["ObjectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["Rules"] = [];
            for (let item of this.rules)
                data["Rules"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["IsInError"] = this.isInError;
        data["Error"] = this.error;
        data["IsDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IDeviceTypeDescription {
    itemId?: number | undefined;
    code?: number | undefined;
    textCode?: string | undefined;
    description?: string | undefined;
    type?: DeviceTypeDescriptionType | undefined;
    isRecounter?: boolean | undefined;
    title?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: DeviceTypeDescriptionObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class AlarmPage implements IAlarmPage {
    pageItems?: Alarm[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IAlarmPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(Alarm.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): AlarmPage {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IAlarmPage {
    pageItems?: Alarm[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Alarm implements IAlarm {
    id?: number | undefined;
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    timeWritten?: string | undefined;
    timeTerminated?: string | undefined;
    timeAcknowledged?: string | undefined;
    timeAnnotated?: string | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;

    constructor(data?: IAlarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeGenerated = _data["timeGenerated"];
            this.timeGeneratedRelative = _data["timeGeneratedRelative"];
            this.timeWritten = _data["timeWritten"];
            this.timeTerminated = _data["timeTerminated"];
            this.timeAcknowledged = _data["timeAcknowledged"];
            this.timeAnnotated = _data["timeAnnotated"];
            this.alarmID = _data["alarmID"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.acknowledgeUser = _data["acknowledgeUser"];
            this.annotationUser = _data["annotationUser"];
            this.device = _data["device"];
            this.tagName = _data["tagName"];
            this.tagValue = _data["tagValue"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.note = _data["note"];
            this.acknowledgementRequired = _data["acknowledgementRequired"];
            this.acknowledged = _data["acknowledged"];
            this.isActive = _data["isActive"];
            this.regionId = _data["regionId"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): Alarm {
        data = typeof data === 'object' ? data : {};
        let result = new Alarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeGenerated"] = this.timeGenerated;
        data["timeGeneratedRelative"] = this.timeGeneratedRelative;
        data["timeWritten"] = this.timeWritten;
        data["timeTerminated"] = this.timeTerminated;
        data["timeAcknowledged"] = this.timeAcknowledged;
        data["timeAnnotated"] = this.timeAnnotated;
        data["alarmID"] = this.alarmID;
        data["source"] = this.source;
        data["category"] = this.category;
        data["acknowledgeUser"] = this.acknowledgeUser;
        data["annotationUser"] = this.annotationUser;
        data["device"] = this.device;
        data["tagName"] = this.tagName;
        data["tagValue"] = this.tagValue;
        data["message"] = this.message;
        data["data"] = this.data;
        data["note"] = this.note;
        data["acknowledgementRequired"] = this.acknowledgementRequired;
        data["acknowledged"] = this.acknowledged;
        data["isActive"] = this.isActive;
        data["regionId"] = this.regionId;
        data["region"] = this.region;
        return data;
    }
}

export interface IAlarm {
    id?: number | undefined;
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    timeWritten?: string | undefined;
    timeTerminated?: string | undefined;
    timeAcknowledged?: string | undefined;
    timeAnnotated?: string | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
}

export class AlarmsAnnotation implements IAlarmsAnnotation {
    alarmsIds?: number[] | undefined;
    note?: string | undefined;

    constructor(data?: IAlarmsAnnotation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["AlarmsIds"])) {
                this.alarmsIds = [] as any;
                for (let item of _data["AlarmsIds"])
                    this.alarmsIds!.push(item);
            }
            this.note = _data["Note"];
        }
    }

    static fromJS(data: any): AlarmsAnnotation {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmsAnnotation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alarmsIds)) {
            data["AlarmsIds"] = [];
            for (let item of this.alarmsIds)
                data["AlarmsIds"].push(item);
        }
        data["Note"] = this.note;
        return data;
    }
}

export interface IAlarmsAnnotation {
    alarmsIds?: number[] | undefined;
    note?: string | undefined;
}

export class Login implements ILogin {
    name!: string;
    password!: string;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILogin {
    name: string;
    password: string;
}

export class ConnectedUserLite implements IConnectedUserLite {
    fullName?: string | undefined;
    logOnName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    comment?: string | undefined;
    lastAccessTimestamp?: string | undefined;
    lastAccessRelative?: string | undefined;
    logOnTimestamp?: string | undefined;
    lastClientVersion?: string | undefined;
    systemRole?: string | undefined;
    internetRole?: string | undefined;
    clientType?: string | undefined;
    clientTypeDescription?: string | undefined;
    isItMe?: boolean | undefined;
    encodedSessionId?: string | undefined;
    sessionId?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: IConnectedUserLite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.logOnName = _data["logOnName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.comment = _data["comment"];
            this.lastAccessTimestamp = _data["lastAccessTimestamp"];
            this.lastAccessRelative = _data["lastAccessRelative"];
            this.logOnTimestamp = _data["logOnTimestamp"];
            this.lastClientVersion = _data["lastClientVersion"];
            this.systemRole = _data["systemRole"];
            this.internetRole = _data["internetRole"];
            this.clientType = _data["clientType"];
            this.clientTypeDescription = _data["clientTypeDescription"];
            this.isItMe = _data["isItMe"];
            this.encodedSessionId = _data["encodedSessionId"];
            this.sessionId = _data["sessionId"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): ConnectedUserLite {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectedUserLite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["logOnName"] = this.logOnName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["comment"] = this.comment;
        data["lastAccessTimestamp"] = this.lastAccessTimestamp;
        data["lastAccessRelative"] = this.lastAccessRelative;
        data["logOnTimestamp"] = this.logOnTimestamp;
        data["lastClientVersion"] = this.lastClientVersion;
        data["systemRole"] = this.systemRole;
        data["internetRole"] = this.internetRole;
        data["clientType"] = this.clientType;
        data["clientTypeDescription"] = this.clientTypeDescription;
        data["isItMe"] = this.isItMe;
        data["encodedSessionId"] = this.encodedSessionId;
        data["sessionId"] = this.sessionId;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IConnectedUserLite {
    fullName?: string | undefined;
    logOnName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    comment?: string | undefined;
    lastAccessTimestamp?: string | undefined;
    lastAccessRelative?: string | undefined;
    logOnTimestamp?: string | undefined;
    lastClientVersion?: string | undefined;
    systemRole?: string | undefined;
    internetRole?: string | undefined;
    clientType?: string | undefined;
    clientTypeDescription?: string | undefined;
    isItMe?: boolean | undefined;
    encodedSessionId?: string | undefined;
    sessionId?: string | undefined;
    apiKey?: string | undefined;
}

export class CallStatisticPage implements ICallStatisticPage {
    pageItems?: CallStatisticItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ICallStatisticPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(CallStatisticItem.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): CallStatisticPage {
        data = typeof data === 'object' ? data : {};
        let result = new CallStatisticPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface ICallStatisticPage {
    pageItems?: CallStatisticItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class CallStatisticItem implements ICallStatisticItem {
    readingStart?: Date | undefined;
    callsTimeInSeconds?: number | undefined;
    requestStatus?: string | undefined;
    requestStatusDescription?: string | undefined;
    successfullyWrittenDeviceParams?: string | undefined;
    unsuccessfullyWrittenDeviceParams?: string | undefined;
    writeDeviceParamsStatusDescription?: string | undefined;

    constructor(data?: ICallStatisticItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.readingStart = _data["ReadingStart"] ? new Date(_data["ReadingStart"].toString()) : <any>undefined;
            this.callsTimeInSeconds = _data["CallsTimeInSeconds"];
            this.requestStatus = _data["RequestStatus"];
            this.requestStatusDescription = _data["RequestStatusDescription"];
            this.successfullyWrittenDeviceParams = _data["SuccessfullyWrittenDeviceParams"];
            this.unsuccessfullyWrittenDeviceParams = _data["UnsuccessfullyWrittenDeviceParams"];
            this.writeDeviceParamsStatusDescription = _data["WriteDeviceParamsStatusDescription"];
        }
    }

    static fromJS(data: any): CallStatisticItem {
        data = typeof data === 'object' ? data : {};
        let result = new CallStatisticItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ReadingStart"] = this.readingStart ? this.readingStart.toISOString() : <any>undefined;
        data["CallsTimeInSeconds"] = this.callsTimeInSeconds;
        data["RequestStatus"] = this.requestStatus;
        data["RequestStatusDescription"] = this.requestStatusDescription;
        data["SuccessfullyWrittenDeviceParams"] = this.successfullyWrittenDeviceParams;
        data["UnsuccessfullyWrittenDeviceParams"] = this.unsuccessfullyWrittenDeviceParams;
        data["WriteDeviceParamsStatusDescription"] = this.writeDeviceParamsStatusDescription;
        return data;
    }
}

export interface ICallStatisticItem {
    readingStart?: Date | undefined;
    callsTimeInSeconds?: number | undefined;
    requestStatus?: string | undefined;
    requestStatusDescription?: string | undefined;
    successfullyWrittenDeviceParams?: string | undefined;
    unsuccessfullyWrittenDeviceParams?: string | undefined;
    writeDeviceParamsStatusDescription?: string | undefined;
}

export class ChartData implements IChartData {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    successRate?: { [key: string]: number; } | undefined;
    readingTimeDuration?: { [key: string]: number; } | undefined;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["Ok"]) {
                this.ok = {} as any;
                for (let key in _data["Ok"]) {
                    if (_data["Ok"].hasOwnProperty(key))
                        (<any>this.ok)![key] = _data["Ok"][key];
                }
            }
            if (_data["Failures"]) {
                this.failures = {} as any;
                for (let key in _data["Failures"]) {
                    if (_data["Failures"].hasOwnProperty(key))
                        (<any>this.failures)![key] = _data["Failures"][key];
                }
            }
            if (_data["SuccessRate"]) {
                this.successRate = {} as any;
                for (let key in _data["SuccessRate"]) {
                    if (_data["SuccessRate"].hasOwnProperty(key))
                        (<any>this.successRate)![key] = _data["SuccessRate"][key];
                }
            }
            if (_data["ReadingTimeDuration"]) {
                this.readingTimeDuration = {} as any;
                for (let key in _data["ReadingTimeDuration"]) {
                    if (_data["ReadingTimeDuration"].hasOwnProperty(key))
                        (<any>this.readingTimeDuration)![key] = _data["ReadingTimeDuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChartData {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ok) {
            data["Ok"] = {};
            for (let key in this.ok) {
                if (this.ok.hasOwnProperty(key))
                    (<any>data["Ok"])[key] = (<any>this.ok)[key];
            }
        }
        if (this.failures) {
            data["Failures"] = {};
            for (let key in this.failures) {
                if (this.failures.hasOwnProperty(key))
                    (<any>data["Failures"])[key] = (<any>this.failures)[key];
            }
        }
        if (this.successRate) {
            data["SuccessRate"] = {};
            for (let key in this.successRate) {
                if (this.successRate.hasOwnProperty(key))
                    (<any>data["SuccessRate"])[key] = (<any>this.successRate)[key];
            }
        }
        if (this.readingTimeDuration) {
            data["ReadingTimeDuration"] = {};
            for (let key in this.readingTimeDuration) {
                if (this.readingTimeDuration.hasOwnProperty(key))
                    (<any>data["ReadingTimeDuration"])[key] = (<any>this.readingTimeDuration)[key];
            }
        }
        return data;
    }
}

export interface IChartData {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    successRate?: { [key: string]: number; } | undefined;
    readingTimeDuration?: { [key: string]: number; } | undefined;
}

export class CallLogs implements ICallLogs {
    items?: CallLogItem[] | undefined;
    count?: number | undefined;

    constructor(data?: ICallLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(CallLogItem.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): CallLogs {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface ICallLogs {
    items?: CallLogItem[] | undefined;
    count?: number | undefined;
}

export class CallLogItem implements ICallLogItem {
    timestamp?: Date | undefined;
    data?: string | undefined;
    status?: string | undefined;
    dataType?: string | undefined;
    packet?: string | undefined;

    constructor(data?: ICallLogItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.data = _data["Data"];
            this.status = _data["Status"];
            this.dataType = _data["DataType"];
            this.packet = _data["Packet"];
        }
    }

    static fromJS(data: any): CallLogItem {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["Data"] = this.data;
        data["Status"] = this.status;
        data["DataType"] = this.dataType;
        data["Packet"] = this.packet;
        return data;
    }
}

export interface ICallLogItem {
    timestamp?: Date | undefined;
    data?: string | undefined;
    status?: string | undefined;
    dataType?: string | undefined;
    packet?: string | undefined;
}

export class CommunicationTestProgress implements ICommunicationTestProgress {
    guid?: string | undefined;
    description?: string | undefined;
    progress?: number | undefined;
    error?: boolean | undefined;
    deviceSerialNumber?: string | undefined;
    operatingAmount?: number | undefined;
    convertAmount?: number | undefined;

    constructor(data?: ICommunicationTestProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["Guid"];
            this.description = _data["Description"];
            this.progress = _data["Progress"];
            this.error = _data["Error"];
            this.deviceSerialNumber = _data["DeviceSerialNumber"];
            this.operatingAmount = _data["OperatingAmount"];
            this.convertAmount = _data["ConvertAmount"];
        }
    }

    static fromJS(data: any): CommunicationTestProgress {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationTestProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["Description"] = this.description;
        data["Progress"] = this.progress;
        data["Error"] = this.error;
        data["DeviceSerialNumber"] = this.deviceSerialNumber;
        data["OperatingAmount"] = this.operatingAmount;
        data["ConvertAmount"] = this.convertAmount;
        return data;
    }
}

export interface ICommunicationTestProgress {
    guid?: string | undefined;
    description?: string | undefined;
    progress?: number | undefined;
    error?: boolean | undefined;
    deviceSerialNumber?: string | undefined;
    operatingAmount?: number | undefined;
    convertAmount?: number | undefined;
}

export class ChangePassword implements IChangePassword {
    oldPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["OldPassword"];
            this.newPassword = _data["NewPassword"];
        }
    }

    static fromJS(data: any): ChangePassword {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OldPassword"] = this.oldPassword;
        data["NewPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePassword {
    oldPassword: string;
    newPassword: string;
}

export class DashboardRoot implements IDashboardRoot {
    dashboardAreas?: DashboardArea[] | undefined;
    count?: number | undefined;
    mainDeviceTotal?: number | undefined;
    balanceTotal?: number | undefined;
    balanceTotalPercentage?: number | undefined;
    subAreaTotal?: number | undefined;
    subAreaTotalPercentage?: number | undefined;
    subAreaTotalTitle?: string | undefined;

    constructor(data?: IDashboardRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DashboardAreas"])) {
                this.dashboardAreas = [] as any;
                for (let item of _data["DashboardAreas"])
                    this.dashboardAreas!.push(DashboardArea.fromJS(item));
            }
            this.count = _data["Count"];
            this.mainDeviceTotal = _data["MainDeviceTotal"];
            this.balanceTotal = _data["BalanceTotal"];
            this.balanceTotalPercentage = _data["BalanceTotalPercentage"];
            this.subAreaTotal = _data["SubAreaTotal"];
            this.subAreaTotalPercentage = _data["SubAreaTotalPercentage"];
            this.subAreaTotalTitle = _data["SubAreaTotalTitle"];
        }
    }

    static fromJS(data: any): DashboardRoot {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dashboardAreas)) {
            data["DashboardAreas"] = [];
            for (let item of this.dashboardAreas)
                data["DashboardAreas"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["MainDeviceTotal"] = this.mainDeviceTotal;
        data["BalanceTotal"] = this.balanceTotal;
        data["BalanceTotalPercentage"] = this.balanceTotalPercentage;
        data["SubAreaTotal"] = this.subAreaTotal;
        data["SubAreaTotalPercentage"] = this.subAreaTotalPercentage;
        data["SubAreaTotalTitle"] = this.subAreaTotalTitle;
        return data;
    }
}

export interface IDashboardRoot {
    dashboardAreas?: DashboardArea[] | undefined;
    count?: number | undefined;
    mainDeviceTotal?: number | undefined;
    balanceTotal?: number | undefined;
    balanceTotalPercentage?: number | undefined;
    subAreaTotal?: number | undefined;
    subAreaTotalPercentage?: number | undefined;
    subAreaTotalTitle?: string | undefined;
}

export class DashboardArea implements IDashboardArea {
    mainDevice?: DashboardItem | undefined;
    regionId?: number | undefined;
    regionName?: string | undefined;
    areaItems?: DashboardAreaItem[] | undefined;
    areaBalance?: number | undefined;
    areaBalancePercentage?: number | undefined;
    areaBalancePercentageTitle?: string | undefined;

    constructor(data?: IDashboardArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainDevice = _data["MainDevice"] ? DashboardItem.fromJS(_data["MainDevice"]) : <any>undefined;
            this.regionId = _data["RegionId"];
            this.regionName = _data["RegionName"];
            if (Array.isArray(_data["AreaItems"])) {
                this.areaItems = [] as any;
                for (let item of _data["AreaItems"])
                    this.areaItems!.push(DashboardAreaItem.fromJS(item));
            }
            this.areaBalance = _data["AreaBalance"];
            this.areaBalancePercentage = _data["AreaBalancePercentage"];
            this.areaBalancePercentageTitle = _data["AreaBalancePercentageTitle"];
        }
    }

    static fromJS(data: any): DashboardArea {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MainDevice"] = this.mainDevice ? this.mainDevice.toJSON() : <any>undefined;
        data["RegionId"] = this.regionId;
        data["RegionName"] = this.regionName;
        if (Array.isArray(this.areaItems)) {
            data["AreaItems"] = [];
            for (let item of this.areaItems)
                data["AreaItems"].push(item.toJSON());
        }
        data["AreaBalance"] = this.areaBalance;
        data["AreaBalancePercentage"] = this.areaBalancePercentage;
        data["AreaBalancePercentageTitle"] = this.areaBalancePercentageTitle;
        return data;
    }
}

export interface IDashboardArea {
    mainDevice?: DashboardItem | undefined;
    regionId?: number | undefined;
    regionName?: string | undefined;
    areaItems?: DashboardAreaItem[] | undefined;
    areaBalance?: number | undefined;
    areaBalancePercentage?: number | undefined;
    areaBalancePercentageTitle?: string | undefined;
}

export class DashboardItem implements IDashboardItem {
    placeGuid?: string | undefined;
    name?: string | undefined;
    dealerIdentification?: string | undefined;
    value?: number | undefined;
    readStatus?: number | undefined;
    connectionMethod?: number | undefined;

    constructor(data?: IDashboardItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeGuid = _data["PlaceGuid"];
            this.name = _data["Name"];
            this.dealerIdentification = _data["DealerIdentification"];
            this.value = _data["Value"];
            this.readStatus = _data["ReadStatus"];
            this.connectionMethod = _data["ConnectionMethod"];
        }
    }

    static fromJS(data: any): DashboardItem {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PlaceGuid"] = this.placeGuid;
        data["Name"] = this.name;
        data["DealerIdentification"] = this.dealerIdentification;
        data["Value"] = this.value;
        data["ReadStatus"] = this.readStatus;
        data["ConnectionMethod"] = this.connectionMethod;
        return data;
    }
}

export interface IDashboardItem {
    placeGuid?: string | undefined;
    name?: string | undefined;
    dealerIdentification?: string | undefined;
    value?: number | undefined;
    readStatus?: number | undefined;
    connectionMethod?: number | undefined;
}

export class DashboardAreaItem implements IDashboardAreaItem {
    name?: string | undefined;
    items?: DashboardItem[] | undefined;
    subTotal?: number | undefined;
    subTotalPercentage?: number | undefined;
    subTotalPercentageTitle?: string | undefined;

    constructor(data?: IDashboardAreaItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(DashboardItem.fromJS(item));
            }
            this.subTotal = _data["SubTotal"];
            this.subTotalPercentage = _data["SubTotalPercentage"];
            this.subTotalPercentageTitle = _data["SubTotalPercentageTitle"];
        }
    }

    static fromJS(data: any): DashboardAreaItem {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardAreaItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["SubTotal"] = this.subTotal;
        data["SubTotalPercentage"] = this.subTotalPercentage;
        data["SubTotalPercentageTitle"] = this.subTotalPercentageTitle;
        return data;
    }
}

export interface IDashboardAreaItem {
    name?: string | undefined;
    items?: DashboardItem[] | undefined;
    subTotal?: number | undefined;
    subTotalPercentage?: number | undefined;
    subTotalPercentageTitle?: string | undefined;
}

export class DashboardVariables implements IDashboardVariables {
    items?: DashboardVariable[] | undefined;
    count?: number | undefined;
    defaultFieldName?: string | undefined;

    constructor(data?: IDashboardVariables) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(DashboardVariable.fromJS(item));
            }
            this.count = _data["Count"];
            this.defaultFieldName = _data["DefaultFieldName"];
        }
    }

    static fromJS(data: any): DashboardVariables {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardVariables();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["DefaultFieldName"] = this.defaultFieldName;
        return data;
    }
}

export interface IDashboardVariables {
    items?: DashboardVariable[] | undefined;
    count?: number | undefined;
    defaultFieldName?: string | undefined;
}

export class DashboardVariable implements IDashboardVariable {
    name?: string | undefined;
    fieldName?: string | undefined;

    constructor(data?: IDashboardVariable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.fieldName = _data["FieldName"];
        }
    }

    static fromJS(data: any): DashboardVariable {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardVariable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["FieldName"] = this.fieldName;
        return data;
    }
}

export interface IDashboardVariable {
    name?: string | undefined;
    fieldName?: string | undefined;
}

export class DashboardMainDevices implements IDashboardMainDevices {
    items?: DashboardMainDevice[] | undefined;
    count?: number | undefined;

    constructor(data?: IDashboardMainDevices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(DashboardMainDevice.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): DashboardMainDevices {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardMainDevices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface IDashboardMainDevices {
    items?: DashboardMainDevice[] | undefined;
    count?: number | undefined;
}

export class DashboardMainDevice implements IDashboardMainDevice {
    mainDeviceGuid?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDashboardMainDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainDeviceGuid = _data["MainDeviceGuid"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): DashboardMainDevice {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardMainDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MainDeviceGuid"] = this.mainDeviceGuid;
        data["Name"] = this.name;
        return data;
    }
}

export interface IDashboardMainDevice {
    mainDeviceGuid?: string | undefined;
    name?: string | undefined;
}

export class DataExportType implements IDataExportType {
    id?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    fileExtension?: string | undefined;

    constructor(data?: IDataExportType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.type = _data["Type"];
            this.description = _data["Description"];
            this.fileExtension = _data["FileExtension"];
        }
    }

    static fromJS(data: any): DataExportType {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Type"] = this.type;
        data["Description"] = this.description;
        data["FileExtension"] = this.fileExtension;
        return data;
    }
}

export interface IDataExportType {
    id?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    fileExtension?: string | undefined;
}

export class DataExportFileParameters implements IDataExportFileParameters {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    leaveDateAsItIs?: boolean | undefined;
    placesIds?: number[] | undefined;
    profilesIds?: number[] | undefined;
    internetAveExportType?: string | undefined;
    exportType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    templateFile?: DataExportTemplateFile | undefined;
    deviceGroupName?: string | undefined;
    clientOutputFileName?: string | undefined;

    constructor(data?: IDataExportFileParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
            this.leaveDateAsItIs = _data["LeaveDateAsItIs"];
            if (Array.isArray(_data["PlacesIds"])) {
                this.placesIds = [] as any;
                for (let item of _data["PlacesIds"])
                    this.placesIds!.push(item);
            }
            if (Array.isArray(_data["ProfilesIds"])) {
                this.profilesIds = [] as any;
                for (let item of _data["ProfilesIds"])
                    this.profilesIds!.push(item);
            }
            this.internetAveExportType = _data["InternetAveExportType"];
            this.exportType = _data["ExportType"];
            this.truncateData = _data["TruncateData"];
            this.withDaylightSavingTime = _data["WithDaylightSavingTime"];
            this.templateFile = _data["TemplateFile"] ? DataExportTemplateFile.fromJS(_data["TemplateFile"]) : <any>undefined;
            this.deviceGroupName = _data["DeviceGroupName"];
            this.clientOutputFileName = _data["ClientOutputFileName"];
        }
    }

    static fromJS(data: any): DataExportFileParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportFileParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["DateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["LeaveDateAsItIs"] = this.leaveDateAsItIs;
        if (Array.isArray(this.placesIds)) {
            data["PlacesIds"] = [];
            for (let item of this.placesIds)
                data["PlacesIds"].push(item);
        }
        if (Array.isArray(this.profilesIds)) {
            data["ProfilesIds"] = [];
            for (let item of this.profilesIds)
                data["ProfilesIds"].push(item);
        }
        data["InternetAveExportType"] = this.internetAveExportType;
        data["ExportType"] = this.exportType;
        data["TruncateData"] = this.truncateData;
        data["WithDaylightSavingTime"] = this.withDaylightSavingTime;
        data["TemplateFile"] = this.templateFile ? this.templateFile.toJSON() : <any>undefined;
        data["DeviceGroupName"] = this.deviceGroupName;
        data["ClientOutputFileName"] = this.clientOutputFileName;
        return data;
    }
}

export interface IDataExportFileParameters {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    leaveDateAsItIs?: boolean | undefined;
    placesIds?: number[] | undefined;
    profilesIds?: number[] | undefined;
    internetAveExportType?: string | undefined;
    exportType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    templateFile?: DataExportTemplateFile | undefined;
    deviceGroupName?: string | undefined;
    clientOutputFileName?: string | undefined;
}

export class DataExportTemplateFile implements IDataExportTemplateFile {
    fileName?: string | undefined;
    contentBase64?: string | undefined;

    constructor(data?: IDataExportTemplateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["FileName"];
            this.contentBase64 = _data["ContentBase64"];
        }
    }

    static fromJS(data: any): DataExportTemplateFile {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportTemplateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FileName"] = this.fileName;
        data["ContentBase64"] = this.contentBase64;
        return data;
    }
}

export interface IDataExportTemplateFile {
    fileName?: string | undefined;
    contentBase64?: string | undefined;
}

export class DataPumpLite implements IDataPumpLite {
    id?: number | undefined;
    eventLogSource?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    typeDescription?: string | undefined;
    enabled?: boolean | undefined;
    inError?: boolean | undefined;
    serverId?: number | undefined;
    regionId?: number | undefined;
    interval?: number | undefined;
    lastExecutionTime?: string | undefined;
    nextExecutionTime?: string | undefined;
    repeatInterval?: string | undefined;
    repeatIntervalDescription?: string | undefined;
    alarmOnErrorEnabled?: boolean | undefined;
    alarmIdOnError?: number | undefined;

    constructor(data?: IDataPumpLite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventLogSource = _data["eventLogSource"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.typeDescription = _data["typeDescription"];
            this.enabled = _data["enabled"];
            this.inError = _data["inError"];
            this.serverId = _data["serverId"];
            this.regionId = _data["regionId"];
            this.interval = _data["interval"];
            this.lastExecutionTime = _data["lastExecutionTime"];
            this.nextExecutionTime = _data["nextExecutionTime"];
            this.repeatInterval = _data["repeatInterval"];
            this.repeatIntervalDescription = _data["repeatIntervalDescription"];
            this.alarmOnErrorEnabled = _data["alarmOnErrorEnabled"];
            this.alarmIdOnError = _data["alarmIdOnError"];
        }
    }

    static fromJS(data: any): DataPumpLite {
        data = typeof data === 'object' ? data : {};
        let result = new DataPumpLite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventLogSource"] = this.eventLogSource;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["typeDescription"] = this.typeDescription;
        data["enabled"] = this.enabled;
        data["inError"] = this.inError;
        data["serverId"] = this.serverId;
        data["regionId"] = this.regionId;
        data["interval"] = this.interval;
        data["lastExecutionTime"] = this.lastExecutionTime;
        data["nextExecutionTime"] = this.nextExecutionTime;
        data["repeatInterval"] = this.repeatInterval;
        data["repeatIntervalDescription"] = this.repeatIntervalDescription;
        data["alarmOnErrorEnabled"] = this.alarmOnErrorEnabled;
        data["alarmIdOnError"] = this.alarmIdOnError;
        return data;
    }
}

export interface IDataPumpLite {
    id?: number | undefined;
    eventLogSource?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    typeDescription?: string | undefined;
    enabled?: boolean | undefined;
    inError?: boolean | undefined;
    serverId?: number | undefined;
    regionId?: number | undefined;
    interval?: number | undefined;
    lastExecutionTime?: string | undefined;
    nextExecutionTime?: string | undefined;
    repeatInterval?: string | undefined;
    repeatIntervalDescription?: string | undefined;
    alarmOnErrorEnabled?: boolean | undefined;
    alarmIdOnError?: number | undefined;
}

export class DataPumpSummary implements IDataPumpSummary {
    systemEvents?: SystemEventPage | undefined;
    lastRunErrors?: number | undefined;
    lastRunSuccessfullySent?: number | undefined;
    lastRunTotal?: number | undefined;
    dataRangeErrors?: number | undefined;
    dataRangeSuccessfullySent?: number | undefined;
    dataRangeTotal?: number | undefined;
    dataRangeFrom?: string | undefined;
    dataRangeTo?: string | undefined;
    noSummaryDataAvailable?: boolean | undefined;
    lastRunSuccessRate?: number | undefined;
    dataRangeSuccessRate?: number | undefined;

    constructor(data?: IDataPumpSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemEvents = _data["systemEvents"] ? SystemEventPage.fromJS(_data["systemEvents"]) : <any>undefined;
            this.lastRunErrors = _data["lastRunErrors"];
            this.lastRunSuccessfullySent = _data["lastRunSuccessfullySent"];
            this.lastRunTotal = _data["lastRunTotal"];
            this.dataRangeErrors = _data["dataRangeErrors"];
            this.dataRangeSuccessfullySent = _data["dataRangeSuccessfullySent"];
            this.dataRangeTotal = _data["dataRangeTotal"];
            this.dataRangeFrom = _data["dataRangeFrom"];
            this.dataRangeTo = _data["dataRangeTo"];
            this.noSummaryDataAvailable = _data["noSummaryDataAvailable"];
            this.lastRunSuccessRate = _data["lastRunSuccessRate"];
            this.dataRangeSuccessRate = _data["dataRangeSuccessRate"];
        }
    }

    static fromJS(data: any): DataPumpSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DataPumpSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemEvents"] = this.systemEvents ? this.systemEvents.toJSON() : <any>undefined;
        data["lastRunErrors"] = this.lastRunErrors;
        data["lastRunSuccessfullySent"] = this.lastRunSuccessfullySent;
        data["lastRunTotal"] = this.lastRunTotal;
        data["dataRangeErrors"] = this.dataRangeErrors;
        data["dataRangeSuccessfullySent"] = this.dataRangeSuccessfullySent;
        data["dataRangeTotal"] = this.dataRangeTotal;
        data["dataRangeFrom"] = this.dataRangeFrom;
        data["dataRangeTo"] = this.dataRangeTo;
        data["noSummaryDataAvailable"] = this.noSummaryDataAvailable;
        data["lastRunSuccessRate"] = this.lastRunSuccessRate;
        data["dataRangeSuccessRate"] = this.dataRangeSuccessRate;
        return data;
    }
}

export interface IDataPumpSummary {
    systemEvents?: SystemEventPage | undefined;
    lastRunErrors?: number | undefined;
    lastRunSuccessfullySent?: number | undefined;
    lastRunTotal?: number | undefined;
    dataRangeErrors?: number | undefined;
    dataRangeSuccessfullySent?: number | undefined;
    dataRangeTotal?: number | undefined;
    dataRangeFrom?: string | undefined;
    dataRangeTo?: string | undefined;
    noSummaryDataAvailable?: boolean | undefined;
    lastRunSuccessRate?: number | undefined;
    dataRangeSuccessRate?: number | undefined;
}

export class SystemEventPage implements ISystemEventPage {
    pageItems?: SystemEvent[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ISystemEventPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(SystemEvent.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): SystemEventPage {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEventPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface ISystemEventPage {
    pageItems?: SystemEvent[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class SystemEvent implements ISystemEvent {
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    type?: string | undefined;
    entryType?: SystemEventEntryType | undefined;
    eventId?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    machine?: string | undefined;

    constructor(data?: ISystemEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeGenerated = _data["timeGenerated"];
            this.timeGeneratedRelative = _data["timeGeneratedRelative"];
            this.type = _data["type"];
            this.entryType = _data["entryType"];
            this.eventId = _data["eventId"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.user = _data["user"];
            this.machine = _data["machine"];
        }
    }

    static fromJS(data: any): SystemEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeGenerated"] = this.timeGenerated;
        data["timeGeneratedRelative"] = this.timeGeneratedRelative;
        data["type"] = this.type;
        data["entryType"] = this.entryType;
        data["eventId"] = this.eventId;
        data["source"] = this.source;
        data["category"] = this.category;
        data["message"] = this.message;
        data["data"] = this.data;
        data["user"] = this.user;
        data["machine"] = this.machine;
        return data;
    }
}

export interface ISystemEvent {
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    type?: string | undefined;
    entryType?: SystemEventEntryType | undefined;
    eventId?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    machine?: string | undefined;
}

export class ChartData1 implements IChartData1 {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    sucessRate?: { [key: string]: number; } | undefined;

    constructor(data?: IChartData1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["Ok"]) {
                this.ok = {} as any;
                for (let key in _data["Ok"]) {
                    if (_data["Ok"].hasOwnProperty(key))
                        (<any>this.ok)![key] = _data["Ok"][key];
                }
            }
            if (_data["Failures"]) {
                this.failures = {} as any;
                for (let key in _data["Failures"]) {
                    if (_data["Failures"].hasOwnProperty(key))
                        (<any>this.failures)![key] = _data["Failures"][key];
                }
            }
            if (_data["SucessRate"]) {
                this.sucessRate = {} as any;
                for (let key in _data["SucessRate"]) {
                    if (_data["SucessRate"].hasOwnProperty(key))
                        (<any>this.sucessRate)![key] = _data["SucessRate"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChartData1 {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ok) {
            data["Ok"] = {};
            for (let key in this.ok) {
                if (this.ok.hasOwnProperty(key))
                    (<any>data["Ok"])[key] = (<any>this.ok)[key];
            }
        }
        if (this.failures) {
            data["Failures"] = {};
            for (let key in this.failures) {
                if (this.failures.hasOwnProperty(key))
                    (<any>data["Failures"])[key] = (<any>this.failures)[key];
            }
        }
        if (this.sucessRate) {
            data["SucessRate"] = {};
            for (let key in this.sucessRate) {
                if (this.sucessRate.hasOwnProperty(key))
                    (<any>data["SucessRate"])[key] = (<any>this.sucessRate)[key];
            }
        }
        return data;
    }
}

export interface IChartData1 {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    sucessRate?: { [key: string]: number; } | undefined;
}

export class ProfilePage implements IProfilePage {
    pageItems?: Profile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IProfilePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(Profile.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ProfilePage {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IProfilePage {
    pageItems?: Profile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Profile implements IProfile {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    created?: string | undefined;
    modified?: string | undefined;
    connectionType?: string | undefined;
    connectionTypeDescription?: string | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.regionId = _data["regionId"];
            this.created = _data["created"];
            this.modified = _data["modified"];
            this.connectionType = _data["connectionType"];
            this.connectionTypeDescription = _data["connectionTypeDescription"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["regionId"] = this.regionId;
        data["created"] = this.created;
        data["modified"] = this.modified;
        data["connectionType"] = this.connectionType;
        data["connectionTypeDescription"] = this.connectionTypeDescription;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IProfile {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    created?: string | undefined;
    modified?: string | undefined;
    connectionType?: string | undefined;
    connectionTypeDescription?: string | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
}

export class DeviceDataParameters implements IDeviceDataParameters {
    fieldNames?: string[] | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    timeFormat?: string | undefined;
    cultureName?: string | undefined;
    line?: string | undefined;
    group?: string | undefined;

    constructor(data?: IDeviceDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["FieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["FieldNames"])
                    this.fieldNames!.push(item);
            }
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
            this.dataType = _data["DataType"];
            this.truncateData = _data["TruncateData"];
            this.withDaylightSavingTime = _data["WithDaylightSavingTime"];
            this.timeFormat = _data["TimeFormat"];
            this.cultureName = _data["CultureName"];
            this.line = _data["Line"];
            this.group = _data["Group"];
        }
    }

    static fromJS(data: any): DeviceDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldNames)) {
            data["FieldNames"] = [];
            for (let item of this.fieldNames)
                data["FieldNames"].push(item);
        }
        data["DateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["DateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["DataType"] = this.dataType;
        data["TruncateData"] = this.truncateData;
        data["WithDaylightSavingTime"] = this.withDaylightSavingTime;
        data["TimeFormat"] = this.timeFormat;
        data["CultureName"] = this.cultureName;
        data["Line"] = this.line;
        data["Group"] = this.group;
        return data;
    }
}

export interface IDeviceDataParameters {
    fieldNames?: string[] | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    timeFormat?: string | undefined;
    cultureName?: string | undefined;
    line?: string | undefined;
    group?: string | undefined;
}

export class SerializableDataTableContainer implements ISerializableDataTableContainer {
    readonly tables?: DataTable[] | undefined;

    constructor(data?: ISerializableDataTableContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["Tables"])
                    (<any>this).tables!.push(DataTable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SerializableDataTableContainer {
        data = typeof data === 'object' ? data : {};
        let result = new SerializableDataTableContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tables)) {
            data["Tables"] = [];
            for (let item of this.tables)
                data["Tables"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISerializableDataTableContainer {
    tables?: DataTable[] | undefined;
}

export class DataTable implements IDataTable {
    caseSensitive?: boolean | undefined;
    readonly isInitialized?: boolean | undefined;
    remotingFormat?: DataTableRemotingFormat | undefined;
    readonly childRelations?: any[] | undefined;
    readonly columns?: any[] | undefined;
    readonly constraints?: any[] | undefined;
    readonly dataSet?: DataSet | undefined;
    readonly defaultView?: any[] | undefined;
    displayExpression?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    readonly hasErrors?: boolean | undefined;
    locale?: string | undefined;
    minimumCapacity?: number | undefined;
    readonly parentRelations?: any[] | undefined;
    primaryKey?: DataColumn[] | undefined;
    readonly rows?: any[] | undefined;
    tableName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    site?: ISite | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseSensitive = _data["CaseSensitive"];
            (<any>this).isInitialized = _data["IsInitialized"];
            this.remotingFormat = _data["RemotingFormat"];
            if (Array.isArray(_data["ChildRelations"])) {
                (<any>this).childRelations = [] as any;
                for (let item of _data["ChildRelations"])
                    (<any>this).childRelations!.push(item);
            }
            if (Array.isArray(_data["Columns"])) {
                (<any>this).columns = [] as any;
                for (let item of _data["Columns"])
                    (<any>this).columns!.push(item);
            }
            if (Array.isArray(_data["Constraints"])) {
                (<any>this).constraints = [] as any;
                for (let item of _data["Constraints"])
                    (<any>this).constraints!.push(item);
            }
            (<any>this).dataSet = _data["DataSet"] ? DataSet.fromJS(_data["DataSet"]) : <any>undefined;
            if (Array.isArray(_data["DefaultView"])) {
                (<any>this).defaultView = [] as any;
                for (let item of _data["DefaultView"])
                    (<any>this).defaultView!.push(item);
            }
            this.displayExpression = _data["DisplayExpression"];
            if (_data["ExtendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["ExtendedProperties"]) {
                    if (_data["ExtendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["ExtendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["HasErrors"];
            this.locale = _data["Locale"];
            this.minimumCapacity = _data["MinimumCapacity"];
            if (Array.isArray(_data["ParentRelations"])) {
                (<any>this).parentRelations = [] as any;
                for (let item of _data["ParentRelations"])
                    (<any>this).parentRelations!.push(item);
            }
            if (Array.isArray(_data["PrimaryKey"])) {
                this.primaryKey = [] as any;
                for (let item of _data["PrimaryKey"])
                    this.primaryKey!.push(DataColumn.fromJS(item));
            }
            if (Array.isArray(_data["Rows"])) {
                (<any>this).rows = [] as any;
                for (let item of _data["Rows"])
                    (<any>this).rows!.push(item);
            }
            this.tableName = _data["TableName"];
            this.namespace = _data["Namespace"];
            this.prefix = _data["Prefix"];
            this.site = _data["Site"] ? ISite.fromJS(_data["Site"]) : <any>undefined;
            (<any>this).container = _data["Container"] ? IContainer.fromJS(_data["Container"]) : <any>undefined;
            (<any>this).designMode = _data["DesignMode"];
        }
    }

    static fromJS(data: any): DataTable {
        data = typeof data === 'object' ? data : {};
        let result = new DataTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CaseSensitive"] = this.caseSensitive;
        data["IsInitialized"] = this.isInitialized;
        data["RemotingFormat"] = this.remotingFormat;
        if (Array.isArray(this.childRelations)) {
            data["ChildRelations"] = [];
            for (let item of this.childRelations)
                data["ChildRelations"].push(item);
        }
        if (Array.isArray(this.columns)) {
            data["Columns"] = [];
            for (let item of this.columns)
                data["Columns"].push(item);
        }
        if (Array.isArray(this.constraints)) {
            data["Constraints"] = [];
            for (let item of this.constraints)
                data["Constraints"].push(item);
        }
        data["DataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultView)) {
            data["DefaultView"] = [];
            for (let item of this.defaultView)
                data["DefaultView"].push(item);
        }
        data["DisplayExpression"] = this.displayExpression;
        if (this.extendedProperties) {
            data["ExtendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["ExtendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["HasErrors"] = this.hasErrors;
        data["Locale"] = this.locale;
        data["MinimumCapacity"] = this.minimumCapacity;
        if (Array.isArray(this.parentRelations)) {
            data["ParentRelations"] = [];
            for (let item of this.parentRelations)
                data["ParentRelations"].push(item);
        }
        if (Array.isArray(this.primaryKey)) {
            data["PrimaryKey"] = [];
            for (let item of this.primaryKey)
                data["PrimaryKey"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["Rows"] = [];
            for (let item of this.rows)
                data["Rows"].push(item);
        }
        data["TableName"] = this.tableName;
        data["Namespace"] = this.namespace;
        data["Prefix"] = this.prefix;
        data["Site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["DesignMode"] = this.designMode;
        return data;
    }
}

export interface IDataTable {
    caseSensitive?: boolean | undefined;
    isInitialized?: boolean | undefined;
    remotingFormat?: DataTableRemotingFormat | undefined;
    childRelations?: any[] | undefined;
    columns?: any[] | undefined;
    constraints?: any[] | undefined;
    dataSet?: DataSet | undefined;
    defaultView?: any[] | undefined;
    displayExpression?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    hasErrors?: boolean | undefined;
    locale?: string | undefined;
    minimumCapacity?: number | undefined;
    parentRelations?: any[] | undefined;
    primaryKey?: DataColumn[] | undefined;
    rows?: any[] | undefined;
    tableName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    site?: ISite | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class DataSet implements IDataSet {
    remotingFormat?: DataSetRemotingFormat | undefined;
    schemaSerializationMode?: DataSetSchemaSerializationMode | undefined;
    caseSensitive?: boolean | undefined;
    readonly defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean | undefined;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    readonly hasErrors?: boolean | undefined;
    readonly isInitialized?: boolean | undefined;
    locale?: string | undefined;
    site?: ISite | undefined;
    readonly relations?: any[] | undefined;
    readonly tables?: any[] | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remotingFormat = _data["RemotingFormat"];
            this.schemaSerializationMode = _data["SchemaSerializationMode"];
            this.caseSensitive = _data["CaseSensitive"];
            if (Array.isArray(_data["DefaultViewManager"])) {
                (<any>this).defaultViewManager = [] as any;
                for (let item of _data["DefaultViewManager"])
                    (<any>this).defaultViewManager!.push(item);
            }
            this.enforceConstraints = _data["EnforceConstraints"];
            this.dataSetName = _data["DataSetName"];
            this.namespace = _data["Namespace"];
            this.prefix = _data["Prefix"];
            if (_data["ExtendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["ExtendedProperties"]) {
                    if (_data["ExtendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["ExtendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["HasErrors"];
            (<any>this).isInitialized = _data["IsInitialized"];
            this.locale = _data["Locale"];
            this.site = _data["Site"] ? ISite.fromJS(_data["Site"]) : <any>undefined;
            if (Array.isArray(_data["Relations"])) {
                (<any>this).relations = [] as any;
                for (let item of _data["Relations"])
                    (<any>this).relations!.push(item);
            }
            if (Array.isArray(_data["Tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["Tables"])
                    (<any>this).tables!.push(item);
            }
            (<any>this).container = _data["Container"] ? IContainer.fromJS(_data["Container"]) : <any>undefined;
            (<any>this).designMode = _data["DesignMode"];
        }
    }

    static fromJS(data: any): DataSet {
        data = typeof data === 'object' ? data : {};
        let result = new DataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RemotingFormat"] = this.remotingFormat;
        data["SchemaSerializationMode"] = this.schemaSerializationMode;
        data["CaseSensitive"] = this.caseSensitive;
        if (Array.isArray(this.defaultViewManager)) {
            data["DefaultViewManager"] = [];
            for (let item of this.defaultViewManager)
                data["DefaultViewManager"].push(item);
        }
        data["EnforceConstraints"] = this.enforceConstraints;
        data["DataSetName"] = this.dataSetName;
        data["Namespace"] = this.namespace;
        data["Prefix"] = this.prefix;
        if (this.extendedProperties) {
            data["ExtendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["ExtendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["HasErrors"] = this.hasErrors;
        data["IsInitialized"] = this.isInitialized;
        data["Locale"] = this.locale;
        data["Site"] = this.site ? this.site.toJSON() : <any>undefined;
        if (Array.isArray(this.relations)) {
            data["Relations"] = [];
            for (let item of this.relations)
                data["Relations"].push(item);
        }
        if (Array.isArray(this.tables)) {
            data["Tables"] = [];
            for (let item of this.tables)
                data["Tables"].push(item);
        }
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["DesignMode"] = this.designMode;
        return data;
    }
}

export interface IDataSet {
    remotingFormat?: DataSetRemotingFormat | undefined;
    schemaSerializationMode?: DataSetSchemaSerializationMode | undefined;
    caseSensitive?: boolean | undefined;
    defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean | undefined;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    hasErrors?: boolean | undefined;
    isInitialized?: boolean | undefined;
    locale?: string | undefined;
    site?: ISite | undefined;
    relations?: any[] | undefined;
    tables?: any[] | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class DataColumn implements IDataColumn {
    allowDBNull?: boolean | undefined;
    autoIncrement?: boolean | undefined;
    autoIncrementSeed?: number | undefined;
    autoIncrementStep?: number | undefined;
    caption?: string | undefined;
    columnName?: string | undefined;
    prefix?: string | undefined;
    dataType?: string | undefined;
    dateTimeMode?: DataColumnDateTimeMode | undefined;
    defaultValue?: any | undefined;
    expression?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    maxLength?: number | undefined;
    namespace?: string | undefined;
    readonly ordinal?: number | undefined;
    readOnly?: boolean | undefined;
    readonly table?: DataTable | undefined;
    unique?: boolean | undefined;
    columnMapping?: DataColumnColumnMapping | undefined;
    site?: ISite | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowDBNull = _data["AllowDBNull"];
            this.autoIncrement = _data["AutoIncrement"];
            this.autoIncrementSeed = _data["AutoIncrementSeed"];
            this.autoIncrementStep = _data["AutoIncrementStep"];
            this.caption = _data["Caption"];
            this.columnName = _data["ColumnName"];
            this.prefix = _data["Prefix"];
            this.dataType = _data["DataType"];
            this.dateTimeMode = _data["DateTimeMode"];
            this.defaultValue = _data["DefaultValue"];
            this.expression = _data["Expression"];
            if (_data["ExtendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["ExtendedProperties"]) {
                    if (_data["ExtendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["ExtendedProperties"][key];
                }
            }
            this.maxLength = _data["MaxLength"];
            this.namespace = _data["Namespace"];
            (<any>this).ordinal = _data["Ordinal"];
            this.readOnly = _data["ReadOnly"];
            (<any>this).table = _data["Table"] ? DataTable.fromJS(_data["Table"]) : <any>undefined;
            this.unique = _data["Unique"];
            this.columnMapping = _data["ColumnMapping"];
            this.site = _data["Site"] ? ISite.fromJS(_data["Site"]) : <any>undefined;
            (<any>this).container = _data["Container"] ? IContainer.fromJS(_data["Container"]) : <any>undefined;
            (<any>this).designMode = _data["DesignMode"];
        }
    }

    static fromJS(data: any): DataColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DataColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AllowDBNull"] = this.allowDBNull;
        data["AutoIncrement"] = this.autoIncrement;
        data["AutoIncrementSeed"] = this.autoIncrementSeed;
        data["AutoIncrementStep"] = this.autoIncrementStep;
        data["Caption"] = this.caption;
        data["ColumnName"] = this.columnName;
        data["Prefix"] = this.prefix;
        data["DataType"] = this.dataType;
        data["DateTimeMode"] = this.dateTimeMode;
        data["DefaultValue"] = this.defaultValue;
        data["Expression"] = this.expression;
        if (this.extendedProperties) {
            data["ExtendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["ExtendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["MaxLength"] = this.maxLength;
        data["Namespace"] = this.namespace;
        data["Ordinal"] = this.ordinal;
        data["ReadOnly"] = this.readOnly;
        data["Table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["Unique"] = this.unique;
        data["ColumnMapping"] = this.columnMapping;
        data["Site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["DesignMode"] = this.designMode;
        return data;
    }
}

export interface IDataColumn {
    allowDBNull?: boolean | undefined;
    autoIncrement?: boolean | undefined;
    autoIncrementSeed?: number | undefined;
    autoIncrementStep?: number | undefined;
    caption?: string | undefined;
    columnName?: string | undefined;
    prefix?: string | undefined;
    dataType?: string | undefined;
    dateTimeMode?: DataColumnDateTimeMode | undefined;
    defaultValue?: any | undefined;
    expression?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    maxLength?: number | undefined;
    namespace?: string | undefined;
    ordinal?: number | undefined;
    readOnly?: boolean | undefined;
    table?: DataTable | undefined;
    unique?: boolean | undefined;
    columnMapping?: DataColumnColumnMapping | undefined;
    site?: ISite | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class ISite implements IISite {
    readonly component?: IComponent | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;
    name?: string | undefined;

    constructor(data?: IISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).component = _data["Component"] ? IComponent.fromJS(_data["Component"]) : <any>undefined;
            (<any>this).container = _data["Container"] ? IContainer.fromJS(_data["Container"]) : <any>undefined;
            (<any>this).designMode = _data["DesignMode"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): ISite {
        data = typeof data === 'object' ? data : {};
        let result = new ISite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["DesignMode"] = this.designMode;
        data["Name"] = this.name;
        return data;
    }
}

export interface IISite {
    component?: IComponent | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
    name?: string | undefined;
}

export class IContainer implements IIContainer {
    readonly components?: any[] | undefined;

    constructor(data?: IIContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["Components"])
                    (<any>this).components!.push(item);
            }
        }
    }

    static fromJS(data: any): IContainer {
        data = typeof data === 'object' ? data : {};
        let result = new IContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["Components"] = [];
            for (let item of this.components)
                data["Components"].push(item);
        }
        return data;
    }
}

export interface IIContainer {
    components?: any[] | undefined;
}

export class IComponent implements IIComponent {
    site?: ISite | undefined;

    constructor(data?: IIComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.site = _data["Site"] ? ISite.fromJS(_data["Site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IComponent {
        data = typeof data === 'object' ? data : {};
        let result = new IComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIComponent {
    site?: ISite | undefined;
}

export class DeviceChartData implements IDeviceChartData {
    fieldNames?: string[] | undefined;
    timeFormat?: string | undefined;
    placeId?: number | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: DeviceChartDataDataType | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    culture?: string | undefined;
    line?: string | undefined;
    leaveDateAsItIs?: boolean | undefined;
    userAccess?: boolean | undefined;
    data?: any | undefined;
    sessionId?: string | undefined;

    constructor(data?: IDeviceChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["FieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["FieldNames"])
                    this.fieldNames!.push(item);
            }
            this.timeFormat = _data["TimeFormat"];
            this.placeId = _data["PlaceId"];
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
            this.dataType = _data["DataType"];
            this.truncateData = _data["TruncateData"];
            this.withDaylightSavingTime = _data["WithDaylightSavingTime"];
            this.culture = _data["Culture"];
            this.line = _data["Line"];
            this.leaveDateAsItIs = _data["LeaveDateAsItIs"];
            this.userAccess = _data["UserAccess"];
            this.data = _data["Data"];
            this.sessionId = _data["SessionId"];
        }
    }

    static fromJS(data: any): DeviceChartData {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldNames)) {
            data["FieldNames"] = [];
            for (let item of this.fieldNames)
                data["FieldNames"].push(item);
        }
        data["TimeFormat"] = this.timeFormat;
        data["PlaceId"] = this.placeId;
        data["DateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["DateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["DataType"] = this.dataType;
        data["TruncateData"] = this.truncateData;
        data["WithDaylightSavingTime"] = this.withDaylightSavingTime;
        data["Culture"] = this.culture;
        data["Line"] = this.line;
        data["LeaveDateAsItIs"] = this.leaveDateAsItIs;
        data["UserAccess"] = this.userAccess;
        data["Data"] = this.data;
        data["SessionId"] = this.sessionId;
        return data;
    }
}

export interface IDeviceChartData {
    fieldNames?: string[] | undefined;
    timeFormat?: string | undefined;
    placeId?: number | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: DeviceChartDataDataType | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    culture?: string | undefined;
    line?: string | undefined;
    leaveDateAsItIs?: boolean | undefined;
    userAccess?: boolean | undefined;
    data?: any | undefined;
    sessionId?: string | undefined;
}

export class MiniWebClientDeviceData implements IMiniWebClientDeviceData {
    place?: Place | undefined;
    line?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;

    constructor(data?: IMiniWebClientDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.place = _data["place"] ? Place.fromJS(_data["place"]) : <any>undefined;
            this.line = _data["line"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): MiniWebClientDeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new MiniWebClientDeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["line"] = this.line;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

export interface IMiniWebClientDeviceData {
    place?: Place | undefined;
    line?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;
}

export class Place implements IPlace {
    id?: number | undefined;
    eic?: string | undefined;
    customerName?: string | undefined;
    placeName?: string | undefined;
    payerName?: string | undefined;
    payerId?: string | undefined;
    customerId?: string | undefined;
    placeId?: string | undefined;
    deviceLocation?: string | undefined;
    terminated?: boolean | undefined;
    region?: string | undefined;
    regionId?: number | undefined;
    connectionMethod?: string | undefined;
    purchaseCategory?: string | undefined;
    convertCoefficient?: number | undefined;
    deviceType?: string | undefined;
    identificationNumber?: string | undefined;
    lastData?: string | undefined;
    deviceSerialNumber?: string | undefined;
    placeStreet?: string | undefined;
    payerStreet?: string | undefined;
    placeCity?: string | undefined;
    payerCity?: string | undefined;
    placeZipCode?: string | undefined;
    payerZipCode?: string | undefined;
    dealer?: string | undefined;
    readingCategory?: string | undefined;
    validatedBy?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validationNote?: string | undefined;
    gps?: string | undefined;
    device?: number | undefined;
    readRequestStatus?: number | undefined;
    readDescription?: string | undefined;
    note?: string | undefined;
    group?: string | undefined;
    workplace?: string | undefined;
    hasTimeWindows?: boolean | undefined;
    hasBattery?: boolean | undefined;
    hasGasComposition?: boolean | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    dailyData?: boolean | undefined;
    scadaId?: string | undefined;
    parentDevice?: string | undefined;

    constructor(data?: IPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.eic = _data["Eic"];
            this.customerName = _data["CustomerName"];
            this.placeName = _data["PlaceName"];
            this.payerName = _data["PayerName"];
            this.payerId = _data["PayerId"];
            this.customerId = _data["CustomerId"];
            this.placeId = _data["PlaceId"];
            this.deviceLocation = _data["DeviceLocation"];
            this.terminated = _data["Terminated"];
            this.region = _data["Region"];
            this.regionId = _data["RegionId"];
            this.connectionMethod = _data["ConnectionMethod"];
            this.purchaseCategory = _data["PurchaseCategory"];
            this.convertCoefficient = _data["ConvertCoefficient"];
            this.deviceType = _data["DeviceType"];
            this.identificationNumber = _data["IdentificationNumber"];
            this.lastData = _data["LastData"];
            this.deviceSerialNumber = _data["DeviceSerialNumber"];
            this.placeStreet = _data["PlaceStreet"];
            this.payerStreet = _data["PayerStreet"];
            this.placeCity = _data["PlaceCity"];
            this.payerCity = _data["PayerCity"];
            this.placeZipCode = _data["PlaceZipCode"];
            this.payerZipCode = _data["PayerZipCode"];
            this.dealer = _data["Dealer"];
            this.readingCategory = _data["ReadingCategory"];
            this.validatedBy = _data["ValidatedBy"];
            this.validatedTill = _data["ValidatedTill"] ? new Date(_data["ValidatedTill"].toString()) : <any>undefined;
            this.isDataValidated = _data["IsDataValidated"];
            this.validationNote = _data["ValidationNote"];
            this.gps = _data["Gps"];
            this.device = _data["Device"];
            this.readRequestStatus = _data["ReadRequestStatus"];
            this.readDescription = _data["ReadDescription"];
            this.note = _data["Note"];
            this.group = _data["Group"];
            this.workplace = _data["Workplace"];
            this.hasTimeWindows = _data["HasTimeWindows"];
            this.hasBattery = _data["HasBattery"];
            this.hasGasComposition = _data["HasGasComposition"];
            this.batteryCapacity = _data["BatteryCapacity"];
            this.batteryVoltage = _data["BatteryVoltage"];
            this.dailyData = _data["DailyData"];
            this.scadaId = _data["ScadaId"];
            this.parentDevice = _data["ParentDevice"];
        }
    }

    static fromJS(data: any): Place {
        data = typeof data === 'object' ? data : {};
        let result = new Place();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Eic"] = this.eic;
        data["CustomerName"] = this.customerName;
        data["PlaceName"] = this.placeName;
        data["PayerName"] = this.payerName;
        data["PayerId"] = this.payerId;
        data["CustomerId"] = this.customerId;
        data["PlaceId"] = this.placeId;
        data["DeviceLocation"] = this.deviceLocation;
        data["Terminated"] = this.terminated;
        data["Region"] = this.region;
        data["RegionId"] = this.regionId;
        data["ConnectionMethod"] = this.connectionMethod;
        data["PurchaseCategory"] = this.purchaseCategory;
        data["ConvertCoefficient"] = this.convertCoefficient;
        data["DeviceType"] = this.deviceType;
        data["IdentificationNumber"] = this.identificationNumber;
        data["LastData"] = this.lastData;
        data["DeviceSerialNumber"] = this.deviceSerialNumber;
        data["PlaceStreet"] = this.placeStreet;
        data["PayerStreet"] = this.payerStreet;
        data["PlaceCity"] = this.placeCity;
        data["PayerCity"] = this.payerCity;
        data["PlaceZipCode"] = this.placeZipCode;
        data["PayerZipCode"] = this.payerZipCode;
        data["Dealer"] = this.dealer;
        data["ReadingCategory"] = this.readingCategory;
        data["ValidatedBy"] = this.validatedBy;
        data["ValidatedTill"] = this.validatedTill ? this.validatedTill.toISOString() : <any>undefined;
        data["IsDataValidated"] = this.isDataValidated;
        data["ValidationNote"] = this.validationNote;
        data["Gps"] = this.gps;
        data["Device"] = this.device;
        data["ReadRequestStatus"] = this.readRequestStatus;
        data["ReadDescription"] = this.readDescription;
        data["Note"] = this.note;
        data["Group"] = this.group;
        data["Workplace"] = this.workplace;
        data["HasTimeWindows"] = this.hasTimeWindows;
        data["HasBattery"] = this.hasBattery;
        data["HasGasComposition"] = this.hasGasComposition;
        data["BatteryCapacity"] = this.batteryCapacity;
        data["BatteryVoltage"] = this.batteryVoltage;
        data["DailyData"] = this.dailyData;
        data["ScadaId"] = this.scadaId;
        data["ParentDevice"] = this.parentDevice;
        return data;
    }
}

export interface IPlace {
    id?: number | undefined;
    eic?: string | undefined;
    customerName?: string | undefined;
    placeName?: string | undefined;
    payerName?: string | undefined;
    payerId?: string | undefined;
    customerId?: string | undefined;
    placeId?: string | undefined;
    deviceLocation?: string | undefined;
    terminated?: boolean | undefined;
    region?: string | undefined;
    regionId?: number | undefined;
    connectionMethod?: string | undefined;
    purchaseCategory?: string | undefined;
    convertCoefficient?: number | undefined;
    deviceType?: string | undefined;
    identificationNumber?: string | undefined;
    lastData?: string | undefined;
    deviceSerialNumber?: string | undefined;
    placeStreet?: string | undefined;
    payerStreet?: string | undefined;
    placeCity?: string | undefined;
    payerCity?: string | undefined;
    placeZipCode?: string | undefined;
    payerZipCode?: string | undefined;
    dealer?: string | undefined;
    readingCategory?: string | undefined;
    validatedBy?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validationNote?: string | undefined;
    gps?: string | undefined;
    device?: number | undefined;
    readRequestStatus?: number | undefined;
    readDescription?: string | undefined;
    note?: string | undefined;
    group?: string | undefined;
    workplace?: string | undefined;
    hasTimeWindows?: boolean | undefined;
    hasBattery?: boolean | undefined;
    hasGasComposition?: boolean | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    dailyData?: boolean | undefined;
    scadaId?: string | undefined;
    parentDevice?: string | undefined;
}

export class AveDroidDeviceData implements IAveDroidDeviceData {
    place?: Place | undefined;
    group?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;

    constructor(data?: IAveDroidDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.place = _data["place"] ? Place.fromJS(_data["place"]) : <any>undefined;
            this.group = _data["group"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): AveDroidDeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new AveDroidDeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["group"] = this.group;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

export interface IAveDroidDeviceData {
    place?: Place | undefined;
    group?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;
}

export class DataValidationRequest implements IDataValidationRequest {
    placesId!: number[];
    till?: Date | undefined;
    note?: string | undefined;

    constructor(data?: IDataValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.placesId = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PlacesId"])) {
                this.placesId = [] as any;
                for (let item of _data["PlacesId"])
                    this.placesId!.push(item);
            }
            this.till = _data["Till"] ? new Date(_data["Till"].toString()) : <any>undefined;
            this.note = _data["Note"];
        }
    }

    static fromJS(data: any): DataValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.placesId)) {
            data["PlacesId"] = [];
            for (let item of this.placesId)
                data["PlacesId"].push(item);
        }
        data["Till"] = this.till ? this.till.toISOString() : <any>undefined;
        data["Note"] = this.note;
        return data;
    }
}

export interface IDataValidationRequest {
    placesId: number[];
    till?: Date | undefined;
    note?: string | undefined;
}

export class Dealer implements IDealer {
    id?: number | undefined;
    name?: string | undefined;
    identificationCode?: string | undefined;
    identificationCodeHash?: number | undefined;
    color?: string | undefined;

    constructor(data?: IDealer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.identificationCode = _data["IdentificationCode"];
            this.identificationCodeHash = _data["IdentificationCodeHash"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): Dealer {
        data = typeof data === 'object' ? data : {};
        let result = new Dealer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["IdentificationCode"] = this.identificationCode;
        data["IdentificationCodeHash"] = this.identificationCodeHash;
        data["Color"] = this.color;
        return data;
    }
}

export interface IDealer {
    id?: number | undefined;
    name?: string | undefined;
    identificationCode?: string | undefined;
    identificationCodeHash?: number | undefined;
    color?: string | undefined;
}

export class DriverCommunicationChannel implements IDriverCommunicationChannel {
    id?: number | undefined;
    channelGuid?: string | undefined;
    channelName?: string | undefined;
    channelType?: DriverCommunicationChannelChannelType | undefined;
    channelState?: DriverCommunicationChannelChannelState | undefined;
    isBlocked?: boolean | undefined;
    isInError?: boolean | undefined;
    productivityPercentage?: number | undefined;
    total?: number | undefined;
    ok?: number | undefined;
    errors?: number | undefined;

    constructor(data?: IDriverCommunicationChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.channelGuid = _data["ChannelGuid"];
            this.channelName = _data["ChannelName"];
            this.channelType = _data["ChannelType"];
            this.channelState = _data["ChannelState"];
            this.isBlocked = _data["IsBlocked"];
            this.isInError = _data["IsInError"];
            this.productivityPercentage = _data["ProductivityPercentage"];
            this.total = _data["Total"];
            this.ok = _data["Ok"];
            this.errors = _data["Errors"];
        }
    }

    static fromJS(data: any): DriverCommunicationChannel {
        data = typeof data === 'object' ? data : {};
        let result = new DriverCommunicationChannel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ChannelGuid"] = this.channelGuid;
        data["ChannelName"] = this.channelName;
        data["ChannelType"] = this.channelType;
        data["ChannelState"] = this.channelState;
        data["IsBlocked"] = this.isBlocked;
        data["IsInError"] = this.isInError;
        data["ProductivityPercentage"] = this.productivityPercentage;
        data["Total"] = this.total;
        data["Ok"] = this.ok;
        data["Errors"] = this.errors;
        return data;
    }
}

export interface IDriverCommunicationChannel {
    id?: number | undefined;
    channelGuid?: string | undefined;
    channelName?: string | undefined;
    channelType?: DriverCommunicationChannelChannelType | undefined;
    channelState?: DriverCommunicationChannelChannelState | undefined;
    isBlocked?: boolean | undefined;
    isInError?: boolean | undefined;
    productivityPercentage?: number | undefined;
    total?: number | undefined;
    ok?: number | undefined;
    errors?: number | undefined;
}

export class CallLogsPage implements ICallLogsPage {
    pageItems?: CallLogItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ICallLogsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(CallLogItem.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): CallLogsPage {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface ICallLogsPage {
    pageItems?: CallLogItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class DeviceTagItem implements IDeviceTagItem {
    id?: number | undefined;
    dataType?: string | undefined;
    dataCharacter?: string | undefined;
    dataCharacterDescription?: string | undefined;
    aggregationType?: string | undefined;
    aggregationTypeDescription?: string | undefined;
    period?: string | undefined;
    periodDescription?: string | undefined;
    address?: number | undefined;
    decimalPlaceCount?: number | undefined;
    convertCoefficient?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    units?: string | undefined;
    group?: string | undefined;
    nameWithUnits?: string | undefined;
    fieldName?: string | undefined;
    diffTagFieldName?: string | undefined;
    visualPosition?: number | undefined;
    lowCriticalLimit?: number | undefined;
    highCriticalLimit?: number | undefined;
    lowWarningLimit?: number | undefined;
    highWarningLimit?: number | undefined;
    isLowCriticalLimitEnabled?: boolean | undefined;
    isHighCriticalLimitEnabled?: boolean | undefined;
    isLowWarningLimitEnabled?: boolean | undefined;
    isHighWarningLimitEnabled?: boolean | undefined;
    enabled?: boolean | undefined;
    visible?: boolean | undefined;
    isComputed?: boolean | undefined;
    isReadOnly?: boolean | undefined;
    computedVariableAsText?: string | undefined;
    isNumber?: boolean | undefined;
    constantValue?: string | undefined;

    constructor(data?: IDeviceTagItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.dataType = _data["DataType"];
            this.dataCharacter = _data["DataCharacter"];
            this.dataCharacterDescription = _data["DataCharacterDescription"];
            this.aggregationType = _data["AggregationType"];
            this.aggregationTypeDescription = _data["AggregationTypeDescription"];
            this.period = _data["Period"];
            this.periodDescription = _data["PeriodDescription"];
            this.address = _data["Address"];
            this.decimalPlaceCount = _data["DecimalPlaceCount"];
            this.convertCoefficient = _data["ConvertCoefficient"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.units = _data["Units"];
            this.group = _data["Group"];
            this.nameWithUnits = _data["NameWithUnits"];
            this.fieldName = _data["FieldName"];
            this.diffTagFieldName = _data["DiffTagFieldName"];
            this.visualPosition = _data["VisualPosition"];
            this.lowCriticalLimit = _data["LowCriticalLimit"];
            this.highCriticalLimit = _data["HighCriticalLimit"];
            this.lowWarningLimit = _data["LowWarningLimit"];
            this.highWarningLimit = _data["HighWarningLimit"];
            this.isLowCriticalLimitEnabled = _data["IsLowCriticalLimitEnabled"];
            this.isHighCriticalLimitEnabled = _data["IsHighCriticalLimitEnabled"];
            this.isLowWarningLimitEnabled = _data["IsLowWarningLimitEnabled"];
            this.isHighWarningLimitEnabled = _data["IsHighWarningLimitEnabled"];
            this.enabled = _data["Enabled"];
            this.visible = _data["Visible"];
            this.isComputed = _data["IsComputed"];
            this.isReadOnly = _data["IsReadOnly"];
            this.computedVariableAsText = _data["ComputedVariableAsText"];
            this.isNumber = _data["IsNumber"];
            this.constantValue = _data["ConstantValue"];
        }
    }

    static fromJS(data: any): DeviceTagItem {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTagItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DataType"] = this.dataType;
        data["DataCharacter"] = this.dataCharacter;
        data["DataCharacterDescription"] = this.dataCharacterDescription;
        data["AggregationType"] = this.aggregationType;
        data["AggregationTypeDescription"] = this.aggregationTypeDescription;
        data["Period"] = this.period;
        data["PeriodDescription"] = this.periodDescription;
        data["Address"] = this.address;
        data["DecimalPlaceCount"] = this.decimalPlaceCount;
        data["ConvertCoefficient"] = this.convertCoefficient;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Units"] = this.units;
        data["Group"] = this.group;
        data["NameWithUnits"] = this.nameWithUnits;
        data["FieldName"] = this.fieldName;
        data["DiffTagFieldName"] = this.diffTagFieldName;
        data["VisualPosition"] = this.visualPosition;
        data["LowCriticalLimit"] = this.lowCriticalLimit;
        data["HighCriticalLimit"] = this.highCriticalLimit;
        data["LowWarningLimit"] = this.lowWarningLimit;
        data["HighWarningLimit"] = this.highWarningLimit;
        data["IsLowCriticalLimitEnabled"] = this.isLowCriticalLimitEnabled;
        data["IsHighCriticalLimitEnabled"] = this.isHighCriticalLimitEnabled;
        data["IsLowWarningLimitEnabled"] = this.isLowWarningLimitEnabled;
        data["IsHighWarningLimitEnabled"] = this.isHighWarningLimitEnabled;
        data["Enabled"] = this.enabled;
        data["Visible"] = this.visible;
        data["IsComputed"] = this.isComputed;
        data["IsReadOnly"] = this.isReadOnly;
        data["ComputedVariableAsText"] = this.computedVariableAsText;
        data["IsNumber"] = this.isNumber;
        data["ConstantValue"] = this.constantValue;
        return data;
    }
}

export interface IDeviceTagItem {
    id?: number | undefined;
    dataType?: string | undefined;
    dataCharacter?: string | undefined;
    dataCharacterDescription?: string | undefined;
    aggregationType?: string | undefined;
    aggregationTypeDescription?: string | undefined;
    period?: string | undefined;
    periodDescription?: string | undefined;
    address?: number | undefined;
    decimalPlaceCount?: number | undefined;
    convertCoefficient?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    units?: string | undefined;
    group?: string | undefined;
    nameWithUnits?: string | undefined;
    fieldName?: string | undefined;
    diffTagFieldName?: string | undefined;
    visualPosition?: number | undefined;
    lowCriticalLimit?: number | undefined;
    highCriticalLimit?: number | undefined;
    lowWarningLimit?: number | undefined;
    highWarningLimit?: number | undefined;
    isLowCriticalLimitEnabled?: boolean | undefined;
    isHighCriticalLimitEnabled?: boolean | undefined;
    isLowWarningLimitEnabled?: boolean | undefined;
    isHighWarningLimitEnabled?: boolean | undefined;
    enabled?: boolean | undefined;
    visible?: boolean | undefined;
    isComputed?: boolean | undefined;
    isReadOnly?: boolean | undefined;
    computedVariableAsText?: string | undefined;
    isNumber?: boolean | undefined;
    constantValue?: string | undefined;
}

export class DeviceAlarmItem implements IDeviceAlarmItem {
    id?: number | undefined;
    tagId?: number | undefined;
    tagFieldName?: string | undefined;
    alarmId?: number | undefined;
    category?: string | undefined;
    text?: string | undefined;
    enabled?: boolean | undefined;
    acknowledgementRequired?: boolean | undefined;
    condition?: DeviceAlarmItemCondition | undefined;
    conditionDescription?: string | undefined;
    rangeFrom?: number | undefined;
    rangeTo?: number | undefined;

    constructor(data?: IDeviceAlarmItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.tagId = _data["TagId"];
            this.tagFieldName = _data["TagFieldName"];
            this.alarmId = _data["AlarmId"];
            this.category = _data["Category"];
            this.text = _data["Text"];
            this.enabled = _data["Enabled"];
            this.acknowledgementRequired = _data["AcknowledgementRequired"];
            this.condition = _data["Condition"];
            this.conditionDescription = _data["ConditionDescription"];
            this.rangeFrom = _data["RangeFrom"];
            this.rangeTo = _data["RangeTo"];
        }
    }

    static fromJS(data: any): DeviceAlarmItem {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAlarmItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TagId"] = this.tagId;
        data["TagFieldName"] = this.tagFieldName;
        data["AlarmId"] = this.alarmId;
        data["Category"] = this.category;
        data["Text"] = this.text;
        data["Enabled"] = this.enabled;
        data["AcknowledgementRequired"] = this.acknowledgementRequired;
        data["Condition"] = this.condition;
        data["ConditionDescription"] = this.conditionDescription;
        data["RangeFrom"] = this.rangeFrom;
        data["RangeTo"] = this.rangeTo;
        return data;
    }
}

export interface IDeviceAlarmItem {
    id?: number | undefined;
    tagId?: number | undefined;
    tagFieldName?: string | undefined;
    alarmId?: number | undefined;
    category?: string | undefined;
    text?: string | undefined;
    enabled?: boolean | undefined;
    acknowledgementRequired?: boolean | undefined;
    condition?: DeviceAlarmItemCondition | undefined;
    conditionDescription?: string | undefined;
    rangeFrom?: number | undefined;
    rangeTo?: number | undefined;
}

export class ReadingParameters implements IReadingParameters {
    callRepeat?: number | undefined;
    priority?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    useSecondaryConnection?: boolean | undefined;
    logCommunication?: boolean | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    address1?: number | undefined;
    address2?: number | undefined;

    constructor(data?: IReadingParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.callRepeat = _data["callRepeat"];
            this.priority = _data["priority"];
            this.maxReadingTimeInMinutes = _data["maxReadingTimeInMinutes"];
            this.useSecondaryConnection = _data["useSecondaryConnection"];
            this.logCommunication = _data["logCommunication"];
            this.primaryConnectionNumber = _data["primaryConnectionNumber"];
            this.secondaryConnectionNumber = _data["secondaryConnectionNumber"];
            this.primaryConnectionType = _data["primaryConnectionType"];
            this.secondaryConnectionType = _data["secondaryConnectionType"];
            this.primaryDeviceDriverId = _data["primaryDeviceDriverId"];
            this.secondaryDeviceDriverId = _data["secondaryDeviceDriverId"];
            this.primaryChannelGuid = _data["primaryChannelGuid"];
            this.secondaryChannelGuid = _data["secondaryChannelGuid"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
        }
    }

    static fromJS(data: any): ReadingParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ReadingParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callRepeat"] = this.callRepeat;
        data["priority"] = this.priority;
        data["maxReadingTimeInMinutes"] = this.maxReadingTimeInMinutes;
        data["useSecondaryConnection"] = this.useSecondaryConnection;
        data["logCommunication"] = this.logCommunication;
        data["primaryConnectionNumber"] = this.primaryConnectionNumber;
        data["secondaryConnectionNumber"] = this.secondaryConnectionNumber;
        data["primaryConnectionType"] = this.primaryConnectionType;
        data["secondaryConnectionType"] = this.secondaryConnectionType;
        data["primaryDeviceDriverId"] = this.primaryDeviceDriverId;
        data["secondaryDeviceDriverId"] = this.secondaryDeviceDriverId;
        data["primaryChannelGuid"] = this.primaryChannelGuid;
        data["secondaryChannelGuid"] = this.secondaryChannelGuid;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        return data;
    }
}

export interface IReadingParameters {
    callRepeat?: number | undefined;
    priority?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    useSecondaryConnection?: boolean | undefined;
    logCommunication?: boolean | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    address1?: number | undefined;
    address2?: number | undefined;
}

export class LastReadingInfo implements ILastReadingInfo {
    lastReadingTimestamp?: Date | undefined;
    lastDataTimestamp?: Date | undefined;
    result?: string | undefined;
    errorText?: string | undefined;
    usedConnection?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;

    constructor(data?: ILastReadingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastReadingTimestamp = _data["lastReadingTimestamp"] ? new Date(_data["lastReadingTimestamp"].toString()) : <any>undefined;
            this.lastDataTimestamp = _data["lastDataTimestamp"] ? new Date(_data["lastDataTimestamp"].toString()) : <any>undefined;
            this.result = _data["result"];
            this.errorText = _data["errorText"];
            this.usedConnection = _data["usedConnection"];
            this.schedulerName = _data["schedulerName"];
            this.schedulerTime = _data["schedulerTime"] ? new Date(_data["schedulerTime"].toString()) : <any>undefined;
            this.manualReadingTime = _data["manualReadingTime"] ? new Date(_data["manualReadingTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LastReadingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LastReadingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastReadingTimestamp"] = this.lastReadingTimestamp ? this.lastReadingTimestamp.toISOString() : <any>undefined;
        data["lastDataTimestamp"] = this.lastDataTimestamp ? this.lastDataTimestamp.toISOString() : <any>undefined;
        data["result"] = this.result;
        data["errorText"] = this.errorText;
        data["usedConnection"] = this.usedConnection;
        data["schedulerName"] = this.schedulerName;
        data["schedulerTime"] = this.schedulerTime ? this.schedulerTime.toISOString() : <any>undefined;
        data["manualReadingTime"] = this.manualReadingTime ? this.manualReadingTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILastReadingInfo {
    lastReadingTimestamp?: Date | undefined;
    lastDataTimestamp?: Date | undefined;
    result?: string | undefined;
    errorText?: string | undefined;
    usedConnection?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
}

export class TimeWindows implements ITimeWindows {
    callWindows?: TimeWindowRow[] | undefined;
    serviceWindows?: TimeWindowRow[] | undefined;
    callWindowExecutionTimes?: Date[] | undefined;
    serviceWindowExecutionTimes?: TimeWindow[] | undefined;

    constructor(data?: ITimeWindows) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["callWindows"])) {
                this.callWindows = [] as any;
                for (let item of _data["callWindows"])
                    this.callWindows!.push(TimeWindowRow.fromJS(item));
            }
            if (Array.isArray(_data["serviceWindows"])) {
                this.serviceWindows = [] as any;
                for (let item of _data["serviceWindows"])
                    this.serviceWindows!.push(TimeWindowRow.fromJS(item));
            }
            if (Array.isArray(_data["callWindowExecutionTimes"])) {
                this.callWindowExecutionTimes = [] as any;
                for (let item of _data["callWindowExecutionTimes"])
                    this.callWindowExecutionTimes!.push(new Date(item));
            }
            if (Array.isArray(_data["serviceWindowExecutionTimes"])) {
                this.serviceWindowExecutionTimes = [] as any;
                for (let item of _data["serviceWindowExecutionTimes"])
                    this.serviceWindowExecutionTimes!.push(TimeWindow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeWindows {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindows();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.callWindows)) {
            data["callWindows"] = [];
            for (let item of this.callWindows)
                data["callWindows"].push(item.toJSON());
        }
        if (Array.isArray(this.serviceWindows)) {
            data["serviceWindows"] = [];
            for (let item of this.serviceWindows)
                data["serviceWindows"].push(item.toJSON());
        }
        if (Array.isArray(this.callWindowExecutionTimes)) {
            data["callWindowExecutionTimes"] = [];
            for (let item of this.callWindowExecutionTimes)
                data["callWindowExecutionTimes"].push(item.toISOString());
        }
        if (Array.isArray(this.serviceWindowExecutionTimes)) {
            data["serviceWindowExecutionTimes"] = [];
            for (let item of this.serviceWindowExecutionTimes)
                data["serviceWindowExecutionTimes"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITimeWindows {
    callWindows?: TimeWindowRow[] | undefined;
    serviceWindows?: TimeWindowRow[] | undefined;
    callWindowExecutionTimes?: Date[] | undefined;
    serviceWindowExecutionTimes?: TimeWindow[] | undefined;
}

export class TimeWindowRow implements ITimeWindowRow {
    enabled?: boolean | undefined;
    type?: string | undefined;
    periodicity?: string | undefined;
    days?: string | undefined;
    dayNumber?: number | undefined;
    hour?: number | undefined;
    minute?: number | undefined;
    second?: number | undefined;
    serviceWindowDurationInSeconds?: number | undefined;

    constructor(data?: ITimeWindowRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.type = _data["type"];
            this.periodicity = _data["periodicity"];
            this.days = _data["days"];
            this.dayNumber = _data["dayNumber"];
            this.hour = _data["hour"];
            this.minute = _data["minute"];
            this.second = _data["second"];
            this.serviceWindowDurationInSeconds = _data["serviceWindowDurationInSeconds"];
        }
    }

    static fromJS(data: any): TimeWindowRow {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindowRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["type"] = this.type;
        data["periodicity"] = this.periodicity;
        data["days"] = this.days;
        data["dayNumber"] = this.dayNumber;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        data["serviceWindowDurationInSeconds"] = this.serviceWindowDurationInSeconds;
        return data;
    }
}

export interface ITimeWindowRow {
    enabled?: boolean | undefined;
    type?: string | undefined;
    periodicity?: string | undefined;
    days?: string | undefined;
    dayNumber?: number | undefined;
    hour?: number | undefined;
    minute?: number | undefined;
    second?: number | undefined;
    serviceWindowDurationInSeconds?: number | undefined;
}

export class TimeWindow implements ITimeWindow {
    executionTime?: Date | undefined;
    duration?: string | undefined;

    constructor(data?: ITimeWindow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.executionTime = _data["ExecutionTime"] ? new Date(_data["ExecutionTime"].toString()) : <any>undefined;
            this.duration = _data["Duration"];
        }
    }

    static fromJS(data: any): TimeWindow {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ExecutionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["Duration"] = this.duration;
        return data;
    }
}

export interface ITimeWindow {
    executionTime?: Date | undefined;
    duration?: string | undefined;
}

export class BatteryStatus implements IBatteryStatus {
    batteryLevel?: number | undefined;
    batteryVoltage?: number | undefined;
    timestamp?: Date | undefined;
    levelHistory?: { [key: string]: number; } | undefined;
    voltageHistory?: { [key: string]: number; } | undefined;

    constructor(data?: IBatteryStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.batteryLevel = _data["batteryLevel"];
            this.batteryVoltage = _data["batteryVoltage"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (_data["levelHistory"]) {
                this.levelHistory = {} as any;
                for (let key in _data["levelHistory"]) {
                    if (_data["levelHistory"].hasOwnProperty(key))
                        (<any>this.levelHistory)![key] = _data["levelHistory"][key];
                }
            }
            if (_data["voltageHistory"]) {
                this.voltageHistory = {} as any;
                for (let key in _data["voltageHistory"]) {
                    if (_data["voltageHistory"].hasOwnProperty(key))
                        (<any>this.voltageHistory)![key] = _data["voltageHistory"][key];
                }
            }
        }
    }

    static fromJS(data: any): BatteryStatus {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batteryLevel"] = this.batteryLevel;
        data["batteryVoltage"] = this.batteryVoltage;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (this.levelHistory) {
            data["levelHistory"] = {};
            for (let key in this.levelHistory) {
                if (this.levelHistory.hasOwnProperty(key))
                    (<any>data["levelHistory"])[key] = (<any>this.levelHistory)[key];
            }
        }
        if (this.voltageHistory) {
            data["voltageHistory"] = {};
            for (let key in this.voltageHistory) {
                if (this.voltageHistory.hasOwnProperty(key))
                    (<any>data["voltageHistory"])[key] = (<any>this.voltageHistory)[key];
            }
        }
        return data;
    }
}

export interface IBatteryStatus {
    batteryLevel?: number | undefined;
    batteryVoltage?: number | undefined;
    timestamp?: Date | undefined;
    levelHistory?: { [key: string]: number; } | undefined;
    voltageHistory?: { [key: string]: number; } | undefined;
}

export class DeviceParameters implements IDeviceParameters {
    baseParameters?: DeviceParameter[] | undefined;
    extendedParameters?: DeviceParameter[] | undefined;

    constructor(data?: IDeviceParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["baseParameters"])) {
                this.baseParameters = [] as any;
                for (let item of _data["baseParameters"])
                    this.baseParameters!.push(DeviceParameter.fromJS(item));
            }
            if (Array.isArray(_data["extendedParameters"])) {
                this.extendedParameters = [] as any;
                for (let item of _data["extendedParameters"])
                    this.extendedParameters!.push(DeviceParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.baseParameters)) {
            data["baseParameters"] = [];
            for (let item of this.baseParameters)
                data["baseParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.extendedParameters)) {
            data["extendedParameters"] = [];
            for (let item of this.extendedParameters)
                data["extendedParameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDeviceParameters {
    baseParameters?: DeviceParameter[] | undefined;
    extendedParameters?: DeviceParameter[] | undefined;
}

export class DeviceParameter implements IDeviceParameter {
    fieldName?: string | undefined;
    description?: string | undefined;
    dataType?: string | undefined;
    value?: string | undefined;
    isReadOnly?: boolean | undefined;

    constructor(data?: IDeviceParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.value = _data["value"];
            this.isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): DeviceParameter {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["value"] = this.value;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }
}

export interface IDeviceParameter {
    fieldName?: string | undefined;
    description?: string | undefined;
    dataType?: string | undefined;
    value?: string | undefined;
    isReadOnly?: boolean | undefined;
}

export class DeviceRuntimeParameters implements IDeviceRuntimeParameters {
    items?: DeviceRuntimeParameter[] | undefined;
    count?: number | undefined;

    constructor(data?: IDeviceRuntimeParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(DeviceRuntimeParameter.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): DeviceRuntimeParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuntimeParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface IDeviceRuntimeParameters {
    items?: DeviceRuntimeParameter[] | undefined;
    count?: number | undefined;
}

export class DeviceRuntimeParameter implements IDeviceRuntimeParameter {
    placeId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    category?: string | undefined;
    subCategory?: string | undefined;
    readonly valueAsObject?: any | undefined;

    constructor(data?: IDeviceRuntimeParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["PlaceId"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.value = _data["Value"];
            this.valueType = _data["ValueType"];
            this.category = _data["Category"];
            this.subCategory = _data["SubCategory"];
            (<any>this).valueAsObject = _data["ValueAsObject"];
        }
    }

    static fromJS(data: any): DeviceRuntimeParameter {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuntimeParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PlaceId"] = this.placeId;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        data["Category"] = this.category;
        data["SubCategory"] = this.subCategory;
        data["ValueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IDeviceRuntimeParameter {
    placeId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    category?: string | undefined;
    subCategory?: string | undefined;
    valueAsObject?: any | undefined;
}

export class GasComposition implements IGasComposition {
    settings?: GasConversionParameters | undefined;

    constructor(data?: IGasComposition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? GasConversionParameters.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GasComposition {
        data = typeof data === 'object' ? data : {};
        let result = new GasComposition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGasComposition {
    settings?: GasConversionParameters | undefined;
}

export class GasConversionParameters implements IGasConversionParameters {
    compressibilityType?: GasConversionParametersCompressibilityType | undefined;
    cO2?: number | undefined;
    n2?: number | undefined;
    superior?: number | undefined;
    realDensity?: number | undefined;
    h2?: number | undefined;
    h2S?: number | undefined;
    he?: number | undefined;
    h2O?: number | undefined;
    o2?: number | undefined;
    ar?: number | undefined;
    cO?: number | undefined;
    c1H4?: number | undefined;
    c2H6?: number | undefined;
    c3H8?: number | undefined;
    iC4H10?: number | undefined;
    nC4H10?: number | undefined;
    iC5H12?: number | undefined;
    nC5H12?: number | undefined;
    c6H14?: number | undefined;
    c7H16?: number | undefined;
    c8H18?: number | undefined;
    c9H20?: number | undefined;
    c10H22?: number | undefined;
    neoC5?: number | undefined;
    c6plus?: number | undefined;
    k1?: number | undefined;
    aGA892DCTolerance?: number | undefined;
    readonly compressibilityTypeDescription?: string | undefined;

    constructor(data?: IGasConversionParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.compressibilityType = _data["CompressibilityType"];
            this.cO2 = _data["CO2"];
            this.n2 = _data["N2"];
            this.superior = _data["Superior"];
            this.realDensity = _data["RealDensity"];
            this.h2 = _data["H2"];
            this.h2S = _data["H2S"];
            this.he = _data["He"];
            this.h2O = _data["H2O"];
            this.o2 = _data["O2"];
            this.ar = _data["Ar"];
            this.cO = _data["CO"];
            this.c1H4 = _data["C1H4"];
            this.c2H6 = _data["C2H6"];
            this.c3H8 = _data["C3H8"];
            this.iC4H10 = _data["iC4H10"];
            this.nC4H10 = _data["nC4H10"];
            this.iC5H12 = _data["iC5H12"];
            this.nC5H12 = _data["nC5H12"];
            this.c6H14 = _data["C6H14"];
            this.c7H16 = _data["C7H16"];
            this.c8H18 = _data["C8H18"];
            this.c9H20 = _data["C9H20"];
            this.c10H22 = _data["C10H22"];
            this.neoC5 = _data["neoC5"];
            this.c6plus = _data["C6plus"];
            this.k1 = _data["K1"];
            this.aGA892DCTolerance = _data["AGA892DCTolerance"];
            (<any>this).compressibilityTypeDescription = _data["CompressibilityTypeDescription"];
        }
    }

    static fromJS(data: any): GasConversionParameters {
        data = typeof data === 'object' ? data : {};
        let result = new GasConversionParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CompressibilityType"] = this.compressibilityType;
        data["CO2"] = this.cO2;
        data["N2"] = this.n2;
        data["Superior"] = this.superior;
        data["RealDensity"] = this.realDensity;
        data["H2"] = this.h2;
        data["H2S"] = this.h2S;
        data["He"] = this.he;
        data["H2O"] = this.h2O;
        data["O2"] = this.o2;
        data["Ar"] = this.ar;
        data["CO"] = this.cO;
        data["C1H4"] = this.c1H4;
        data["C2H6"] = this.c2H6;
        data["C3H8"] = this.c3H8;
        data["iC4H10"] = this.iC4H10;
        data["nC4H10"] = this.nC4H10;
        data["iC5H12"] = this.iC5H12;
        data["nC5H12"] = this.nC5H12;
        data["C6H14"] = this.c6H14;
        data["C7H16"] = this.c7H16;
        data["C8H18"] = this.c8H18;
        data["C9H20"] = this.c9H20;
        data["C10H22"] = this.c10H22;
        data["neoC5"] = this.neoC5;
        data["C6plus"] = this.c6plus;
        data["K1"] = this.k1;
        data["AGA892DCTolerance"] = this.aGA892DCTolerance;
        data["CompressibilityTypeDescription"] = this.compressibilityTypeDescription;
        return data;
    }
}

export interface IGasConversionParameters {
    compressibilityType?: GasConversionParametersCompressibilityType | undefined;
    cO2?: number | undefined;
    n2?: number | undefined;
    superior?: number | undefined;
    realDensity?: number | undefined;
    h2?: number | undefined;
    h2S?: number | undefined;
    he?: number | undefined;
    h2O?: number | undefined;
    o2?: number | undefined;
    ar?: number | undefined;
    cO?: number | undefined;
    c1H4?: number | undefined;
    c2H6?: number | undefined;
    c3H8?: number | undefined;
    iC4H10?: number | undefined;
    nC4H10?: number | undefined;
    iC5H12?: number | undefined;
    nC5H12?: number | undefined;
    c6H14?: number | undefined;
    c7H16?: number | undefined;
    c8H18?: number | undefined;
    c9H20?: number | undefined;
    c10H22?: number | undefined;
    neoC5?: number | undefined;
    c6plus?: number | undefined;
    k1?: number | undefined;
    aGA892DCTolerance?: number | undefined;
    compressibilityTypeDescription?: string | undefined;
}

export class ConnectionType implements IConnectionType {
    id?: number | undefined;
    description?: string | undefined;

    constructor(data?: IConnectionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): ConnectionType {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Description"] = this.description;
        return data;
    }
}

export interface IConnectionType {
    id?: number | undefined;
    description?: string | undefined;
}

export class ServerInfos implements IServerInfos {
    items?: ServerInfo[] | undefined;
    count?: number | undefined;

    constructor(data?: IServerInfos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ServerInfo.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): ServerInfos {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInfos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface IServerInfos {
    items?: ServerInfo[] | undefined;
    count?: number | undefined;
}

export class ServerInfo implements IServerInfo {
    id?: number | undefined;
    ip?: string | undefined;
    lastRegistered?: string | undefined;
    name?: string | undefined;
    online?: boolean | undefined;
    port?: number | undefined;
    regionId?: number | undefined;
    type?: string | undefined;
    version?: string | undefined;
    memoryUsage?: number | undefined;
    diskUsage?: number | undefined;
    cpuUsage?: number | undefined;
    usageAge?: string | undefined;

    constructor(data?: IServerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ip = _data["ip"];
            this.lastRegistered = _data["lastRegistered"];
            this.name = _data["name"];
            this.online = _data["online"];
            this.port = _data["port"];
            this.regionId = _data["regionId"];
            this.type = _data["type"];
            this.version = _data["version"];
            this.memoryUsage = _data["memoryUsage"];
            this.diskUsage = _data["diskUsage"];
            this.cpuUsage = _data["cpuUsage"];
            this.usageAge = _data["usageAge"];
        }
    }

    static fromJS(data: any): ServerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ip"] = this.ip;
        data["lastRegistered"] = this.lastRegistered;
        data["name"] = this.name;
        data["online"] = this.online;
        data["port"] = this.port;
        data["regionId"] = this.regionId;
        data["type"] = this.type;
        data["version"] = this.version;
        data["memoryUsage"] = this.memoryUsage;
        data["diskUsage"] = this.diskUsage;
        data["cpuUsage"] = this.cpuUsage;
        data["usageAge"] = this.usageAge;
        return data;
    }
}

export interface IServerInfo {
    id?: number | undefined;
    ip?: string | undefined;
    lastRegistered?: string | undefined;
    name?: string | undefined;
    online?: boolean | undefined;
    port?: number | undefined;
    regionId?: number | undefined;
    type?: string | undefined;
    version?: string | undefined;
    memoryUsage?: number | undefined;
    diskUsage?: number | undefined;
    cpuUsage?: number | undefined;
    usageAge?: string | undefined;
}

export class ServerMonitoringItems implements IServerMonitoringItems {
    items?: ServerMonitoringItem[] | undefined;
    count?: number | undefined;

    constructor(data?: IServerMonitoringItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ServerMonitoringItem.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): ServerMonitoringItems {
        data = typeof data === 'object' ? data : {};
        let result = new ServerMonitoringItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        return data;
    }
}

export interface IServerMonitoringItems {
    items?: ServerMonitoringItem[] | undefined;
    count?: number | undefined;
}

export class ServerMonitoringItem implements IServerMonitoringItem {
    timestamp?: Date | undefined;
    serverId?: number | undefined;
    data?: string | undefined;

    constructor(data?: IServerMonitoringItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.serverId = _data["ServerId"];
            this.data = _data["Data"];
        }
    }

    static fromJS(data: any): ServerMonitoringItem {
        data = typeof data === 'object' ? data : {};
        let result = new ServerMonitoringItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["ServerId"] = this.serverId;
        data["Data"] = this.data;
        return data;
    }
}

export interface IServerMonitoringItem {
    timestamp?: Date | undefined;
    serverId?: number | undefined;
    data?: string | undefined;
}

export class ChartData_1 implements IChartData_1 {
    timestamp?: Date | undefined;
    value?: any | undefined;

    constructor(data?: IChartData_1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["Timestamp"] ? new Date(_data["Timestamp"].toString()) : <any>undefined;
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): ChartData_1 {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData_1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["Value"] = this.value;
        return data;
    }
}

export interface IChartData_1 {
    timestamp?: Date | undefined;
    value?: any | undefined;
}

export class Page_1 implements IPage_1 {
    items?: ExportScheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPage_1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ExportScheduler.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): Page_1 {
        data = typeof data === 'object' ? data : {};
        let result = new Page_1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IPage_1 {
    items?: ExportScheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ExportScheduler implements IExportScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    firstExecutionTime?: Date | undefined;
    lastExecutionTime?: Date | undefined;
    enabled?: boolean | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;
    modified?: Date | undefined;
    modifiedBy?: string | undefined;
    profilesIds?: number[] | undefined;
    periodicallyConditionType?: ExportSchedulerPeriodicallyConditionType | undefined;
    periodicallyConditionCount?: number | undefined;
    exportProperties?: ExportProperties | undefined;
    days?: string | undefined;
    serializedExportProperties?: string | undefined;
    readonly nextExecutionTime?: Date | undefined;

    constructor(data?: IExportScheduler) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.guid = _data["Guid"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.regionId = _data["RegionId"];
            this.firstExecutionTime = _data["FirstExecutionTime"] ? new Date(_data["FirstExecutionTime"].toString()) : <any>undefined;
            this.lastExecutionTime = _data["LastExecutionTime"] ? new Date(_data["LastExecutionTime"].toString()) : <any>undefined;
            this.enabled = _data["Enabled"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
            this.createdBy = _data["CreatedBy"];
            this.modified = _data["Modified"] ? new Date(_data["Modified"].toString()) : <any>undefined;
            this.modifiedBy = _data["ModifiedBy"];
            if (Array.isArray(_data["ProfilesIds"])) {
                this.profilesIds = [] as any;
                for (let item of _data["ProfilesIds"])
                    this.profilesIds!.push(item);
            }
            this.periodicallyConditionType = _data["PeriodicallyConditionType"];
            this.periodicallyConditionCount = _data["PeriodicallyConditionCount"];
            this.exportProperties = _data["ExportProperties"] ? ExportProperties.fromJS(_data["ExportProperties"]) : <any>undefined;
            this.days = _data["Days"];
            this.serializedExportProperties = _data["SerializedExportProperties"];
            (<any>this).nextExecutionTime = _data["NextExecutionTime"] ? new Date(_data["NextExecutionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportScheduler {
        data = typeof data === 'object' ? data : {};
        let result = new ExportScheduler();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Guid"] = this.guid;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["RegionId"] = this.regionId;
        data["FirstExecutionTime"] = this.firstExecutionTime ? this.firstExecutionTime.toISOString() : <any>undefined;
        data["LastExecutionTime"] = this.lastExecutionTime ? this.lastExecutionTime.toISOString() : <any>undefined;
        data["Enabled"] = this.enabled;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["CreatedBy"] = this.createdBy;
        data["Modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["ModifiedBy"] = this.modifiedBy;
        if (Array.isArray(this.profilesIds)) {
            data["ProfilesIds"] = [];
            for (let item of this.profilesIds)
                data["ProfilesIds"].push(item);
        }
        data["PeriodicallyConditionType"] = this.periodicallyConditionType;
        data["PeriodicallyConditionCount"] = this.periodicallyConditionCount;
        data["ExportProperties"] = this.exportProperties ? this.exportProperties.toJSON() : <any>undefined;
        data["Days"] = this.days;
        data["SerializedExportProperties"] = this.serializedExportProperties;
        data["NextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IExportScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    firstExecutionTime?: Date | undefined;
    lastExecutionTime?: Date | undefined;
    enabled?: boolean | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;
    modified?: Date | undefined;
    modifiedBy?: string | undefined;
    profilesIds?: number[] | undefined;
    periodicallyConditionType?: ExportSchedulerPeriodicallyConditionType | undefined;
    periodicallyConditionCount?: number | undefined;
    exportProperties?: ExportProperties | undefined;
    days?: string | undefined;
    serializedExportProperties?: string | undefined;
    nextExecutionTime?: Date | undefined;
}

export class ExportProperties implements IExportProperties {
    name?: string | undefined;
    exportType?: number | undefined;
    timeRange?: ExportPropertiesTimeRange | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    sendEmail?: boolean | undefined;
    emails?: string | undefined;
    subDirectory?: string | undefined;
    rootPath?: string | undefined;
    customTemplateFileName?: string | undefined;
    cultureName?: string | undefined;
    exportFileFormat?: number | undefined;
    previousDaysCount?: number | undefined;
    exportPerFile?: boolean | undefined;
    emailCc?: string | undefined;
    emailBcc?: string | undefined;
    emailSubject?: string | undefined;

    constructor(data?: IExportProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.exportType = _data["ExportType"];
            this.timeRange = _data["TimeRange"];
            this.truncateData = _data["TruncateData"];
            this.withDaylightSavingTime = _data["WithDaylightSavingTime"];
            this.sendEmail = _data["SendEmail"];
            this.emails = _data["Emails"];
            this.subDirectory = _data["SubDirectory"];
            this.rootPath = _data["RootPath"];
            this.customTemplateFileName = _data["CustomTemplateFileName"];
            this.cultureName = _data["CultureName"];
            this.exportFileFormat = _data["ExportFileFormat"];
            this.previousDaysCount = _data["PreviousDaysCount"];
            this.exportPerFile = _data["ExportPerFile"];
            this.emailCc = _data["EmailCc"];
            this.emailBcc = _data["EmailBcc"];
            this.emailSubject = _data["EmailSubject"];
        }
    }

    static fromJS(data: any): ExportProperties {
        data = typeof data === 'object' ? data : {};
        let result = new ExportProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["ExportType"] = this.exportType;
        data["TimeRange"] = this.timeRange;
        data["TruncateData"] = this.truncateData;
        data["WithDaylightSavingTime"] = this.withDaylightSavingTime;
        data["SendEmail"] = this.sendEmail;
        data["Emails"] = this.emails;
        data["SubDirectory"] = this.subDirectory;
        data["RootPath"] = this.rootPath;
        data["CustomTemplateFileName"] = this.customTemplateFileName;
        data["CultureName"] = this.cultureName;
        data["ExportFileFormat"] = this.exportFileFormat;
        data["PreviousDaysCount"] = this.previousDaysCount;
        data["ExportPerFile"] = this.exportPerFile;
        data["EmailCc"] = this.emailCc;
        data["EmailBcc"] = this.emailBcc;
        data["EmailSubject"] = this.emailSubject;
        return data;
    }
}

export interface IExportProperties {
    name?: string | undefined;
    exportType?: number | undefined;
    timeRange?: ExportPropertiesTimeRange | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    sendEmail?: boolean | undefined;
    emails?: string | undefined;
    subDirectory?: string | undefined;
    rootPath?: string | undefined;
    customTemplateFileName?: string | undefined;
    cultureName?: string | undefined;
    exportFileFormat?: number | undefined;
    previousDaysCount?: number | undefined;
    exportPerFile?: boolean | undefined;
    emailCc?: string | undefined;
    emailBcc?: string | undefined;
    emailSubject?: string | undefined;
}

export class Page_11 implements IPage_11 {
    items?: ExportFile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPage_11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ExportFile.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): Page_11 {
        data = typeof data === 'object' ? data : {};
        let result = new Page_11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IPage_11 {
    items?: ExportFile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ExportFile implements IExportFile {
    name?: string | undefined;
    sizeInKb?: number | undefined;
    type?: string | undefined;
    created?: Date | undefined;

    constructor(data?: IExportFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.sizeInKb = _data["SizeInKb"];
            this.type = _data["Type"];
            this.created = _data["Created"] ? new Date(_data["Created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportFile {
        data = typeof data === 'object' ? data : {};
        let result = new ExportFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["SizeInKb"] = this.sizeInKb;
        data["Type"] = this.type;
        data["Created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IExportFile {
    name?: string | undefined;
    sizeInKb?: number | undefined;
    type?: string | undefined;
    created?: Date | undefined;
}

export class KeyValueCommandResponse implements IKeyValueCommandResponse {
    collection?: string | undefined;
    keyValues?: { [key: string]: string; } | undefined;

    constructor(data?: IKeyValueCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collection = _data["Collection"];
            if (_data["KeyValues"]) {
                this.keyValues = {} as any;
                for (let key in _data["KeyValues"]) {
                    if (_data["KeyValues"].hasOwnProperty(key))
                        (<any>this.keyValues)![key] = _data["KeyValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): KeyValueCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Collection"] = this.collection;
        if (this.keyValues) {
            data["KeyValues"] = {};
            for (let key in this.keyValues) {
                if (this.keyValues.hasOwnProperty(key))
                    (<any>data["KeyValues"])[key] = (<any>this.keyValues)[key];
            }
        }
        return data;
    }
}

export interface IKeyValueCommandResponse {
    collection?: string | undefined;
    keyValues?: { [key: string]: string; } | undefined;
}

export class KeyValuePair_2 implements IKeyValuePair_2 {
    readonly key?: string | undefined;
    readonly value?: string | undefined;

    constructor(data?: IKeyValuePair_2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["Key"];
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): KeyValuePair_2 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePair_2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface IKeyValuePair_2 {
    key?: string | undefined;
    value?: string | undefined;
}

export class PlacePage implements IPlacePage {
    pageItems?: Place[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPlacePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(Place.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): PlacePage {
        data = typeof data === 'object' ? data : {};
        let result = new PlacePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IPlacePage {
    pageItems?: Place[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ReadRequestPage implements IReadRequestPage {
    pageItems?: ReadRequest[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IReadRequestPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(ReadRequest.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): ReadRequestPage {
        data = typeof data === 'object' ? data : {};
        let result = new ReadRequestPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface IReadRequestPage {
    pageItems?: ReadRequest[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ReadRequest implements IReadRequest {
    guid?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    placeId?: string | undefined;
    deviceDriverId?: number | undefined;
    regionId?: number | undefined;
    progress?: number | undefined;
    status?: ReadRequestStatus | undefined;
    statusDescription?: string | undefined;
    failureSource?: ReadRequestFailureSource | undefined;
    failureSourceDescription?: string | undefined;
    failureCode?: number | undefined;
    failureDescription?: string | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    closed?: string | undefined;
    lastAccessTime?: string | undefined;
    connectionDescription?: string | undefined;
    group?: string | undefined;
    connectionNumber?: string | undefined;
    connectionType?: string | undefined;
    deviceType?: string | undefined;

    constructor(data?: IReadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["Guid"];
            this.title = _data["Title"];
            this.note = _data["Note"];
            this.placeId = _data["PlaceId"];
            this.deviceDriverId = _data["DeviceDriverId"];
            this.regionId = _data["RegionId"];
            this.progress = _data["Progress"];
            this.status = _data["Status"];
            this.statusDescription = _data["StatusDescription"];
            this.failureSource = _data["FailureSource"];
            this.failureSourceDescription = _data["FailureSourceDescription"];
            this.failureCode = _data["FailureCode"];
            this.failureDescription = _data["FailureDescription"];
            this.created = _data["Created"];
            this.createdBy = _data["CreatedBy"];
            this.closed = _data["Closed"];
            this.lastAccessTime = _data["LastAccessTime"];
            this.connectionDescription = _data["ConnectionDescription"];
            this.group = _data["Group"];
            this.connectionNumber = _data["ConnectionNumber"];
            this.connectionType = _data["ConnectionType"];
            this.deviceType = _data["DeviceType"];
        }
    }

    static fromJS(data: any): ReadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Guid"] = this.guid;
        data["Title"] = this.title;
        data["Note"] = this.note;
        data["PlaceId"] = this.placeId;
        data["DeviceDriverId"] = this.deviceDriverId;
        data["RegionId"] = this.regionId;
        data["Progress"] = this.progress;
        data["Status"] = this.status;
        data["StatusDescription"] = this.statusDescription;
        data["FailureSource"] = this.failureSource;
        data["FailureSourceDescription"] = this.failureSourceDescription;
        data["FailureCode"] = this.failureCode;
        data["FailureDescription"] = this.failureDescription;
        data["Created"] = this.created;
        data["CreatedBy"] = this.createdBy;
        data["Closed"] = this.closed;
        data["LastAccessTime"] = this.lastAccessTime;
        data["ConnectionDescription"] = this.connectionDescription;
        data["Group"] = this.group;
        data["ConnectionNumber"] = this.connectionNumber;
        data["ConnectionType"] = this.connectionType;
        data["DeviceType"] = this.deviceType;
        return data;
    }
}

export interface IReadRequest {
    guid?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    placeId?: string | undefined;
    deviceDriverId?: number | undefined;
    regionId?: number | undefined;
    progress?: number | undefined;
    status?: ReadRequestStatus | undefined;
    statusDescription?: string | undefined;
    failureSource?: ReadRequestFailureSource | undefined;
    failureSourceDescription?: string | undefined;
    failureCode?: number | undefined;
    failureDescription?: string | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    closed?: string | undefined;
    lastAccessTime?: string | undefined;
    connectionDescription?: string | undefined;
    group?: string | undefined;
    connectionNumber?: string | undefined;
    connectionType?: string | undefined;
    deviceType?: string | undefined;
}

export class SchedulerPage implements ISchedulerPage {
    pageItems?: Scheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ISchedulerPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["PageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["PageItems"])
                    this.pageItems!.push(Scheduler.fromJS(item));
            }
            this.count = _data["Count"];
            this.totalCount = _data["TotalCount"];
        }
    }

    static fromJS(data: any): SchedulerPage {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulerPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["PageItems"] = [];
            for (let item of this.pageItems)
                data["PageItems"].push(item.toJSON());
        }
        data["Count"] = this.count;
        data["TotalCount"] = this.totalCount;
        return data;
    }
}

export interface ISchedulerPage {
    pageItems?: Scheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Scheduler implements IScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    enabled?: boolean | undefined;
    regionId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    firstReadingTime?: string | undefined;
    lastReadingTime?: string | undefined;
    lastReadingRelativeTime?: string | undefined;
    lastReadingTimeDescription?: string | undefined;
    nextReadingTime?: string | undefined;
    readStateOption?: string | undefined;
    useDeviceDriver?: boolean | undefined;
    connectionOption?: string | undefined;
    deviceDriverId?: number | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    modified?: string | undefined;
    modifiedBy?: string | undefined;
    isLimitedReadWriteOperation?: boolean | undefined;
    readWriteOperationType?: number | undefined;
    readDevicesInTimeWindows?: boolean | undefined;

    constructor(data?: IScheduler) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guid = _data["guid"];
            this.enabled = _data["enabled"];
            this.regionId = _data["regionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.firstReadingTime = _data["firstReadingTime"];
            this.lastReadingTime = _data["lastReadingTime"];
            this.lastReadingRelativeTime = _data["lastReadingRelativeTime"];
            this.lastReadingTimeDescription = _data["lastReadingTimeDescription"];
            this.nextReadingTime = _data["nextReadingTime"];
            this.readStateOption = _data["readStateOption"];
            this.useDeviceDriver = _data["useDeviceDriver"];
            this.connectionOption = _data["connectionOption"];
            this.deviceDriverId = _data["deviceDriverId"];
            this.created = _data["created"];
            this.createdBy = _data["createdBy"];
            this.modified = _data["modified"];
            this.modifiedBy = _data["modifiedBy"];
            this.isLimitedReadWriteOperation = _data["isLimitedReadWriteOperation"];
            this.readWriteOperationType = _data["readWriteOperationType"];
            this.readDevicesInTimeWindows = _data["readDevicesInTimeWindows"];
        }
    }

    static fromJS(data: any): Scheduler {
        data = typeof data === 'object' ? data : {};
        let result = new Scheduler();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["enabled"] = this.enabled;
        data["regionId"] = this.regionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["firstReadingTime"] = this.firstReadingTime;
        data["lastReadingTime"] = this.lastReadingTime;
        data["lastReadingRelativeTime"] = this.lastReadingRelativeTime;
        data["lastReadingTimeDescription"] = this.lastReadingTimeDescription;
        data["nextReadingTime"] = this.nextReadingTime;
        data["readStateOption"] = this.readStateOption;
        data["useDeviceDriver"] = this.useDeviceDriver;
        data["connectionOption"] = this.connectionOption;
        data["deviceDriverId"] = this.deviceDriverId;
        data["created"] = this.created;
        data["createdBy"] = this.createdBy;
        data["modified"] = this.modified;
        data["modifiedBy"] = this.modifiedBy;
        data["isLimitedReadWriteOperation"] = this.isLimitedReadWriteOperation;
        data["readWriteOperationType"] = this.readWriteOperationType;
        data["readDevicesInTimeWindows"] = this.readDevicesInTimeWindows;
        return data;
    }
}

export interface IScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    enabled?: boolean | undefined;
    regionId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    firstReadingTime?: string | undefined;
    lastReadingTime?: string | undefined;
    lastReadingRelativeTime?: string | undefined;
    lastReadingTimeDescription?: string | undefined;
    nextReadingTime?: string | undefined;
    readStateOption?: string | undefined;
    useDeviceDriver?: boolean | undefined;
    connectionOption?: string | undefined;
    deviceDriverId?: number | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    modified?: string | undefined;
    modifiedBy?: string | undefined;
    isLimitedReadWriteOperation?: boolean | undefined;
    readWriteOperationType?: number | undefined;
    readDevicesInTimeWindows?: boolean | undefined;
}

export class SystemInfo implements ISystemInfo {
    devicesCount?: number | undefined;
    devicesReadingCompleted?: number | undefined;
    devicesFailures?: number | undefined;
    devicesReadingInProgress?: number | undefined;
    serversCount?: number | undefined;
    serversOnline?: number | undefined;
    serversOffline?: number | undefined;
    usersOnline?: number | undefined;
    activeAlarms?: number | undefined;
    errors?: number | undefined;
    commandsPerMinute?: number | undefined;
    masterDataRowCount?: number | undefined;
    operatingDataRowCount?: number | undefined;
    dataPumpCount?: number | undefined;
    dataPumpsInError?: number | undefined;
    overallReadingSuccessRate?: number[] | undefined;
    readingSuccessRate?: number | undefined;

    constructor(data?: ISystemInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.devicesCount = _data["DevicesCount"];
            this.devicesReadingCompleted = _data["DevicesReadingCompleted"];
            this.devicesFailures = _data["DevicesFailures"];
            this.devicesReadingInProgress = _data["DevicesReadingInProgress"];
            this.serversCount = _data["ServersCount"];
            this.serversOnline = _data["ServersOnline"];
            this.serversOffline = _data["ServersOffline"];
            this.usersOnline = _data["UsersOnline"];
            this.activeAlarms = _data["ActiveAlarms"];
            this.errors = _data["Errors"];
            this.commandsPerMinute = _data["CommandsPerMinute"];
            this.masterDataRowCount = _data["MasterDataRowCount"];
            this.operatingDataRowCount = _data["OperatingDataRowCount"];
            this.dataPumpCount = _data["DataPumpCount"];
            this.dataPumpsInError = _data["DataPumpsInError"];
            if (Array.isArray(_data["OverallReadingSuccessRate"])) {
                this.overallReadingSuccessRate = [] as any;
                for (let item of _data["OverallReadingSuccessRate"])
                    this.overallReadingSuccessRate!.push(item);
            }
            this.readingSuccessRate = _data["ReadingSuccessRate"];
        }
    }

    static fromJS(data: any): SystemInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DevicesCount"] = this.devicesCount;
        data["DevicesReadingCompleted"] = this.devicesReadingCompleted;
        data["DevicesFailures"] = this.devicesFailures;
        data["DevicesReadingInProgress"] = this.devicesReadingInProgress;
        data["ServersCount"] = this.serversCount;
        data["ServersOnline"] = this.serversOnline;
        data["ServersOffline"] = this.serversOffline;
        data["UsersOnline"] = this.usersOnline;
        data["ActiveAlarms"] = this.activeAlarms;
        data["Errors"] = this.errors;
        data["CommandsPerMinute"] = this.commandsPerMinute;
        data["MasterDataRowCount"] = this.masterDataRowCount;
        data["OperatingDataRowCount"] = this.operatingDataRowCount;
        data["DataPumpCount"] = this.dataPumpCount;
        data["DataPumpsInError"] = this.dataPumpsInError;
        if (Array.isArray(this.overallReadingSuccessRate)) {
            data["OverallReadingSuccessRate"] = [];
            for (let item of this.overallReadingSuccessRate)
                data["OverallReadingSuccessRate"].push(item);
        }
        data["ReadingSuccessRate"] = this.readingSuccessRate;
        return data;
    }
}

export interface ISystemInfo {
    devicesCount?: number | undefined;
    devicesReadingCompleted?: number | undefined;
    devicesFailures?: number | undefined;
    devicesReadingInProgress?: number | undefined;
    serversCount?: number | undefined;
    serversOnline?: number | undefined;
    serversOffline?: number | undefined;
    usersOnline?: number | undefined;
    activeAlarms?: number | undefined;
    errors?: number | undefined;
    commandsPerMinute?: number | undefined;
    masterDataRowCount?: number | undefined;
    operatingDataRowCount?: number | undefined;
    dataPumpCount?: number | undefined;
    dataPumpsInError?: number | undefined;
    overallReadingSuccessRate?: number[] | undefined;
    readingSuccessRate?: number | undefined;
}

export class ServerRegion implements IServerRegion {
    id?: number | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    dealerIdentification?: string | undefined;

    constructor(data?: IServerRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.abbreviation = _data["Abbreviation"];
            this.dealerIdentification = _data["DealerIdentification"];
        }
    }

    static fromJS(data: any): ServerRegion {
        data = typeof data === 'object' ? data : {};
        let result = new ServerRegion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Abbreviation"] = this.abbreviation;
        data["DealerIdentification"] = this.dealerIdentification;
        return data;
    }
}

export interface IServerRegion {
    id?: number | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    dealerIdentification?: string | undefined;
}

export class ServerTime implements IServerTime {
    now?: Date | undefined;
    utcNow?: Date | undefined;

    constructor(data?: IServerTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.now = _data["Now"] ? new Date(_data["Now"].toString()) : <any>undefined;
            this.utcNow = _data["UtcNow"] ? new Date(_data["UtcNow"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerTime {
        data = typeof data === 'object' ? data : {};
        let result = new ServerTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Now"] = this.now ? this.now.toISOString() : <any>undefined;
        data["UtcNow"] = this.utcNow ? this.utcNow.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServerTime {
    now?: Date | undefined;
    utcNow?: Date | undefined;
}

export class ServerVersion implements IServerVersion {
    version?: string | undefined;

    constructor(data?: IServerVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["Version"];
        }
    }

    static fromJS(data: any): ServerVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ServerVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Version"] = this.version;
        return data;
    }
}

export interface IServerVersion {
    version?: string | undefined;
}

export class SystemEventLog implements ISystemEventLog {
    eventType?: SystemEventLogEventType | undefined;
    eventId?: number | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;

    constructor(data?: ISystemEventLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["EventType"];
            this.eventId = _data["EventId"];
            this.category = _data["Category"];
            this.message = _data["Message"];
            this.data = _data["Data"];
            this.userName = _data["UserName"];
        }
    }

    static fromJS(data: any): SystemEventLog {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEventLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EventType"] = this.eventType;
        data["EventId"] = this.eventId;
        data["Category"] = this.category;
        data["Message"] = this.message;
        data["Data"] = this.data;
        data["UserName"] = this.userName;
        return data;
    }
}

export interface ISystemEventLog {
    eventType?: SystemEventLogEventType | undefined;
    eventId?: number | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
}

export class SessionIds implements ISessionIds {
    sessionIds?: string[] | undefined;

    constructor(data?: ISessionIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sessionIds"])) {
                this.sessionIds = [] as any;
                for (let item of _data["sessionIds"])
                    this.sessionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SessionIds {
        data = typeof data === 'object' ? data : {};
        let result = new SessionIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sessionIds)) {
            data["sessionIds"] = [];
            for (let item of this.sessionIds)
                data["sessionIds"].push(item);
        }
        return data;
    }
}

export interface ISessionIds {
    sessionIds?: string[] | undefined;
}

export enum DataRange {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum DataRange2 {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum ConnectionOption {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ReadWriteOperationType {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
}

export enum AlarmEntryObjectState {
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

export enum ConsumptionPlaceObjectState {
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

export enum CustomerObjectState {
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

export enum BaseDeviceType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
    _22 = 22,
    _24 = 24,
    _25 = 25,
    _26 = 26,
    _27 = 27,
    _28 = 28,
    _29 = 29,
    _30 = 30,
    _31 = 31,
    _32 = 32,
    _33 = 33,
    _34 = 34,
    _35 = 35,
    _36 = 36,
    _37 = 37,
    _38 = 38,
    _39 = 39,
    _40 = 40,
    _41 = 41,
    _42 = 42,
    _43 = 43,
    _44 = 44,
    _45 = 45,
    _46 = 46,
    _47 = 47,
    _48 = 48,
    _49 = 49,
    _50 = 50,
    _51 = 51,
    _52 = 52,
    _53 = 53,
    _54 = 54,
    _55 = 55,
    _56 = 56,
    _57 = 57,
    _58 = 58,
    _59 = 59,
    _60 = 60,
    _61 = 61,
    _62 = 62,
    _63 = 63,
    _64 = 64,
    _65 = 65,
    _66 = 66,
    _67 = 67,
    _68 = 68,
    _69 = 69,
    _70 = 70,
    _71 = 71,
    _72 = 72,
    _73 = 73,
    _74 = 74,
    _75 = 75,
    _76 = 76,
    _77 = 77,
    _78 = 78,
    _79 = 79,
    _80 = 80,
    _81 = 81,
    _82 = 82,
    _83 = 83,
    _84 = 84,
    _85 = 85,
    _86 = 86,
    _87 = 87,
    _88 = 88,
    _89 = 89,
    _90 = 90,
    _91 = 91,
    _92 = 92,
    _93 = 93,
    __1 = -1,
}

export enum BaseDeviceReadProcessState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    __1 = -1,
}

export enum BaseDeviceChromatographPeriod {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum BaseDeviceKind {
    _0 = 0,
    _1 = 1,
}

export enum BaseDeviceSourceDataPeriod {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum BaseDeviceValveAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum BaseDeviceValveState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum BaseDeviceObjectState {
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

export enum DeviceTypeDescriptionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
    _22 = 22,
    _24 = 24,
    _25 = 25,
    _26 = 26,
    _27 = 27,
    _28 = 28,
    _29 = 29,
    _30 = 30,
    _31 = 31,
    _32 = 32,
    _33 = 33,
    _34 = 34,
    _35 = 35,
    _36 = 36,
    _37 = 37,
    _38 = 38,
    _39 = 39,
    _40 = 40,
    _41 = 41,
    _42 = 42,
    _43 = 43,
    _44 = 44,
    _45 = 45,
    _46 = 46,
    _47 = 47,
    _48 = 48,
    _49 = 49,
    _50 = 50,
    _51 = 51,
    _52 = 52,
    _53 = 53,
    _54 = 54,
    _55 = 55,
    _56 = 56,
    _57 = 57,
    _58 = 58,
    _59 = 59,
    _60 = 60,
    _61 = 61,
    _62 = 62,
    _63 = 63,
    _64 = 64,
    _65 = 65,
    _66 = 66,
    _67 = 67,
    _68 = 68,
    _69 = 69,
    _70 = 70,
    _71 = 71,
    _72 = 72,
    _73 = 73,
    _74 = 74,
    _75 = 75,
    _76 = 76,
    _77 = 77,
    _78 = 78,
    _79 = 79,
    _80 = 80,
    _81 = 81,
    _82 = 82,
    _83 = 83,
    _84 = 84,
    _85 = 85,
    _86 = 86,
    _87 = 87,
    _88 = 88,
    _89 = 89,
    _90 = 90,
    _91 = 91,
    _92 = 92,
    _93 = 93,
    __1 = -1,
}

export enum DeviceTypeDescriptionObjectState {
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
}

export enum SystemEventEntryType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum DataTableRemotingFormat {
    _0 = 0,
    _1 = 1,
}

export enum DataSetRemotingFormat {
    _0 = 0,
    _1 = 1,
}

export enum DataSetSchemaSerializationMode {
    _1 = 1,
    _2 = 2,
}

export enum DataColumnDateTimeMode {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum DataColumnColumnMapping {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum DeviceChartDataDataType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum DriverCommunicationChannelChannelType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    __1 = -1,
}

export enum DriverCommunicationChannelChannelState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DeviceAlarmItemCondition {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export enum GasConversionParametersCompressibilityType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export enum ExportSchedulerPeriodicallyConditionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ExportPropertiesTimeRange {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
}

export enum ReadRequestStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    __1 = -1,
}

export enum ReadRequestFailureSource {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export enum SystemEventLogEventType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}