//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IActualValuesClient {
    /**
     * @return Actual values for requested places
     */
    getActualValues(placeIds: number[]): Promise<ActualValues>;
}

export class ActualValuesClient implements IActualValuesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Actual values for requested places
     */
    getActualValues(placeIds: number[], cancelToken?: CancelToken | undefined): Promise<ActualValues> {
        let url_ = this.baseUrl + "/v1/actual-values?";
        if (placeIds === undefined || placeIds === null)
            throw new Error("The parameter 'placeIds' must be defined and cannot be null.");
        else
            placeIds && placeIds.forEach(item => { url_ += "placeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetActualValues(_response);
        });
    }

    protected processGetActualValues(response: AxiosResponse): Promise<ActualValues> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ActualValues.fromJS(resultData200);
            return Promise.resolve<ActualValues>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ActualValues>(null as any);
    }
}

export interface IAlarmsClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of alarms
     */
    getAlarms(type: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<AlarmPage>;
}

export class AlarmsClient implements IAlarmsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of alarms
     */
    getAlarms(type: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<AlarmPage> {
        let url_ = this.baseUrl + "/v1/alarms?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlarms(_response);
        });
    }

    protected processGetAlarms(response: AxiosResponse): Promise<AlarmPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AlarmPage.fromJS(resultData200);
            return Promise.resolve<AlarmPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AlarmPage>(null as any);
    }
}

export interface IClient {
    /**
     * @return OK
     */
    alarms_annotated(annotation: AlarmsAnnotation): Promise<any>;
    /**
     * @return OK
     */
    alarms_acknowledged(alarmIds: number[]): Promise<any>;
    /**
     * @return OK
     */
    user_logOff(): Promise<any>;
    /**
     * @return OK
     */
    cancel_Communication_Test(guid: string): Promise<any>;
    /**
     * @return OK
     */
    start_Communication_Test(guid: string, connectionNumber: string, connectionType: number, deviceDriverId: number, deviceParameters: string): Promise<any>;
    /**
     * @return OK
     */
    run_DataPump_with_GUID(dataPumpGuid: string): Promise<any>;
    /**
     * @return OK
     */
    validate_Data(validationRequest: DataValidationRequest): Promise<any>;
    /**
     * @return OK
     */
    cancel_Data_Validation(validationRequest: DataValidationRequest): Promise<any>;
    /**
     * @return OK
     */
    servers_forced_to_update(serverIds: number[], reason: string): Promise<any>;
    /**
     * @return OK
     */
    servers_forced_to_restart(serverIds: number[], reason: string): Promise<any>;
    /**
     * @return OK
     */
    server_forced_to_update(serverId: number, reason: string): Promise<any>;
    /**
     * @return OK
     */
    server_forced_to_restart(serverId: number, reason: string): Promise<any>;
    /**
     * @return OK
     */
    save_KeyValue_pair(collection: string, key: string, value: string): Promise<any>;
    /**
     * @return OK
     */
    delete_KeyValue_pair(collection: string, key: string): Promise<any>;
    /**
     * @return OK
     */
    read_profile(profileId: number): Promise<any>;
    /**
     * @return OK
     */
    read_profiles(profileIds: number[]): Promise<any>;
    /**
     * @return OK
     */
    cancel_reading_request(readRequestGuids: string[]): Promise<any>;
    /**
     * @param useCommonDeviceDriver (optional) 
     * @param boostPriority (optional) 
     * @param isLimitedReadWriteOperation (optional) 
     * @return OK
     */
    create_reading_request_for_places(placeIds: number[], connectionOption: ConnectionOption, readWriteOperationType: ReadWriteOperationType, deviceDriverId: number, useCommonDeviceDriver: boolean | null | undefined, boostPriority: boolean | null | undefined, isLimitedReadWriteOperation: boolean | null | undefined): Promise<any>;
    /**
     * @return OK
     */
    read_schedulers(schedulerIds: number[]): Promise<any>;
    /**
     * @return OK
     */
    shift_schedulers_execution_time(minutesToAdd: number, schedulerIds: number[]): Promise<any>;
    /**
     * @return OK
     */
    saves_a_system_event(eventLog: SystemEventLog): Promise<any>;
    /**
     * @return OK
     */
    users_disconnected(encodedSessions: SessionIds): Promise<any>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return OK
     */
    alarms_annotated(annotation: AlarmsAnnotation, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/alarms/annotate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(annotation);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlarms_annotated(_response);
        });
    }

    protected processAlarms_annotated(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    alarms_acknowledged(alarmIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/alarms/acknowledge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(alarmIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAlarms_acknowledged(_response);
        });
    }

    protected processAlarms_acknowledged(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    user_logOff( cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/auth/logoff";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUser_logOff(_response);
        });
    }

    protected processUser_logOff(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_Communication_Test(guid: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/test/cancel?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_Communication_Test(_response);
        });
    }

    protected processCancel_Communication_Test(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    start_Communication_Test(guid: string, connectionNumber: string, connectionType: number, deviceDriverId: number, deviceParameters: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/test/start?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        if (connectionNumber === undefined || connectionNumber === null)
            throw new Error("The parameter 'connectionNumber' must be defined and cannot be null.");
        else
            url_ += "connectionNumber=" + encodeURIComponent("" + connectionNumber) + "&";
        if (connectionType === undefined || connectionType === null)
            throw new Error("The parameter 'connectionType' must be defined and cannot be null.");
        else
            url_ += "connectionType=" + encodeURIComponent("" + connectionType) + "&";
        if (deviceDriverId === undefined || deviceDriverId === null)
            throw new Error("The parameter 'deviceDriverId' must be defined and cannot be null.");
        else
            url_ += "deviceDriverId=" + encodeURIComponent("" + deviceDriverId) + "&";
        if (deviceParameters === undefined || deviceParameters === null)
            throw new Error("The parameter 'deviceParameters' must be defined and cannot be null.");
        else
            url_ += "deviceParameters=" + encodeURIComponent("" + deviceParameters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStart_Communication_Test(_response);
        });
    }

    protected processStart_Communication_Test(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    run_DataPump_with_GUID(dataPumpGuid: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/data/pumps/{dataPumpGuid}/run";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRun_DataPump_with_GUID(_response);
        });
    }

    protected processRun_DataPump_with_GUID(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    validate_Data(validationRequest: DataValidationRequest, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/data/validation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(validationRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate_Data(_response);
        });
    }

    protected processValidate_Data(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_Data_Validation(validationRequest: DataValidationRequest, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/data/validation/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(validationRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_Data_Validation(_response);
        });
    }

    protected processCancel_Data_Validation(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    servers_forced_to_update(serverIds: number[], reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/update?";
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(serverIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServers_forced_to_update(_response);
        });
    }

    protected processServers_forced_to_update(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    servers_forced_to_restart(serverIds: number[], reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/restart?";
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(serverIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServers_forced_to_restart(_response);
        });
    }

    protected processServers_forced_to_restart(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    server_forced_to_update(serverId: number, reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/{serverId}/update?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServer_forced_to_update(_response);
        });
    }

    protected processServer_forced_to_update(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    server_forced_to_restart(serverId: number, reason: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/{serverId}/restart?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (reason === undefined || reason === null)
            throw new Error("The parameter 'reason' must be defined and cannot be null.");
        else
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServer_forced_to_restart(_response);
        });
    }

    protected processServer_forced_to_restart(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    save_KeyValue_pair(collection: string, key: string, value: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/key-value-store/{collection}/{key}?";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (value === undefined || value === null)
            throw new Error("The parameter 'value' must be defined and cannot be null.");
        else
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSave_KeyValue_pair(_response);
        });
    }

    protected processSave_KeyValue_pair(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    delete_KeyValue_pair(collection: string, key: string, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/key-value-store/{collection}/{key}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete_KeyValue_pair(_response);
        });
    }

    protected processDelete_KeyValue_pair(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_profile(profileId: number, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/profiles/{profileId}/read";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_profile(_response);
        });
    }

    protected processRead_profile(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_profiles(profileIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/profiles/read?";
        if (profileIds === undefined || profileIds === null)
            throw new Error("The parameter 'profileIds' must be defined and cannot be null.");
        else
            profileIds && profileIds.forEach(item => { url_ += "profileIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_profiles(_response);
        });
    }

    protected processRead_profiles(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    cancel_reading_request(readRequestGuids: string[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/read/cancel?";
        if (readRequestGuids === undefined || readRequestGuids === null)
            throw new Error("The parameter 'readRequestGuids' must be defined and cannot be null.");
        else
            readRequestGuids && readRequestGuids.forEach(item => { url_ += "readRequestGuids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel_reading_request(_response);
        });
    }

    protected processCancel_reading_request(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @param useCommonDeviceDriver (optional) 
     * @param boostPriority (optional) 
     * @param isLimitedReadWriteOperation (optional) 
     * @return OK
     */
    create_reading_request_for_places(placeIds: number[], connectionOption: ConnectionOption, readWriteOperationType: ReadWriteOperationType, deviceDriverId: number, useCommonDeviceDriver: boolean | null | undefined, boostPriority: boolean | null | undefined, isLimitedReadWriteOperation: boolean | null | undefined, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/read?";
        if (placeIds === undefined || placeIds === null)
            throw new Error("The parameter 'placeIds' must be defined and cannot be null.");
        else
            placeIds && placeIds.forEach(item => { url_ += "placeIds=" + encodeURIComponent("" + item) + "&"; });
        if (connectionOption === undefined || connectionOption === null)
            throw new Error("The parameter 'connectionOption' must be defined and cannot be null.");
        else
            url_ += "connectionOption=" + encodeURIComponent("" + connectionOption) + "&";
        if (readWriteOperationType === undefined || readWriteOperationType === null)
            throw new Error("The parameter 'readWriteOperationType' must be defined and cannot be null.");
        else
            url_ += "readWriteOperationType=" + encodeURIComponent("" + readWriteOperationType) + "&";
        if (deviceDriverId === undefined || deviceDriverId === null)
            throw new Error("The parameter 'deviceDriverId' must be defined and cannot be null.");
        else
            url_ += "deviceDriverId=" + encodeURIComponent("" + deviceDriverId) + "&";
        if (useCommonDeviceDriver !== undefined && useCommonDeviceDriver !== null)
            url_ += "useCommonDeviceDriver=" + encodeURIComponent("" + useCommonDeviceDriver) + "&";
        if (boostPriority !== undefined && boostPriority !== null)
            url_ += "boostPriority=" + encodeURIComponent("" + boostPriority) + "&";
        if (isLimitedReadWriteOperation !== undefined && isLimitedReadWriteOperation !== null)
            url_ += "isLimitedReadWriteOperation=" + encodeURIComponent("" + isLimitedReadWriteOperation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate_reading_request_for_places(_response);
        });
    }

    protected processCreate_reading_request_for_places(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    read_schedulers(schedulerIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/schedulers/read?";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRead_schedulers(_response);
        });
    }

    protected processRead_schedulers(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    shift_schedulers_execution_time(minutesToAdd: number, schedulerIds: number[], cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/schedulers/shift?";
        if (minutesToAdd === undefined || minutesToAdd === null)
            throw new Error("The parameter 'minutesToAdd' must be defined and cannot be null.");
        else
            url_ += "minutesToAdd=" + encodeURIComponent("" + minutesToAdd) + "&";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShift_schedulers_execution_time(_response);
        });
    }

    protected processShift_schedulers_execution_time(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    saves_a_system_event(eventLog: SystemEventLog, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/system/events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventLog);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaves_a_system_event(_response);
        });
    }

    protected processSaves_a_system_event(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * @return OK
     */
    users_disconnected(encodedSessions: SessionIds, cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/v1/users/disconnect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(encodedSessions);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsers_disconnected(_response);
        });
    }

    protected processUsers_disconnected(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }
}

export interface IAuthClient {
    /**
     * @return User logged on
     */
    logon(login: Login): Promise<ConnectedUserLite>;
}

export class AuthClient implements IAuthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return User logged on
     */
    logon(login: Login, cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite> {
        let url_ = this.baseUrl + "/v1/auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogon(_response);
        });
    }

    protected processLogon(response: AxiosResponse): Promise<ConnectedUserLite> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConnectedUserLite.fromJS(resultData200);
            return Promise.resolve<ConnectedUserLite>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("User not logged on", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite>(null as any);
    }
}

export interface ICallStatisticsClient {
    /**
     * @return Get Call Statistics logs
     */
    getCallLogs(placeId: number, readingStart: Date): Promise<CallLogs>;
    /**
     * @return Get Call Statistics chart data
     */
    getCallStatisticsChartData(placeId: number, dataRange: number, chartType: number): Promise<ChartData>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get Call Statistics paged
     */
    getCallStatistics(from: Date, to: Date, placeId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<CallStatisticPage>;
}

export class CallStatisticsClient implements ICallStatisticsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get Call Statistics logs
     */
    getCallLogs(placeId: number, readingStart: Date, cancelToken?: CancelToken | undefined): Promise<CallLogs> {
        let url_ = this.baseUrl + "/v1/statistics/logs?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (readingStart === undefined || readingStart === null)
            throw new Error("The parameter 'readingStart' must be defined and cannot be null.");
        else
            url_ += "readingStart=" + encodeURIComponent(readingStart ? "" + readingStart.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallLogs(_response);
        });
    }

    protected processGetCallLogs(response: AxiosResponse): Promise<CallLogs> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogs.fromJS(resultData200);
            return Promise.resolve<CallLogs>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogs>(null as any);
    }

    /**
     * @return Get Call Statistics chart data
     */
    getCallStatisticsChartData(placeId: number, dataRange: number, chartType: number, cancelToken?: CancelToken | undefined): Promise<ChartData> {
        let url_ = this.baseUrl + "/v1/statistics/chart-data?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        if (chartType === undefined || chartType === null)
            throw new Error("The parameter 'chartType' must be defined and cannot be null.");
        else
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallStatisticsChartData(_response);
        });
    }

    protected processGetCallStatisticsChartData(response: AxiosResponse): Promise<ChartData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChartData.fromJS(resultData200);
            return Promise.resolve<ChartData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get Call Statistics paged
     */
    getCallStatistics(from: Date, to: Date, placeId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallStatisticPage> {
        let url_ = this.baseUrl + "/v1/statistics?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCallStatistics(_response);
        });
    }

    protected processGetCallStatistics(response: AxiosResponse): Promise<CallStatisticPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallStatisticPage.fromJS(resultData200);
            return Promise.resolve<CallStatisticPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallStatisticPage>(null as any);
    }
}

export interface ICommunicationTestClient {
    /**
     * @return Get Communication Test Progress
     */
    getCommunicationTestProgress(guid: string): Promise<CommunicationTestProgress>;
}

export class CommunicationTestClient implements ICommunicationTestClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get Communication Test Progress
     */
    getCommunicationTestProgress(guid: string, cancelToken?: CancelToken | undefined): Promise<CommunicationTestProgress> {
        let url_ = this.baseUrl + "/v1/test/progress?";
        if (guid === undefined || guid === null)
            throw new Error("The parameter 'guid' must be defined and cannot be null.");
        else
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommunicationTestProgress(_response);
        });
    }

    protected processGetCommunicationTestProgress(response: AxiosResponse): Promise<CommunicationTestProgress> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CommunicationTestProgress.fromJS(resultData200);
            return Promise.resolve<CommunicationTestProgress>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunicationTestProgress>(null as any);
    }
}

export interface IConnectedUserClient {
    /**
     * @return Connected user
     */
    getConnectedUser(): Promise<ConnectedUserLite>;
    /**
     * @return Email updated
     */
    updateEmail(newEmail: string): Promise<void>;
    /**
     * @return Phone updated
     */
    updatePhone(newPhone: string): Promise<void>;
    /**
     * @return Username updated
     */
    updateUserName(newUserName: string): Promise<void>;
    /**
     * @return Password changed
     */
    changePassword(changePassword: ChangePassword): Promise<void>;
}

export class ConnectedUserClient implements IConnectedUserClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Connected user
     */
    getConnectedUser( cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite> {
        let url_ = this.baseUrl + "/v1/users/connected-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectedUser(_response);
        });
    }

    protected processGetConnectedUser(response: AxiosResponse): Promise<ConnectedUserLite> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConnectedUserLite.fromJS(resultData200);
            return Promise.resolve<ConnectedUserLite>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite>(null as any);
    }

    /**
     * @return Email updated
     */
    updateEmail(newEmail: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/connected-user/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEmail);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateEmail(_response);
        });
    }

    protected processUpdateEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Email not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Phone updated
     */
    updatePhone(newPhone: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/connected-user/phone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newPhone);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePhone(_response);
        });
    }

    protected processUpdatePhone(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Phone not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Username updated
     */
    updateUserName(newUserName: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/connected-user/username";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserName);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserName(_response);
        });
    }

    protected processUpdateUserName(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException("Username not changed", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Password changed
     */
    changePassword(changePassword: ChangePassword, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/users/connected-user/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePassword);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IDashboardClient {
    /**
     * @return Dashboard variables
     */
    getDashboardVariables(): Promise<DashboardVariables>;
    /**
     * @return Dashboard main devices
     */
    getDashboardMainDevices(regionId: number): Promise<DashboardMainDevices>;
    /**
     * @return Dashboard
     */
    getDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string): Promise<DashboardRoot>;
    /**
     * @return Dashboard export in .xlsx
     */
    exportDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string): Promise<void>;
}

export class DashboardClient implements IDashboardClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Dashboard variables
     */
    getDashboardVariables( cancelToken?: CancelToken | undefined): Promise<DashboardVariables> {
        let url_ = this.baseUrl + "/v1/dashboard/variables";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardVariables(_response);
        });
    }

    protected processGetDashboardVariables(response: AxiosResponse): Promise<DashboardVariables> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardVariables.fromJS(resultData200);
            return Promise.resolve<DashboardVariables>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardVariables>(null as any);
    }

    /**
     * @return Dashboard main devices
     */
    getDashboardMainDevices(regionId: number, cancelToken?: CancelToken | undefined): Promise<DashboardMainDevices> {
        let url_ = this.baseUrl + "/v1/dashboard/devices?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboardMainDevices(_response);
        });
    }

    protected processGetDashboardMainDevices(response: AxiosResponse): Promise<DashboardMainDevices> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardMainDevices.fromJS(resultData200);
            return Promise.resolve<DashboardMainDevices>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardMainDevices>(null as any);
    }

    /**
     * @return Dashboard
     */
    getDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string, cancelToken?: CancelToken | undefined): Promise<DashboardRoot> {
        let url_ = this.baseUrl + "/v1/dashboard?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        if (dealerId === undefined || dealerId === null)
            throw new Error("The parameter 'dealerId' must be defined and cannot be null.");
        else
            url_ += "dealerId=" + encodeURIComponent("" + dealerId) + "&";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (truncateData === undefined || truncateData === null)
            throw new Error("The parameter 'truncateData' must be defined and cannot be null.");
        else
            url_ += "truncateData=" + encodeURIComponent("" + truncateData) + "&";
        if (withDaylightSavingTime === undefined || withDaylightSavingTime === null)
            throw new Error("The parameter 'withDaylightSavingTime' must be defined and cannot be null.");
        else
            url_ += "withDaylightSavingTime=" + encodeURIComponent("" + withDaylightSavingTime) + "&";
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined and cannot be null.");
        else
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (dataType === undefined || dataType === null)
            throw new Error("The parameter 'dataType' must be defined and cannot be null.");
        else
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        if (mainDeviceGuidFilter === undefined || mainDeviceGuidFilter === null)
            throw new Error("The parameter 'mainDeviceGuidFilter' must be defined and cannot be null.");
        else
            url_ += "mainDeviceGuidFilter=" + encodeURIComponent("" + mainDeviceGuidFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: AxiosResponse): Promise<DashboardRoot> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardRoot.fromJS(resultData200);
            return Promise.resolve<DashboardRoot>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardRoot>(null as any);
    }

    /**
     * @return Dashboard export in .xlsx
     */
    exportDashboard(regionId: number, dealerId: number, dateFrom: Date, dateTo: Date, truncateData: boolean, withDaylightSavingTime: boolean, fieldName: string, dataType: number, mainDeviceGuidFilter: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/dashboard/export?";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined and cannot be null.");
        else
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        if (dealerId === undefined || dealerId === null)
            throw new Error("The parameter 'dealerId' must be defined and cannot be null.");
        else
            url_ += "dealerId=" + encodeURIComponent("" + dealerId) + "&";
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (truncateData === undefined || truncateData === null)
            throw new Error("The parameter 'truncateData' must be defined and cannot be null.");
        else
            url_ += "truncateData=" + encodeURIComponent("" + truncateData) + "&";
        if (withDaylightSavingTime === undefined || withDaylightSavingTime === null)
            throw new Error("The parameter 'withDaylightSavingTime' must be defined and cannot be null.");
        else
            url_ += "withDaylightSavingTime=" + encodeURIComponent("" + withDaylightSavingTime) + "&";
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined and cannot be null.");
        else
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (dataType === undefined || dataType === null)
            throw new Error("The parameter 'dataType' must be defined and cannot be null.");
        else
            url_ += "dataType=" + encodeURIComponent("" + dataType) + "&";
        if (mainDeviceGuidFilter === undefined || mainDeviceGuidFilter === null)
            throw new Error("The parameter 'mainDeviceGuidFilter' must be defined and cannot be null.");
        else
            url_ += "mainDeviceGuidFilter=" + encodeURIComponent("" + mainDeviceGuidFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExportDashboard(_response);
        });
    }

    protected processExportDashboard(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IDataExportClient {
    /**
     * @param exportFileParameters_dateFrom (optional) 
     * @param exportFileParameters_dateTo (optional) 
     * @param exportFileParameters_leaveDateAsItIs (optional) 
     * @param exportFileParameters_placesIds (optional) 
     * @param exportFileParameters_profilesIds (optional) 
     * @param exportFileParameters_internetAveExportType (optional) 
     * @param exportFileParameters_exportType (optional) 
     * @param exportFileParameters_truncateData (optional) 
     * @param exportFileParameters_withDaylightSavingTime (optional) 
     * @param exportFileParameters_templateFile_fileName (optional) 
     * @param exportFileParameters_templateFile_contentBase64 (optional) 
     * @param exportFileParameters_deviceGroupName (optional) 
     * @param exportFileParameters_clientOutputFileName (optional) 
     * @return Export file
     */
    getExportFile(exportFileParameters_dateFrom: Date | null | undefined, exportFileParameters_dateTo: Date | null | undefined, exportFileParameters_leaveDateAsItIs: boolean | null | undefined, exportFileParameters_placesIds: number[] | null | undefined, exportFileParameters_profilesIds: number[] | null | undefined, exportFileParameters_internetAveExportType: string | null | undefined, exportFileParameters_exportType: number | null | undefined, exportFileParameters_truncateData: boolean | null | undefined, exportFileParameters_withDaylightSavingTime: boolean | null | undefined, exportFileParameters_templateFile_fileName: string | null | undefined, exportFileParameters_templateFile_contentBase64: string | null | undefined, exportFileParameters_deviceGroupName: string | null | undefined, exportFileParameters_clientOutputFileName: string | null | undefined): Promise<void>;
    /**
     * @return List of Export types
     */
    getExportTypes(): Promise<DataExportType>;
    /**
     * @return List of Export templates
     */
    getExportTemplates(): Promise<string[]>;
}

export class DataExportClient implements IDataExportClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param exportFileParameters_dateFrom (optional) 
     * @param exportFileParameters_dateTo (optional) 
     * @param exportFileParameters_leaveDateAsItIs (optional) 
     * @param exportFileParameters_placesIds (optional) 
     * @param exportFileParameters_profilesIds (optional) 
     * @param exportFileParameters_internetAveExportType (optional) 
     * @param exportFileParameters_exportType (optional) 
     * @param exportFileParameters_truncateData (optional) 
     * @param exportFileParameters_withDaylightSavingTime (optional) 
     * @param exportFileParameters_templateFile_fileName (optional) 
     * @param exportFileParameters_templateFile_contentBase64 (optional) 
     * @param exportFileParameters_deviceGroupName (optional) 
     * @param exportFileParameters_clientOutputFileName (optional) 
     * @return Export file
     */
    getExportFile(exportFileParameters_dateFrom: Date | null | undefined, exportFileParameters_dateTo: Date | null | undefined, exportFileParameters_leaveDateAsItIs: boolean | null | undefined, exportFileParameters_placesIds: number[] | null | undefined, exportFileParameters_profilesIds: number[] | null | undefined, exportFileParameters_internetAveExportType: string | null | undefined, exportFileParameters_exportType: number | null | undefined, exportFileParameters_truncateData: boolean | null | undefined, exportFileParameters_withDaylightSavingTime: boolean | null | undefined, exportFileParameters_templateFile_fileName: string | null | undefined, exportFileParameters_templateFile_contentBase64: string | null | undefined, exportFileParameters_deviceGroupName: string | null | undefined, exportFileParameters_clientOutputFileName: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/data/export/file?";
        if (exportFileParameters_dateFrom !== undefined && exportFileParameters_dateFrom !== null)
            url_ += "exportFileParameters.dateFrom=" + encodeURIComponent(exportFileParameters_dateFrom ? "" + exportFileParameters_dateFrom.toISOString() : "") + "&";
        if (exportFileParameters_dateTo !== undefined && exportFileParameters_dateTo !== null)
            url_ += "exportFileParameters.dateTo=" + encodeURIComponent(exportFileParameters_dateTo ? "" + exportFileParameters_dateTo.toISOString() : "") + "&";
        if (exportFileParameters_leaveDateAsItIs !== undefined && exportFileParameters_leaveDateAsItIs !== null)
            url_ += "exportFileParameters.leaveDateAsItIs=" + encodeURIComponent("" + exportFileParameters_leaveDateAsItIs) + "&";
        if (exportFileParameters_placesIds !== undefined && exportFileParameters_placesIds !== null)
            exportFileParameters_placesIds && exportFileParameters_placesIds.forEach(item => { url_ += "exportFileParameters.placesIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportFileParameters_profilesIds !== undefined && exportFileParameters_profilesIds !== null)
            exportFileParameters_profilesIds && exportFileParameters_profilesIds.forEach(item => { url_ += "exportFileParameters.profilesIds=" + encodeURIComponent("" + item) + "&"; });
        if (exportFileParameters_internetAveExportType !== undefined && exportFileParameters_internetAveExportType !== null)
            url_ += "exportFileParameters.internetAveExportType=" + encodeURIComponent("" + exportFileParameters_internetAveExportType) + "&";
        if (exportFileParameters_exportType !== undefined && exportFileParameters_exportType !== null)
            url_ += "exportFileParameters.exportType=" + encodeURIComponent("" + exportFileParameters_exportType) + "&";
        if (exportFileParameters_truncateData !== undefined && exportFileParameters_truncateData !== null)
            url_ += "exportFileParameters.truncateData=" + encodeURIComponent("" + exportFileParameters_truncateData) + "&";
        if (exportFileParameters_withDaylightSavingTime !== undefined && exportFileParameters_withDaylightSavingTime !== null)
            url_ += "exportFileParameters.withDaylightSavingTime=" + encodeURIComponent("" + exportFileParameters_withDaylightSavingTime) + "&";
        if (exportFileParameters_templateFile_fileName !== undefined && exportFileParameters_templateFile_fileName !== null)
            url_ += "exportFileParameters.templateFile.fileName=" + encodeURIComponent("" + exportFileParameters_templateFile_fileName) + "&";
        if (exportFileParameters_templateFile_contentBase64 !== undefined && exportFileParameters_templateFile_contentBase64 !== null)
            url_ += "exportFileParameters.templateFile.contentBase64=" + encodeURIComponent("" + exportFileParameters_templateFile_contentBase64) + "&";
        if (exportFileParameters_deviceGroupName !== undefined && exportFileParameters_deviceGroupName !== null)
            url_ += "exportFileParameters.deviceGroupName=" + encodeURIComponent("" + exportFileParameters_deviceGroupName) + "&";
        if (exportFileParameters_clientOutputFileName !== undefined && exportFileParameters_clientOutputFileName !== null)
            url_ += "exportFileParameters.clientOutputFileName=" + encodeURIComponent("" + exportFileParameters_clientOutputFileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFile(_response);
        });
    }

    protected processGetExportFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return List of Export types
     */
    getExportTypes( cancelToken?: CancelToken | undefined): Promise<DataExportType> {
        let url_ = this.baseUrl + "/v1/data/export/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportTypes(_response);
        });
    }

    protected processGetExportTypes(response: AxiosResponse): Promise<DataExportType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataExportType.fromJS(resultData200);
            return Promise.resolve<DataExportType>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataExportType>(null as any);
    }

    /**
     * @return List of Export templates
     */
    getExportTemplates( cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/data/export/templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportTemplates(_response);
        });
    }

    protected processGetExportTemplates(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export interface IDataPumpsClient {
    /**
     * @return Get DataPumpSettings
     */
    getDataPumpSettings(dataPumpGuid: string): Promise<string>;
    /**
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get DataPumps
     */
    getDataPumps(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<DataPumpLite[]>;
    /**
     * @return Get statistics chart data for DataPump with GUID
     */
    getDataPumpStatisticsChartData(dataPumpGuid: string, dataRange: number, chartType: number): Promise<ChartData1>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get DataPumpProfiles
     */
    getDataPumpProfiles(dataPumpIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<ProfilePage>;
    /**
     * @param briefSummary (optional) 
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get summary for DataPump with GUID
     */
    getDataPumpSummary(dataPumpGuid: string, dateFrom: Date, dateTo: Date, briefSummary: boolean | null | undefined, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<DataPumpSummary>;
}

export class DataPumpsClient implements IDataPumpsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get DataPumpSettings
     */
    getDataPumpSettings(dataPumpGuid: string, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/data/pumps/{dataPumpGuid}/settings";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpSettings(_response);
        });
    }

    protected processGetDataPumpSettings(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get DataPumps
     */
    getDataPumps(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DataPumpLite[]> {
        let url_ = this.baseUrl + "/v1/data/pumps?";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumps(_response);
        });
    }

    protected processGetDataPumps(response: AxiosResponse): Promise<DataPumpLite[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataPumpLite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DataPumpLite[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataPumpLite[]>(null as any);
    }

    /**
     * @return Get statistics chart data for DataPump with GUID
     */
    getDataPumpStatisticsChartData(dataPumpGuid: string, dataRange: number, chartType: number, cancelToken?: CancelToken | undefined): Promise<ChartData1> {
        let url_ = this.baseUrl + "/v1/data/pumps/{dataPumpGuid}/statistics/chart-data?";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        if (chartType === undefined || chartType === null)
            throw new Error("The parameter 'chartType' must be defined and cannot be null.");
        else
            url_ += "chartType=" + encodeURIComponent("" + chartType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpStatisticsChartData(_response);
        });
    }

    protected processGetDataPumpStatisticsChartData(response: AxiosResponse): Promise<ChartData1> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChartData1.fromJS(resultData200);
            return Promise.resolve<ChartData1>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData1>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get DataPumpProfiles
     */
    getDataPumpProfiles(dataPumpIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/v1/data/pumps/profiles?";
        if (dataPumpIds === undefined || dataPumpIds === null)
            throw new Error("The parameter 'dataPumpIds' must be defined and cannot be null.");
        else
            dataPumpIds && dataPumpIds.forEach(item => { url_ += "dataPumpIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpProfiles(_response);
        });
    }

    protected processGetDataPumpProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }

    /**
     * @param briefSummary (optional) 
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get summary for DataPump with GUID
     */
    getDataPumpSummary(dataPumpGuid: string, dateFrom: Date, dateTo: Date, briefSummary: boolean | null | undefined, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DataPumpSummary> {
        let url_ = this.baseUrl + "/v1/data/pumps/{dataPumpGuid}/summary?";
        if (dataPumpGuid === undefined || dataPumpGuid === null)
            throw new Error("The parameter 'dataPumpGuid' must be defined.");
        url_ = url_.replace("{dataPumpGuid}", encodeURIComponent("" + dataPumpGuid));
        if (dateFrom === undefined || dateFrom === null)
            throw new Error("The parameter 'dateFrom' must be defined and cannot be null.");
        else
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined || dateTo === null)
            throw new Error("The parameter 'dateTo' must be defined and cannot be null.");
        else
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        if (briefSummary !== undefined && briefSummary !== null)
            url_ += "briefSummary=" + encodeURIComponent("" + briefSummary) + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDataPumpSummary(_response);
        });
    }

    protected processGetDataPumpSummary(response: AxiosResponse): Promise<DataPumpSummary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DataPumpSummary.fromJS(resultData200);
            return Promise.resolve<DataPumpSummary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DataPumpSummary>(null as any);
    }
}

export interface IDataStorageClient {
    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get Device data
     */
    getDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined): Promise<SerializableDataTableContainer>;
    /**
     * @return Save Device data
     */
    saveDeviceData(placeId: number, rows: string): Promise<void>;
    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get Device chart data
     */
    getDeviceChartData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined): Promise<DeviceChartData>;
    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get AveDroid Device data
     */
    getAveDroidDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined): Promise<AveDroidDeviceData>;
    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get MiniWebClient Device chart data
     */
    getMiniWebClientDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined): Promise<MiniWebClientDeviceData>;
}

export class DataStorageClient implements IDataStorageClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get Device data
     */
    getDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SerializableDataTableContainer> {
        let url_ = this.baseUrl + "/v1/data/storage/{placeId}?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceData(_response);
        });
    }

    protected processGetDeviceData(response: AxiosResponse): Promise<SerializableDataTableContainer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SerializableDataTableContainer.fromJS(resultData200);
            return Promise.resolve<SerializableDataTableContainer>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SerializableDataTableContainer>(null as any);
    }

    /**
     * @return Save Device data
     */
    saveDeviceData(placeId: number, rows: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/data/storage/{placeId}?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (rows === undefined || rows === null)
            throw new Error("The parameter 'rows' must be defined and cannot be null.");
        else
            url_ += "rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveDeviceData(_response);
        });
    }

    protected processSaveDeviceData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get Device chart data
     */
    getDeviceChartData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<DeviceChartData> {
        let url_ = this.baseUrl + "/v1/data/storage/{placeId}/chart?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceChartData(_response);
        });
    }

    protected processGetDeviceChartData(response: AxiosResponse): Promise<DeviceChartData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceChartData.fromJS(resultData200);
            return Promise.resolve<DeviceChartData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceChartData>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get AveDroid Device data
     */
    getAveDroidDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<AveDroidDeviceData> {
        let url_ = this.baseUrl + "/v1/data/storage/{placeId}/ave-droid?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAveDroidDeviceData(_response);
        });
    }

    protected processGetAveDroidDeviceData(response: AxiosResponse): Promise<AveDroidDeviceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AveDroidDeviceData.fromJS(resultData200);
            return Promise.resolve<AveDroidDeviceData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AveDroidDeviceData>(null as any);
    }

    /**
     * @param parameters_fieldNames (optional) 
     * @param parameters_dateFrom (optional) 
     * @param parameters_dateTo (optional) 
     * @param parameters_dataType (optional) 
     * @param parameters_truncateData (optional) 
     * @param parameters_withDaylightSavingTime (optional) 
     * @param parameters_timeFormat (optional) 
     * @param parameters_cultureName (optional) 
     * @param parameters_line (optional) 
     * @param parameters_group (optional) 
     * @return Get MiniWebClient Device chart data
     */
    getMiniWebClientDeviceData(placeId: number, parameters_fieldNames: string[] | null | undefined, parameters_dateFrom: Date | null | undefined, parameters_dateTo: Date | null | undefined, parameters_dataType: number | null | undefined, parameters_truncateData: boolean | null | undefined, parameters_withDaylightSavingTime: boolean | null | undefined, parameters_timeFormat: string | null | undefined, parameters_cultureName: string | null | undefined, parameters_line: string | null | undefined, parameters_group: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<MiniWebClientDeviceData> {
        let url_ = this.baseUrl + "/v1/data/storage/{placeId}/mini-web-client?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        if (parameters_fieldNames !== undefined && parameters_fieldNames !== null)
            parameters_fieldNames && parameters_fieldNames.forEach(item => { url_ += "parameters.fieldNames=" + encodeURIComponent("" + item) + "&"; });
        if (parameters_dateFrom !== undefined && parameters_dateFrom !== null)
            url_ += "parameters.dateFrom=" + encodeURIComponent(parameters_dateFrom ? "" + parameters_dateFrom.toISOString() : "") + "&";
        if (parameters_dateTo !== undefined && parameters_dateTo !== null)
            url_ += "parameters.dateTo=" + encodeURIComponent(parameters_dateTo ? "" + parameters_dateTo.toISOString() : "") + "&";
        if (parameters_dataType !== undefined && parameters_dataType !== null)
            url_ += "parameters.dataType=" + encodeURIComponent("" + parameters_dataType) + "&";
        if (parameters_truncateData !== undefined && parameters_truncateData !== null)
            url_ += "parameters.truncateData=" + encodeURIComponent("" + parameters_truncateData) + "&";
        if (parameters_withDaylightSavingTime !== undefined && parameters_withDaylightSavingTime !== null)
            url_ += "parameters.withDaylightSavingTime=" + encodeURIComponent("" + parameters_withDaylightSavingTime) + "&";
        if (parameters_timeFormat !== undefined && parameters_timeFormat !== null)
            url_ += "parameters.timeFormat=" + encodeURIComponent("" + parameters_timeFormat) + "&";
        if (parameters_cultureName !== undefined && parameters_cultureName !== null)
            url_ += "parameters.cultureName=" + encodeURIComponent("" + parameters_cultureName) + "&";
        if (parameters_line !== undefined && parameters_line !== null)
            url_ += "parameters.line=" + encodeURIComponent("" + parameters_line) + "&";
        if (parameters_group !== undefined && parameters_group !== null)
            url_ += "parameters.group=" + encodeURIComponent("" + parameters_group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMiniWebClientDeviceData(_response);
        });
    }

    protected processGetMiniWebClientDeviceData(response: AxiosResponse): Promise<MiniWebClientDeviceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MiniWebClientDeviceData.fromJS(resultData200);
            return Promise.resolve<MiniWebClientDeviceData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MiniWebClientDeviceData>(null as any);
    }
}

export interface IDealersClient {
    /**
     * @return Get dealers
     */
    getDealers(): Promise<Dealer[]>;
}

export class DealersClient implements IDealersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get dealers
     */
    getDealers( cancelToken?: CancelToken | undefined): Promise<Dealer[]> {
        let url_ = this.baseUrl + "/v1/dealers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDealers(_response);
        });
    }

    protected processGetDealers(response: AxiosResponse): Promise<Dealer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dealer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Dealer[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Dealer[]>(null as any);
    }
}

export interface IDeviceDriversClient {
    /**
     * @return Get list of driver communication channels for server
     */
    getDriverCommunicationChannels(serverId: number): Promise<DriverCommunicationChannel[]>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @return Get driver logs
     */
    getDriverLogs(serverId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined): Promise<CallLogsPage>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @return Get driver communication channel logs
     */
    getCommunicationChannelLogs(serverId: number, channelGuid: string, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined): Promise<CallLogsPage>;
}

export class DeviceDriversClient implements IDeviceDriversClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get list of driver communication channels for server
     */
    getDriverCommunicationChannels(serverId: number, cancelToken?: CancelToken | undefined): Promise<DriverCommunicationChannel[]> {
        let url_ = this.baseUrl + "/v1/devices/drivers/{serverId}/channels";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDriverCommunicationChannels(_response);
        });
    }

    protected processGetDriverCommunicationChannels(response: AxiosResponse): Promise<DriverCommunicationChannel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DriverCommunicationChannel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DriverCommunicationChannel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DriverCommunicationChannel[]>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @return Get driver logs
     */
    getDriverLogs(serverId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallLogsPage> {
        let url_ = this.baseUrl + "/v1/devices/drivers/{serverId}/logs?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDriverLogs(_response);
        });
    }

    protected processGetDriverLogs(response: AxiosResponse): Promise<CallLogsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogsPage.fromJS(resultData200);
            return Promise.resolve<CallLogsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogsPage>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @return Get driver communication channel logs
     */
    getCommunicationChannelLogs(serverId: number, channelGuid: string, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, cancelToken?: CancelToken | undefined): Promise<CallLogsPage> {
        let url_ = this.baseUrl + "/v1/devices/drivers/{serverId}/channels/{channelGuid}/logs?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (channelGuid === undefined || channelGuid === null)
            throw new Error("The parameter 'channelGuid' must be defined.");
        url_ = url_.replace("{channelGuid}", encodeURIComponent("" + channelGuid));
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommunicationChannelLogs(_response);
        });
    }

    protected processGetCommunicationChannelLogs(response: AxiosResponse): Promise<CallLogsPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CallLogsPage.fromJS(resultData200);
            return Promise.resolve<CallLogsPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CallLogsPage>(null as any);
    }
}

export interface IDevicesClient {
    /**
     * @return List of device tag groups
     */
    getTagGroups(): Promise<string[]>;
    /**
     * @return List of device tags
     */
    getTags(placeId: number): Promise<DeviceTagItem[]>;
    /**
     * @return List of device alarms
     */
    getAlarms(placeId: number): Promise<DeviceAlarmItem[]>;
    /**
     * @return List of connection types
     */
    getConnectionTypes(): Promise<ConnectionType[]>;
    /**
     * @return List of device parameters
     */
    getDeviceParameters(placeId: number): Promise<DeviceParameters>;
    /**
     * @return List of battery info
     */
    getBatteryStatus(placeId: number): Promise<BatteryStatus>;
    /**
     * @return List of device reading info
     */
    getLastReadingInfo(placeId: number): Promise<LastReadingInfo>;
    /**
     * @return List of time windows
     */
    getTimeWindows(placeId: number): Promise<TimeWindows>;
    /**
     * @return List of device runtime parameters
     */
    getDeviceRuntimeParameters(placeId: number): Promise<DeviceRuntimeParameters>;
    /**
     * @return List of device reading parameters
     */
    getReadingParameters(placeId: number): Promise<ReadingParameters>;
    /**
     * @return List of device runtime parameters as xlsx file
     */
    getDeviceRuntimeParametersXlsx(placeId: number): Promise<DeviceRuntimeParameters>;
    /**
     * @return Device gas composition
     */
    getGasComposition(placeId: number): Promise<GasComposition>;
}

export class DevicesClient implements IDevicesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return List of device tag groups
     */
    getTagGroups( cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/v1/devices/tags/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTagGroups(_response);
        });
    }

    protected processGetTagGroups(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return List of device tags
     */
    getTags(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceTagItem[]> {
        let url_ = this.baseUrl + "/v1/devices/tags/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTags(_response);
        });
    }

    protected processGetTags(response: AxiosResponse): Promise<DeviceTagItem[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceTagItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceTagItem[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceTagItem[]>(null as any);
    }

    /**
     * @return List of device alarms
     */
    getAlarms(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceAlarmItem[]> {
        let url_ = this.baseUrl + "/v1/devices/alarms/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAlarms(_response);
        });
    }

    protected processGetAlarms(response: AxiosResponse): Promise<DeviceAlarmItem[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceAlarmItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceAlarmItem[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceAlarmItem[]>(null as any);
    }

    /**
     * @return List of connection types
     */
    getConnectionTypes( cancelToken?: CancelToken | undefined): Promise<ConnectionType[]> {
        let url_ = this.baseUrl + "/v1/devices/connection/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectionTypes(_response);
        });
    }

    protected processGetConnectionTypes(response: AxiosResponse): Promise<ConnectionType[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConnectionType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ConnectionType[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectionType[]>(null as any);
    }

    /**
     * @return List of device parameters
     */
    getDeviceParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceParameters> {
        let url_ = this.baseUrl + "/v1/devices/params/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceParameters(_response);
        });
    }

    protected processGetDeviceParameters(response: AxiosResponse): Promise<DeviceParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceParameters.fromJS(resultData200);
            return Promise.resolve<DeviceParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceParameters>(null as any);
    }

    /**
     * @return List of battery info
     */
    getBatteryStatus(placeId: number, cancelToken?: CancelToken | undefined): Promise<BatteryStatus> {
        let url_ = this.baseUrl + "/v1/devices/battery/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetBatteryStatus(_response);
        });
    }

    protected processGetBatteryStatus(response: AxiosResponse): Promise<BatteryStatus> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BatteryStatus.fromJS(resultData200);
            return Promise.resolve<BatteryStatus>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BatteryStatus>(null as any);
    }

    /**
     * @return List of device reading info
     */
    getLastReadingInfo(placeId: number, cancelToken?: CancelToken | undefined): Promise<LastReadingInfo> {
        let url_ = this.baseUrl + "/v1/devices/reading/info/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLastReadingInfo(_response);
        });
    }

    protected processGetLastReadingInfo(response: AxiosResponse): Promise<LastReadingInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LastReadingInfo.fromJS(resultData200);
            return Promise.resolve<LastReadingInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LastReadingInfo>(null as any);
    }

    /**
     * @return List of time windows
     */
    getTimeWindows(placeId: number, cancelToken?: CancelToken | undefined): Promise<TimeWindows> {
        let url_ = this.baseUrl + "/v1/devices/time_windows/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTimeWindows(_response);
        });
    }

    protected processGetTimeWindows(response: AxiosResponse): Promise<TimeWindows> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeWindows.fromJS(resultData200);
            return Promise.resolve<TimeWindows>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeWindows>(null as any);
    }

    /**
     * @return List of device runtime parameters
     */
    getDeviceRuntimeParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceRuntimeParameters> {
        let url_ = this.baseUrl + "/v1/devices/params/runtime/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceRuntimeParameters(_response);
        });
    }

    protected processGetDeviceRuntimeParameters(response: AxiosResponse): Promise<DeviceRuntimeParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceRuntimeParameters.fromJS(resultData200);
            return Promise.resolve<DeviceRuntimeParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceRuntimeParameters>(null as any);
    }

    /**
     * @return List of device reading parameters
     */
    getReadingParameters(placeId: number, cancelToken?: CancelToken | undefined): Promise<ReadingParameters> {
        let url_ = this.baseUrl + "/v1/devices/reading/params/{placeId}";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReadingParameters(_response);
        });
    }

    protected processGetReadingParameters(response: AxiosResponse): Promise<ReadingParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReadingParameters.fromJS(resultData200);
            return Promise.resolve<ReadingParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReadingParameters>(null as any);
    }

    /**
     * @return List of device runtime parameters as xlsx file
     */
    getDeviceRuntimeParametersXlsx(placeId: number, cancelToken?: CancelToken | undefined): Promise<DeviceRuntimeParameters> {
        let url_ = this.baseUrl + "/v1/devices/params/runtime/{placeId}/xlsx";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeviceRuntimeParametersXlsx(_response);
        });
    }

    protected processGetDeviceRuntimeParametersXlsx(response: AxiosResponse): Promise<DeviceRuntimeParameters> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceRuntimeParameters.fromJS(resultData200);
            return Promise.resolve<DeviceRuntimeParameters>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceRuntimeParameters>(null as any);
    }

    /**
     * @return Device gas composition
     */
    getGasComposition(placeId: number, cancelToken?: CancelToken | undefined): Promise<GasComposition> {
        let url_ = this.baseUrl + "/v1/devices/gas/composition?";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined and cannot be null.");
        else
            url_ += "placeId=" + encodeURIComponent("" + placeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGasComposition(_response);
        });
    }

    protected processGetGasComposition(response: AxiosResponse): Promise<GasComposition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GasComposition.fromJS(resultData200);
            return Promise.resolve<GasComposition>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GasComposition>(null as any);
    }
}

export interface IDiagnosticsClient {
    /**
     * @return Get servers info
     */
    getServerInfos(): Promise<ServerInfos>;
    /**
     * @return Get server monitoring data
     */
    getServerMonitoringItems(serverId: number, dataRange: DataRange): Promise<ServerMonitoringItems>;
    /**
     * @return Get server monitoring chart data
     */
    getServerMonitoringChartData(serverId: number, dataRange: DataRange2): Promise<ChartData_1[]>;
}

export class DiagnosticsClient implements IDiagnosticsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get servers info
     */
    getServerInfos( cancelToken?: CancelToken | undefined): Promise<ServerInfos> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerInfos(_response);
        });
    }

    protected processGetServerInfos(response: AxiosResponse): Promise<ServerInfos> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerInfos.fromJS(resultData200);
            return Promise.resolve<ServerInfos>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerInfos>(null as any);
    }

    /**
     * @return Get server monitoring data
     */
    getServerMonitoringItems(serverId: number, dataRange: DataRange, cancelToken?: CancelToken | undefined): Promise<ServerMonitoringItems> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/{serverId}/monitoring?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerMonitoringItems(_response);
        });
    }

    protected processGetServerMonitoringItems(response: AxiosResponse): Promise<ServerMonitoringItems> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerMonitoringItems.fromJS(resultData200);
            return Promise.resolve<ServerMonitoringItems>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerMonitoringItems>(null as any);
    }

    /**
     * @return Get server monitoring chart data
     */
    getServerMonitoringChartData(serverId: number, dataRange: DataRange2, cancelToken?: CancelToken | undefined): Promise<ChartData_1[]> {
        let url_ = this.baseUrl + "/v1/diagnostics/servers/{serverId}/monitoring/chart-data?";
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        if (dataRange === undefined || dataRange === null)
            throw new Error("The parameter 'dataRange' must be defined and cannot be null.");
        else
            url_ += "dataRange=" + encodeURIComponent("" + dataRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerMonitoringChartData(_response);
        });
    }

    protected processGetServerMonitoringChartData(response: AxiosResponse): Promise<ChartData_1[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChartData_1.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ChartData_1[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChartData_1[]>(null as any);
    }
}

export interface IExportsClient {
    /**
     * @return Export file
     */
    getExportFile(exportSchedulerId: number, fileName: string): Promise<void>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of export schedulers
     */
    getExportSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<Page_1>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of export files
     */
    getExportFiles(exportSchedulerId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<Page_11>;
    /**
     * @return Export scheduler run successfully
     */
    runExportScheduler(exportSchedulerId: number): Promise<void>;
}

export class ExportsClient implements IExportsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Export file
     */
    getExportFile(exportSchedulerId: number, fileName: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/export/{exportSchedulerId}/files/{fileName}";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFile(_response);
        });
    }

    protected processGetExportFile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of export schedulers
     */
    getExportSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<Page_1> {
        let url_ = this.baseUrl + "/v1/export?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportSchedulers(_response);
        });
    }

    protected processGetExportSchedulers(response: AxiosResponse): Promise<Page_1> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Page_1.fromJS(resultData200);
            return Promise.resolve<Page_1>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Page_1>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of export files
     */
    getExportFiles(exportSchedulerId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<Page_11> {
        let url_ = this.baseUrl + "/v1/export/{exportSchedulerId}/files?";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExportFiles(_response);
        });
    }

    protected processGetExportFiles(response: AxiosResponse): Promise<Page_11> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Page_11.fromJS(resultData200);
            return Promise.resolve<Page_11>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Page_11>(null as any);
    }

    /**
     * @return Export scheduler run successfully
     */
    runExportScheduler(exportSchedulerId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/export/{exportSchedulerId}/run";
        if (exportSchedulerId === undefined || exportSchedulerId === null)
            throw new Error("The parameter 'exportSchedulerId' must be defined.");
        url_ = url_.replace("{exportSchedulerId}", encodeURIComponent("" + exportSchedulerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRunExportScheduler(_response);
        });
    }

    protected processRunExportScheduler(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IKeyValueStoreClient {
    /**
     * @return Get Key-Value collection
     */
    getKeyValueCollection(collection: string): Promise<KeyValueCommandResponse>;
    /**
     * @return Get Key-Value pair
     */
    getKeyValue(collection: string, key: string): Promise<KeyValuePair_2>;
}

export class KeyValueStoreClient implements IKeyValueStoreClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Get Key-Value collection
     */
    getKeyValueCollection(collection: string, cancelToken?: CancelToken | undefined): Promise<KeyValueCommandResponse> {
        let url_ = this.baseUrl + "/v1/key-value-store/{collection}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetKeyValueCollection(_response);
        });
    }

    protected processGetKeyValueCollection(response: AxiosResponse): Promise<KeyValueCommandResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyValueCommandResponse.fromJS(resultData200);
            return Promise.resolve<KeyValueCommandResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Key-Value collection does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyValueCommandResponse>(null as any);
    }

    /**
     * @return Get Key-Value pair
     */
    getKeyValue(collection: string, key: string, cancelToken?: CancelToken | undefined): Promise<KeyValuePair_2> {
        let url_ = this.baseUrl + "/v1/key-value-store/{collection}/{key}";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined.");
        url_ = url_.replace("{collection}", encodeURIComponent("" + collection));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetKeyValue(_response);
        });
    }

    protected processGetKeyValue(response: AxiosResponse): Promise<KeyValuePair_2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = KeyValuePair_2.fromJS(resultData200);
            return Promise.resolve<KeyValuePair_2>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException("Key-Value pair does not exist", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<KeyValuePair_2>(null as any);
    }
}

export interface IPlacesClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of places
     */
    getPlaces(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<PlacePage>;
    /**
     * @return Place Data deleted
     */
    deletePlaceData(placeId: number, timestamps: Date[]): Promise<void>;
}

export class PlacesClient implements IPlacesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Page of places
     */
    getPlaces(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/v1/places?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPlaces(_response);
        });
    }

    protected processGetPlaces(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }

    /**
     * @return Place Data deleted
     */
    deletePlaceData(placeId: number, timestamps: Date[], cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/places/{placeId}/data";
        if (placeId === undefined || placeId === null)
            throw new Error("The parameter 'placeId' must be defined.");
        url_ = url_.replace("{placeId}", encodeURIComponent("" + placeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(timestamps);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletePlaceData(_response);
        });
    }

    protected processDeletePlaceData(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IProfilesClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get profiles paged
     */
    getProfiles(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<ProfilePage>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get profile places paged
     */
    getProfilePlaces(profileId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<PlacePage>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get places for multiple profiles paged
     */
    getProfilePlaces2(profileIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<PlacePage>;
}

export class ProfilesClient implements IProfilesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get profiles paged
     */
    getProfiles(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/v1/profiles?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfiles(_response);
        });
    }

    protected processGetProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get profile places paged
     */
    getProfilePlaces(profileId: number, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/v1/profiles/{profileId}/places?";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfilePlaces(_response);
        });
    }

    protected processGetProfilePlaces(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get places for multiple profiles paged
     */
    getProfilePlaces2(profileIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<PlacePage> {
        let url_ = this.baseUrl + "/v1/profiles/places?";
        if (profileIds === undefined || profileIds === null)
            throw new Error("The parameter 'profileIds' must be defined and cannot be null.");
        else
            profileIds && profileIds.forEach(item => { url_ += "profileIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProfilePlaces2(_response);
        });
    }

    protected processGetProfilePlaces2(response: AxiosResponse): Promise<PlacePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlacePage.fromJS(resultData200);
            return Promise.resolve<PlacePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlacePage>(null as any);
    }
}

export interface IReadingClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get reading requests paged
     */
    getReadingRequests(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<ReadRequestPage>;
}

export class ReadingClient implements IReadingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get reading requests paged
     */
    getReadingRequests(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ReadRequestPage> {
        let url_ = this.baseUrl + "/v1/read/requests?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetReadingRequests(_response);
        });
    }

    protected processGetReadingRequests(response: AxiosResponse): Promise<ReadRequestPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReadRequestPage.fromJS(resultData200);
            return Promise.resolve<ReadRequestPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReadRequestPage>(null as any);
    }
}

export interface ISchedulersClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get schedulers
     */
    getSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<SchedulerPage>;
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get schedulers profiles
     */
    getSchedulerProfiles(schedulerIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<ProfilePage>;
}

export class SchedulersClient implements ISchedulersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get schedulers
     */
    getSchedulers(start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SchedulerPage> {
        let url_ = this.baseUrl + "/v1/schedulers?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchedulers(_response);
        });
    }

    protected processGetSchedulers(response: AxiosResponse): Promise<SchedulerPage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SchedulerPage.fromJS(resultData200);
            return Promise.resolve<SchedulerPage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SchedulerPage>(null as any);
    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Get schedulers profiles
     */
    getSchedulerProfiles(schedulerIds: number[], start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ProfilePage> {
        let url_ = this.baseUrl + "/v1/schedulers/profiles?";
        if (schedulerIds === undefined || schedulerIds === null)
            throw new Error("The parameter 'schedulerIds' must be defined and cannot be null.");
        else
            schedulerIds && schedulerIds.forEach(item => { url_ += "schedulerIds=" + encodeURIComponent("" + item) + "&"; });
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSchedulerProfiles(_response);
        });
    }

    protected processGetSchedulerProfiles(response: AxiosResponse): Promise<ProfilePage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfilePage.fromJS(resultData200);
            return Promise.resolve<ProfilePage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfilePage>(null as any);
    }
}

export interface ISystemClient {
    /**
     * @return Returns system info
     */
    getSystemInfo(): Promise<SystemInfo>;
    /**
     * @return Returns pong
     */
    ping(): Promise<string>;
    /**
     * @return Returns regions
     */
    getRegions(): Promise<ServerRegion[]>;
    /**
     * @return Returns server version
     */
    getServerVersion(): Promise<ServerVersion>;
    /**
     * @return Returns server time
     */
    getServerTime(): Promise<ServerTime>;
    /**
     * @return Returns echo
     */
    echo(echo: string): Promise<string>;
}

export class SystemClient implements ISystemClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @return Returns system info
     */
    getSystemInfo( cancelToken?: CancelToken | undefined): Promise<SystemInfo> {
        let url_ = this.baseUrl + "/v1/system/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemInfo(_response);
        });
    }

    protected processGetSystemInfo(response: AxiosResponse): Promise<SystemInfo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SystemInfo.fromJS(resultData200);
            return Promise.resolve<SystemInfo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemInfo>(null as any);
    }

    /**
     * @return Returns pong
     */
    ping( cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/system/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPing(_response);
        });
    }

    protected processPing(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Returns regions
     */
    getRegions( cancelToken?: CancelToken | undefined): Promise<ServerRegion[]> {
        let url_ = this.baseUrl + "/v1/system/regions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegions(_response);
        });
    }

    protected processGetRegions(response: AxiosResponse): Promise<ServerRegion[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerRegion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerRegion[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerRegion[]>(null as any);
    }

    /**
     * @return Returns server version
     */
    getServerVersion( cancelToken?: CancelToken | undefined): Promise<ServerVersion> {
        let url_ = this.baseUrl + "/v1/system/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerVersion(_response);
        });
    }

    protected processGetServerVersion(response: AxiosResponse): Promise<ServerVersion> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerVersion.fromJS(resultData200);
            return Promise.resolve<ServerVersion>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerVersion>(null as any);
    }

    /**
     * @return Returns server time
     */
    getServerTime( cancelToken?: CancelToken | undefined): Promise<ServerTime> {
        let url_ = this.baseUrl + "/v1/system/server-time";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerTime(_response);
        });
    }

    protected processGetServerTime(response: AxiosResponse): Promise<ServerTime> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerTime.fromJS(resultData200);
            return Promise.resolve<ServerTime>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerTime>(null as any);
    }

    /**
     * @return Returns echo
     */
    echo(echo: string, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/v1/system/echo?";
        if (echo === undefined || echo === null)
            throw new Error("The parameter 'echo' must be defined and cannot be null.");
        else
            url_ += "echo=" + encodeURIComponent("" + echo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEcho(_response);
        });
    }

    protected processEcho(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface ISystemEventsClient {
    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Returns system events
     */
    getSystemEvents(eventType: number, eventId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<SystemEventPage[]>;
}

export class SystemEventsClient implements ISystemEventsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param start (optional) 
     * @param limit (optional) 
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Returns system events
     */
    getSystemEvents(eventType: number, eventId: number, from: Date, to: Date, start: number | null | undefined, limit: number | null | undefined, sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<SystemEventPage[]> {
        let url_ = this.baseUrl + "/v1/system/events?";
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined and cannot be null.");
        else
            url_ += "eventType=" + encodeURIComponent("" + eventType) + "&";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined and cannot be null.");
        else
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSystemEvents(_response);
        });
    }

    protected processGetSystemEvents(response: AxiosResponse): Promise<SystemEventPage[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SystemEventPage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SystemEventPage[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SystemEventPage[]>(null as any);
    }
}

export interface IUsersClient {
    /**
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Connected users
     */
    getConnectedUsers(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined): Promise<ConnectedUserLite[]>;
}

export class UsersClient implements IUsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ave-system.com/api";

    }

    /**
     * @param sort (optional) 
     * @param direction (optional) 
     * @param filter (optional) 
     * @return Connected users
     */
    getConnectedUsers(sort: string | null | undefined, direction: string | null | undefined, filter: string | null | undefined, cancelToken?: CancelToken | undefined): Promise<ConnectedUserLite[]> {
        let url_ = this.baseUrl + "/v1/users/connected?";
        if (sort !== undefined && sort !== null)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (direction !== undefined && direction !== null)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetConnectedUsers(_response);
        });
    }

    protected processGetConnectedUsers(response: AxiosResponse): Promise<ConnectedUserLite[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConnectedUserLite.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ConnectedUserLite[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConnectedUserLite[]>(null as any);
    }
}

export class ActualValues implements IActualValues {
    items?: ActualValue[] | undefined;
    count?: number | undefined;

    constructor(data?: IActualValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActualValue.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ActualValues {
        data = typeof data === 'object' ? data : {};
        let result = new ActualValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IActualValues {
    items?: ActualValue[] | undefined;
    count?: number | undefined;
}

export class ActualValue implements IActualValue {
    placeId?: number | undefined;
    mark?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    units?: string | undefined;
    state?: string | undefined;
    status?: string | undefined;
    address?: number | undefined;
    tagName?: string | undefined;
    tagFieldName?: string | undefined;
    tagDescription?: string | undefined;
    addressEx?: string | undefined;
    tagGroupName?: string | undefined;
    tagHasBindingToAlarm?: boolean | undefined;
    alarmEntry?: AlarmEntry | undefined;
    readonly valueAsObject?: any | undefined;

    constructor(data?: IActualValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["placeId"];
            this.mark = _data["mark"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
            this.units = _data["units"];
            this.state = _data["state"];
            this.status = _data["status"];
            this.address = _data["address"];
            this.tagName = _data["tagName"];
            this.tagFieldName = _data["tagFieldName"];
            this.tagDescription = _data["tagDescription"];
            this.addressEx = _data["addressEx"];
            this.tagGroupName = _data["tagGroupName"];
            this.tagHasBindingToAlarm = _data["tagHasBindingToAlarm"];
            this.alarmEntry = _data["alarmEntry"] ? AlarmEntry.fromJS(_data["alarmEntry"]) : <any>undefined;
            (<any>this).valueAsObject = _data["valueAsObject"];
        }
    }

    static fromJS(data: any): ActualValue {
        data = typeof data === 'object' ? data : {};
        let result = new ActualValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeId"] = this.placeId;
        data["mark"] = this.mark;
        data["name"] = this.name;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        data["units"] = this.units;
        data["state"] = this.state;
        data["status"] = this.status;
        data["address"] = this.address;
        data["tagName"] = this.tagName;
        data["tagFieldName"] = this.tagFieldName;
        data["tagDescription"] = this.tagDescription;
        data["addressEx"] = this.addressEx;
        data["tagGroupName"] = this.tagGroupName;
        data["tagHasBindingToAlarm"] = this.tagHasBindingToAlarm;
        data["alarmEntry"] = this.alarmEntry ? this.alarmEntry.toJSON() : <any>undefined;
        data["valueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IActualValue {
    placeId?: number | undefined;
    mark?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    units?: string | undefined;
    state?: string | undefined;
    status?: string | undefined;
    address?: number | undefined;
    tagName?: string | undefined;
    tagFieldName?: string | undefined;
    tagDescription?: string | undefined;
    addressEx?: string | undefined;
    tagGroupName?: string | undefined;
    tagHasBindingToAlarm?: boolean | undefined;
    alarmEntry?: AlarmEntry | undefined;
    valueAsObject?: any | undefined;
}

export class AlarmEntry implements IAlarmEntry {
    guid?: string | undefined;
    timeGenerated?: Date | undefined;
    timeTerminated?: Date | undefined;
    timeWritten?: Date | undefined;
    timeAcknowledged?: Date | undefined;
    timeAnnotated?: Date | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
    itemId?: number | undefined;
    place?: ConsumptionPlace | undefined;
    readonly timeAnnotatedAsText?: string | undefined;
    readonly timeAcknowledgedAsText?: string | undefined;
    readonly timeTerminatedAsText?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: AlarmEntryObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IAlarmEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.timeGenerated = _data["timeGenerated"] ? new Date(_data["timeGenerated"].toString()) : <any>undefined;
            this.timeTerminated = _data["timeTerminated"] ? new Date(_data["timeTerminated"].toString()) : <any>undefined;
            this.timeWritten = _data["timeWritten"] ? new Date(_data["timeWritten"].toString()) : <any>undefined;
            this.timeAcknowledged = _data["timeAcknowledged"] ? new Date(_data["timeAcknowledged"].toString()) : <any>undefined;
            this.timeAnnotated = _data["timeAnnotated"] ? new Date(_data["timeAnnotated"].toString()) : <any>undefined;
            this.alarmID = _data["alarmID"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.acknowledgeUser = _data["acknowledgeUser"];
            this.annotationUser = _data["annotationUser"];
            this.device = _data["device"];
            this.tagName = _data["tagName"];
            this.tagValue = _data["tagValue"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.note = _data["note"];
            this.acknowledgementRequired = _data["acknowledgementRequired"];
            this.acknowledged = _data["acknowledged"];
            this.isActive = _data["isActive"];
            this.regionId = _data["regionId"];
            this.region = _data["region"];
            this.itemId = _data["itemId"];
            this.place = _data["place"] ? ConsumptionPlace.fromJS(_data["place"]) : <any>undefined;
            (<any>this).timeAnnotatedAsText = _data["timeAnnotatedAsText"];
            (<any>this).timeAcknowledgedAsText = _data["timeAcknowledgedAsText"];
            (<any>this).timeTerminatedAsText = _data["timeTerminatedAsText"];
            (<any>this).id = _data["id"];
            this.tag = _data["tag"];
            (<any>this).syncRoot = _data["syncRoot"];
            if (Array.isArray(_data["parent"])) {
                this.parent = [] as any;
                for (let item of _data["parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isDeleted = _data["isDeleted"];
            this.isEdited = _data["isEdited"];
            (<any>this).objectState = _data["objectState"];
            if (Array.isArray(_data["rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["isValid"];
            (<any>this).isInError = _data["isInError"];
            (<any>this).error = _data["error"];
            (<any>this).isDirtyHashCode = _data["isDirtyHashCode"];
        }
    }

    static fromJS(data: any): AlarmEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["timeGenerated"] = this.timeGenerated ? this.timeGenerated.toISOString() : <any>undefined;
        data["timeTerminated"] = this.timeTerminated ? this.timeTerminated.toISOString() : <any>undefined;
        data["timeWritten"] = this.timeWritten ? this.timeWritten.toISOString() : <any>undefined;
        data["timeAcknowledged"] = this.timeAcknowledged ? this.timeAcknowledged.toISOString() : <any>undefined;
        data["timeAnnotated"] = this.timeAnnotated ? this.timeAnnotated.toISOString() : <any>undefined;
        data["alarmID"] = this.alarmID;
        data["source"] = this.source;
        data["category"] = this.category;
        data["acknowledgeUser"] = this.acknowledgeUser;
        data["annotationUser"] = this.annotationUser;
        data["device"] = this.device;
        data["tagName"] = this.tagName;
        data["tagValue"] = this.tagValue;
        data["message"] = this.message;
        data["data"] = this.data;
        data["note"] = this.note;
        data["acknowledgementRequired"] = this.acknowledgementRequired;
        data["acknowledged"] = this.acknowledged;
        data["isActive"] = this.isActive;
        data["regionId"] = this.regionId;
        data["region"] = this.region;
        data["itemId"] = this.itemId;
        data["place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["timeAnnotatedAsText"] = this.timeAnnotatedAsText;
        data["timeAcknowledgedAsText"] = this.timeAcknowledgedAsText;
        data["timeTerminatedAsText"] = this.timeTerminatedAsText;
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["syncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["parent"] = [];
            for (let item of this.parent)
                data["parent"].push(item);
        }
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isDeleted"] = this.isDeleted;
        data["isEdited"] = this.isEdited;
        data["objectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        data["isInError"] = this.isInError;
        data["error"] = this.error;
        data["isDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IAlarmEntry {
    guid?: string | undefined;
    timeGenerated?: Date | undefined;
    timeTerminated?: Date | undefined;
    timeWritten?: Date | undefined;
    timeAcknowledged?: Date | undefined;
    timeAnnotated?: Date | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
    itemId?: number | undefined;
    place?: ConsumptionPlace | undefined;
    timeAnnotatedAsText?: string | undefined;
    timeAcknowledgedAsText?: string | undefined;
    timeTerminatedAsText?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: AlarmEntryObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class ConsumptionPlace implements IConsumptionPlace {
    readonly formatedPlaceNumber?: string | undefined;
    readonly descriptionWithId?: string | undefined;
    readonly description?: string | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    placeEic?: string | undefined;
    scadaId?: string | undefined;
    regionId?: number | undefined;
    placeId?: string | undefined;
    name?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    payerId?: string | undefined;
    payerName?: string | undefined;
    payerStreet?: string | undefined;
    payerCity?: string | undefined;
    payerZipCode?: string | undefined;
    payerIdentificationNumber?: string | undefined;
    contractNumber?: string | undefined;
    dealerIdentification?: string | undefined;
    purchaseCategory?: number | undefined;
    connectionMethod?: number | undefined;
    readingCategory?: number | undefined;
    consumptionTerminated?: boolean | undefined;
    automaticallyImported?: boolean | undefined;
    exportToCis?: boolean | undefined;
    useAlternativeValues?: boolean | undefined;
    created?: Date | undefined;
    modified?: Date | undefined;
    note?: string | undefined;
    group?: string | undefined;
    state?: number | undefined;
    lastDataTimestamp?: Date | undefined;
    lastReadingTimestamp?: Date | undefined;
    workPlace?: string | undefined;
    dataShardId?: number | undefined;
    annualConsumptionMonths?: number | undefined;
    annualConsumptionVolume?: number | undefined;
    annualConsumptionInMwh?: number | undefined;
    deviceSize?: string | undefined;
    validatedTill?: Date | undefined;
    readonly isDataValidated?: boolean | undefined;
    validatedBy?: string | undefined;
    readonly manuallyImported?: boolean | undefined;
    customer?: Customer | undefined;
    validationNote?: string | undefined;
    parentPlaceGuid?: string | undefined;
    payerNote?: string | undefined;
    string1?: string | undefined;
    string2?: string | undefined;
    int1?: number | undefined;
    int2?: number | undefined;
    extendedProperties?: ExtendedProperty[] | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    device?: BaseDevice | undefined;
    readonly deviceSerialNumber?: string | undefined;
    readonly dataTableName?: string | undefined;
    readonly lastReadingTimestampDescription?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: ConsumptionPlaceObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IConsumptionPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).formatedPlaceNumber = _data["formatedPlaceNumber"];
            (<any>this).descriptionWithId = _data["descriptionWithId"];
            (<any>this).description = _data["description"];
            this.itemId = _data["itemId"];
            this.guid = _data["guid"];
            this.placeEic = _data["placeEic"];
            this.scadaId = _data["scadaId"];
            this.regionId = _data["regionId"];
            this.placeId = _data["placeId"];
            this.name = _data["name"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.payerId = _data["payerId"];
            this.payerName = _data["payerName"];
            this.payerStreet = _data["payerStreet"];
            this.payerCity = _data["payerCity"];
            this.payerZipCode = _data["payerZipCode"];
            this.payerIdentificationNumber = _data["payerIdentificationNumber"];
            this.contractNumber = _data["contractNumber"];
            this.dealerIdentification = _data["dealerIdentification"];
            this.purchaseCategory = _data["purchaseCategory"];
            this.connectionMethod = _data["connectionMethod"];
            this.readingCategory = _data["readingCategory"];
            this.consumptionTerminated = _data["consumptionTerminated"];
            this.automaticallyImported = _data["automaticallyImported"];
            this.exportToCis = _data["exportToCis"];
            this.useAlternativeValues = _data["useAlternativeValues"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.note = _data["note"];
            this.group = _data["group"];
            this.state = _data["state"];
            this.lastDataTimestamp = _data["lastDataTimestamp"] ? new Date(_data["lastDataTimestamp"].toString()) : <any>undefined;
            this.lastReadingTimestamp = _data["lastReadingTimestamp"] ? new Date(_data["lastReadingTimestamp"].toString()) : <any>undefined;
            this.workPlace = _data["workPlace"];
            this.dataShardId = _data["dataShardId"];
            this.annualConsumptionMonths = _data["annualConsumptionMonths"];
            this.annualConsumptionVolume = _data["annualConsumptionVolume"];
            this.annualConsumptionInMwh = _data["annualConsumptionInMwh"];
            this.deviceSize = _data["deviceSize"];
            this.validatedTill = _data["validatedTill"] ? new Date(_data["validatedTill"].toString()) : <any>undefined;
            (<any>this).isDataValidated = _data["isDataValidated"];
            this.validatedBy = _data["validatedBy"];
            (<any>this).manuallyImported = _data["manuallyImported"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.validationNote = _data["validationNote"];
            this.parentPlaceGuid = _data["parentPlaceGuid"];
            this.payerNote = _data["payerNote"];
            this.string1 = _data["string1"];
            this.string2 = _data["string2"];
            this.int1 = _data["int1"];
            this.int2 = _data["int2"];
            if (Array.isArray(_data["extendedProperties"])) {
                this.extendedProperties = [] as any;
                for (let item of _data["extendedProperties"])
                    this.extendedProperties!.push(ExtendedProperty.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.device = _data["device"] ? BaseDevice.fromJS(_data["device"]) : <any>undefined;
            (<any>this).deviceSerialNumber = _data["deviceSerialNumber"];
            (<any>this).dataTableName = _data["dataTableName"];
            (<any>this).lastReadingTimestampDescription = _data["lastReadingTimestampDescription"];
            (<any>this).id = _data["id"];
            this.tag = _data["tag"];
            (<any>this).syncRoot = _data["syncRoot"];
            if (Array.isArray(_data["parent"])) {
                this.parent = [] as any;
                for (let item of _data["parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isDeleted = _data["isDeleted"];
            this.isEdited = _data["isEdited"];
            (<any>this).objectState = _data["objectState"];
            if (Array.isArray(_data["rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["isValid"];
            (<any>this).isInError = _data["isInError"];
            (<any>this).error = _data["error"];
            (<any>this).isDirtyHashCode = _data["isDirtyHashCode"];
        }
    }

    static fromJS(data: any): ConsumptionPlace {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumptionPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formatedPlaceNumber"] = this.formatedPlaceNumber;
        data["descriptionWithId"] = this.descriptionWithId;
        data["description"] = this.description;
        data["itemId"] = this.itemId;
        data["guid"] = this.guid;
        data["placeEic"] = this.placeEic;
        data["scadaId"] = this.scadaId;
        data["regionId"] = this.regionId;
        data["placeId"] = this.placeId;
        data["name"] = this.name;
        data["street"] = this.street;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["payerId"] = this.payerId;
        data["payerName"] = this.payerName;
        data["payerStreet"] = this.payerStreet;
        data["payerCity"] = this.payerCity;
        data["payerZipCode"] = this.payerZipCode;
        data["payerIdentificationNumber"] = this.payerIdentificationNumber;
        data["contractNumber"] = this.contractNumber;
        data["dealerIdentification"] = this.dealerIdentification;
        data["purchaseCategory"] = this.purchaseCategory;
        data["connectionMethod"] = this.connectionMethod;
        data["readingCategory"] = this.readingCategory;
        data["consumptionTerminated"] = this.consumptionTerminated;
        data["automaticallyImported"] = this.automaticallyImported;
        data["exportToCis"] = this.exportToCis;
        data["useAlternativeValues"] = this.useAlternativeValues;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["note"] = this.note;
        data["group"] = this.group;
        data["state"] = this.state;
        data["lastDataTimestamp"] = this.lastDataTimestamp ? this.lastDataTimestamp.toISOString() : <any>undefined;
        data["lastReadingTimestamp"] = this.lastReadingTimestamp ? this.lastReadingTimestamp.toISOString() : <any>undefined;
        data["workPlace"] = this.workPlace;
        data["dataShardId"] = this.dataShardId;
        data["annualConsumptionMonths"] = this.annualConsumptionMonths;
        data["annualConsumptionVolume"] = this.annualConsumptionVolume;
        data["annualConsumptionInMwh"] = this.annualConsumptionInMwh;
        data["deviceSize"] = this.deviceSize;
        data["validatedTill"] = this.validatedTill ? this.validatedTill.toISOString() : <any>undefined;
        data["isDataValidated"] = this.isDataValidated;
        data["validatedBy"] = this.validatedBy;
        data["manuallyImported"] = this.manuallyImported;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["validationNote"] = this.validationNote;
        data["parentPlaceGuid"] = this.parentPlaceGuid;
        data["payerNote"] = this.payerNote;
        data["string1"] = this.string1;
        data["string2"] = this.string2;
        data["int1"] = this.int1;
        data["int2"] = this.int2;
        if (Array.isArray(this.extendedProperties)) {
            data["extendedProperties"] = [];
            for (let item of this.extendedProperties)
                data["extendedProperties"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["deviceSerialNumber"] = this.deviceSerialNumber;
        data["dataTableName"] = this.dataTableName;
        data["lastReadingTimestampDescription"] = this.lastReadingTimestampDescription;
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["syncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["parent"] = [];
            for (let item of this.parent)
                data["parent"].push(item);
        }
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isDeleted"] = this.isDeleted;
        data["isEdited"] = this.isEdited;
        data["objectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        data["isInError"] = this.isInError;
        data["error"] = this.error;
        data["isDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IConsumptionPlace {
    formatedPlaceNumber?: string | undefined;
    descriptionWithId?: string | undefined;
    description?: string | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    placeEic?: string | undefined;
    scadaId?: string | undefined;
    regionId?: number | undefined;
    placeId?: string | undefined;
    name?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    payerId?: string | undefined;
    payerName?: string | undefined;
    payerStreet?: string | undefined;
    payerCity?: string | undefined;
    payerZipCode?: string | undefined;
    payerIdentificationNumber?: string | undefined;
    contractNumber?: string | undefined;
    dealerIdentification?: string | undefined;
    purchaseCategory?: number | undefined;
    connectionMethod?: number | undefined;
    readingCategory?: number | undefined;
    consumptionTerminated?: boolean | undefined;
    automaticallyImported?: boolean | undefined;
    exportToCis?: boolean | undefined;
    useAlternativeValues?: boolean | undefined;
    created?: Date | undefined;
    modified?: Date | undefined;
    note?: string | undefined;
    group?: string | undefined;
    state?: number | undefined;
    lastDataTimestamp?: Date | undefined;
    lastReadingTimestamp?: Date | undefined;
    workPlace?: string | undefined;
    dataShardId?: number | undefined;
    annualConsumptionMonths?: number | undefined;
    annualConsumptionVolume?: number | undefined;
    annualConsumptionInMwh?: number | undefined;
    deviceSize?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validatedBy?: string | undefined;
    manuallyImported?: boolean | undefined;
    customer?: Customer | undefined;
    validationNote?: string | undefined;
    parentPlaceGuid?: string | undefined;
    payerNote?: string | undefined;
    string1?: string | undefined;
    string2?: string | undefined;
    int1?: number | undefined;
    int2?: number | undefined;
    extendedProperties?: ExtendedProperty[] | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    device?: BaseDevice | undefined;
    deviceSerialNumber?: string | undefined;
    dataTableName?: string | undefined;
    lastReadingTimestampDescription?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: ConsumptionPlaceObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class BusinessRule implements IBusinessRule {
    readonly description?: string | undefined;
    readonly propertyName?: string | undefined;

    constructor(data?: IBusinessRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["description"];
            (<any>this).propertyName = _data["propertyName"];
        }
    }

    static fromJS(data: any): BusinessRule {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["propertyName"] = this.propertyName;
        return data;
    }
}

export interface IBusinessRule {
    description?: string | undefined;
    propertyName?: string | undefined;
}

export class Customer implements ICustomer {
    itemId?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    consumerId?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    phone?: string | undefined;
    note?: string | undefined;
    comment?: string | undefined;
    contactPerson?: string | undefined;
    email?: string | undefined;
    vatPlace?: string | undefined;
    vatNumber?: string | undefined;
    meterNumber?: string | undefined;
    customerNumber?: string | undefined;
    networkNumber?: string | undefined;
    consumerType?: string | undefined;
    bankInfo?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: CustomerObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.consumerId = _data["consumerId"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.phone = _data["phone"];
            this.note = _data["note"];
            this.comment = _data["comment"];
            this.contactPerson = _data["contactPerson"];
            this.email = _data["email"];
            this.vatPlace = _data["vatPlace"];
            this.vatNumber = _data["vatNumber"];
            this.meterNumber = _data["meterNumber"];
            this.customerNumber = _data["customerNumber"];
            this.networkNumber = _data["networkNumber"];
            this.consumerType = _data["consumerType"];
            this.bankInfo = _data["bankInfo"];
            (<any>this).id = _data["id"];
            this.tag = _data["tag"];
            (<any>this).syncRoot = _data["syncRoot"];
            if (Array.isArray(_data["parent"])) {
                this.parent = [] as any;
                for (let item of _data["parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isDeleted = _data["isDeleted"];
            this.isEdited = _data["isEdited"];
            (<any>this).objectState = _data["objectState"];
            if (Array.isArray(_data["rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["isValid"];
            (<any>this).isInError = _data["isInError"];
            (<any>this).error = _data["error"];
            (<any>this).isDirtyHashCode = _data["isDirtyHashCode"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["consumerId"] = this.consumerId;
        data["street"] = this.street;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["phone"] = this.phone;
        data["note"] = this.note;
        data["comment"] = this.comment;
        data["contactPerson"] = this.contactPerson;
        data["email"] = this.email;
        data["vatPlace"] = this.vatPlace;
        data["vatNumber"] = this.vatNumber;
        data["meterNumber"] = this.meterNumber;
        data["customerNumber"] = this.customerNumber;
        data["networkNumber"] = this.networkNumber;
        data["consumerType"] = this.consumerType;
        data["bankInfo"] = this.bankInfo;
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["syncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["parent"] = [];
            for (let item of this.parent)
                data["parent"].push(item);
        }
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isDeleted"] = this.isDeleted;
        data["isEdited"] = this.isEdited;
        data["objectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        data["isInError"] = this.isInError;
        data["error"] = this.error;
        data["isDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface ICustomer {
    itemId?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    consumerId?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    phone?: string | undefined;
    note?: string | undefined;
    comment?: string | undefined;
    contactPerson?: string | undefined;
    email?: string | undefined;
    vatPlace?: string | undefined;
    vatNumber?: string | undefined;
    meterNumber?: string | undefined;
    customerNumber?: string | undefined;
    networkNumber?: string | undefined;
    consumerType?: string | undefined;
    bankInfo?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: CustomerObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class ExtendedProperty implements IExtendedProperty {
    isEdited?: boolean | undefined;
    placeId?: number | undefined;
    visualPosition?: number | undefined;
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    isReadonly?: boolean | undefined;
    valueAsObject?: any | undefined;

    constructor(data?: IExtendedProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEdited = _data["isEdited"];
            this.placeId = _data["placeId"];
            this.visualPosition = _data["visualPosition"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
            this.isReadonly = _data["isReadonly"];
            this.valueAsObject = _data["valueAsObject"];
        }
    }

    static fromJS(data: any): ExtendedProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendedProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEdited"] = this.isEdited;
        data["placeId"] = this.placeId;
        data["visualPosition"] = this.visualPosition;
        data["key"] = this.key;
        data["name"] = this.name;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        data["isReadonly"] = this.isReadonly;
        data["valueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IExtendedProperty {
    isEdited?: boolean | undefined;
    placeId?: number | undefined;
    visualPosition?: number | undefined;
    key?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    isReadonly?: boolean | undefined;
    valueAsObject?: any | undefined;
}

export class BaseDevice implements IBaseDevice {
    batteryCapacityFieldNames?: string[] | undefined;
    batteryVoltageFieldNames?: string[] | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    readonly tags?: any[] | undefined;
    readonly alarms?: any[] | undefined;
    readonly alarmCount?: number | undefined;
    readonly tagCount?: number | undefined;
    consumptionPlaceGuid?: string | undefined;
    serialNumber?: string | undefined;
    identificationNumber?: string | undefined;
    location?: string | undefined;
    gpsCoordinates?: string | undefined;
    type?: BaseDeviceType | undefined;
    readonly deviceTypeName?: string | undefined;
    deviceTypeDescriptionId?: number | undefined;
    typeDescription?: DeviceTypeDescription | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    useSecondaryConnection?: boolean | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    convertCoefficient?: number | undefined;
    gasDayBegin?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    note?: string | undefined;
    readProcessState?: BaseDeviceReadProcessState | undefined;
    readonly readProcessStateText?: string | undefined;
    logCommunication?: boolean | undefined;
    callRepeat?: number | undefined;
    chromatographGuid?: string | undefined;
    chromatographPeriod?: BaseDeviceChromatographPeriod | undefined;
    chromatograph?: string | undefined;
    firmwareVersion?: string | undefined;
    softwareVersion?: string | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    kind?: BaseDeviceKind | undefined;
    readonly hasConnectedChromatograph?: boolean | undefined;
    chromatographFieldName?: string | undefined;
    readProgress?: number | undefined;
    readProcessDescription?: string | undefined;
    readConnectionDescription?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
    fireAlarmOnReadingFailure?: boolean | undefined;
    readingFailureAlarmId?: number | undefined;
    consumptionPlaceName?: string | undefined;
    readPriority?: number | undefined;
    configurationRequired?: boolean | undefined;
    parentDeviceGuid?: string | undefined;
    childProperties?: string | undefined;
    serializedTags?: string | undefined;
    serializedAlarms?: string | undefined;
    loadDataFromChannel?: number | undefined;
    negativeValuesEnabled?: boolean | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    sourceDataPeriod?: BaseDeviceSourceDataPeriod | undefined;
    readonly hasNonstandardSourceDataPeriod?: boolean | undefined;
    afterReadingErrorWaitTimeout?: number | undefined;
    valveAction?: BaseDeviceValveAction | undefined;
    valveState?: BaseDeviceValveState | undefined;
    readAllChannels?: boolean | undefined;
    readonly readingFailure?: boolean | undefined;
    readonly readingDone?: boolean | undefined;
    readonly checkNewDataTimeStamp?: boolean | undefined;
    readonly newDataMaxTimeStampDivergence?: number | undefined;
    readonly isBackwardCallSupported?: boolean | undefined;
    readonly archiveDataOverlay?: number | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: BaseDeviceObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IBaseDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["batteryCapacityFieldNames"])) {
                this.batteryCapacityFieldNames = [] as any;
                for (let item of _data["batteryCapacityFieldNames"])
                    this.batteryCapacityFieldNames!.push(item);
            }
            if (Array.isArray(_data["batteryVoltageFieldNames"])) {
                this.batteryVoltageFieldNames = [] as any;
                for (let item of _data["batteryVoltageFieldNames"])
                    this.batteryVoltageFieldNames!.push(item);
            }
            this.itemId = _data["itemId"];
            this.guid = _data["guid"];
            if (Array.isArray(_data["tags"])) {
                (<any>this).tags = [] as any;
                for (let item of _data["tags"])
                    (<any>this).tags!.push(item);
            }
            if (Array.isArray(_data["alarms"])) {
                (<any>this).alarms = [] as any;
                for (let item of _data["alarms"])
                    (<any>this).alarms!.push(item);
            }
            (<any>this).alarmCount = _data["alarmCount"];
            (<any>this).tagCount = _data["tagCount"];
            this.consumptionPlaceGuid = _data["consumptionPlaceGuid"];
            this.serialNumber = _data["serialNumber"];
            this.identificationNumber = _data["identificationNumber"];
            this.location = _data["location"];
            this.gpsCoordinates = _data["gpsCoordinates"];
            this.type = _data["type"];
            (<any>this).deviceTypeName = _data["deviceTypeName"];
            this.deviceTypeDescriptionId = _data["deviceTypeDescriptionId"];
            this.typeDescription = _data["typeDescription"] ? DeviceTypeDescription.fromJS(_data["typeDescription"]) : <any>undefined;
            this.primaryConnectionNumber = _data["primaryConnectionNumber"];
            this.secondaryConnectionNumber = _data["secondaryConnectionNumber"];
            this.useSecondaryConnection = _data["useSecondaryConnection"];
            this.primaryConnectionType = _data["primaryConnectionType"];
            this.secondaryConnectionType = _data["secondaryConnectionType"];
            this.convertCoefficient = _data["convertCoefficient"];
            this.gasDayBegin = _data["gasDayBegin"];
            this.primaryDeviceDriverId = _data["primaryDeviceDriverId"];
            this.secondaryDeviceDriverId = _data["secondaryDeviceDriverId"];
            this.note = _data["note"];
            this.readProcessState = _data["readProcessState"];
            (<any>this).readProcessStateText = _data["readProcessStateText"];
            this.logCommunication = _data["logCommunication"];
            this.callRepeat = _data["callRepeat"];
            this.chromatographGuid = _data["chromatographGuid"];
            this.chromatographPeriod = _data["chromatographPeriod"];
            this.chromatograph = _data["chromatograph"];
            this.firmwareVersion = _data["firmwareVersion"];
            this.softwareVersion = _data["softwareVersion"];
            this.batteryCapacity = _data["batteryCapacity"];
            this.batteryVoltage = _data["batteryVoltage"];
            this.maxReadingTimeInMinutes = _data["maxReadingTimeInMinutes"];
            this.kind = _data["kind"];
            (<any>this).hasConnectedChromatograph = _data["hasConnectedChromatograph"];
            this.chromatographFieldName = _data["chromatographFieldName"];
            this.readProgress = _data["readProgress"];
            this.readProcessDescription = _data["readProcessDescription"];
            this.readConnectionDescription = _data["readConnectionDescription"];
            this.schedulerName = _data["schedulerName"];
            this.schedulerTime = _data["schedulerTime"] ? new Date(_data["schedulerTime"].toString()) : <any>undefined;
            this.manualReadingTime = _data["manualReadingTime"] ? new Date(_data["manualReadingTime"].toString()) : <any>undefined;
            this.fireAlarmOnReadingFailure = _data["fireAlarmOnReadingFailure"];
            this.readingFailureAlarmId = _data["readingFailureAlarmId"];
            this.consumptionPlaceName = _data["consumptionPlaceName"];
            this.readPriority = _data["readPriority"];
            this.configurationRequired = _data["configurationRequired"];
            this.parentDeviceGuid = _data["parentDeviceGuid"];
            this.childProperties = _data["childProperties"];
            this.serializedTags = _data["serializedTags"];
            this.serializedAlarms = _data["serializedAlarms"];
            this.loadDataFromChannel = _data["loadDataFromChannel"];
            this.negativeValuesEnabled = _data["negativeValuesEnabled"];
            this.primaryChannelGuid = _data["primaryChannelGuid"];
            this.secondaryChannelGuid = _data["secondaryChannelGuid"];
            this.sourceDataPeriod = _data["sourceDataPeriod"];
            (<any>this).hasNonstandardSourceDataPeriod = _data["hasNonstandardSourceDataPeriod"];
            this.afterReadingErrorWaitTimeout = _data["afterReadingErrorWaitTimeout"];
            this.valveAction = _data["valveAction"];
            this.valveState = _data["valveState"];
            this.readAllChannels = _data["readAllChannels"];
            (<any>this).readingFailure = _data["readingFailure"];
            (<any>this).readingDone = _data["readingDone"];
            (<any>this).checkNewDataTimeStamp = _data["checkNewDataTimeStamp"];
            (<any>this).newDataMaxTimeStampDivergence = _data["newDataMaxTimeStampDivergence"];
            (<any>this).isBackwardCallSupported = _data["isBackwardCallSupported"];
            (<any>this).archiveDataOverlay = _data["archiveDataOverlay"];
            (<any>this).id = _data["id"];
            this.tag = _data["tag"];
            (<any>this).syncRoot = _data["syncRoot"];
            if (Array.isArray(_data["parent"])) {
                this.parent = [] as any;
                for (let item of _data["parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isDeleted = _data["isDeleted"];
            this.isEdited = _data["isEdited"];
            (<any>this).objectState = _data["objectState"];
            if (Array.isArray(_data["rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["isValid"];
            (<any>this).isInError = _data["isInError"];
            (<any>this).error = _data["error"];
            (<any>this).isDirtyHashCode = _data["isDirtyHashCode"];
        }
    }

    static fromJS(data: any): BaseDevice {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.batteryCapacityFieldNames)) {
            data["batteryCapacityFieldNames"] = [];
            for (let item of this.batteryCapacityFieldNames)
                data["batteryCapacityFieldNames"].push(item);
        }
        if (Array.isArray(this.batteryVoltageFieldNames)) {
            data["batteryVoltageFieldNames"] = [];
            for (let item of this.batteryVoltageFieldNames)
                data["batteryVoltageFieldNames"].push(item);
        }
        data["itemId"] = this.itemId;
        data["guid"] = this.guid;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.alarms)) {
            data["alarms"] = [];
            for (let item of this.alarms)
                data["alarms"].push(item);
        }
        data["alarmCount"] = this.alarmCount;
        data["tagCount"] = this.tagCount;
        data["consumptionPlaceGuid"] = this.consumptionPlaceGuid;
        data["serialNumber"] = this.serialNumber;
        data["identificationNumber"] = this.identificationNumber;
        data["location"] = this.location;
        data["gpsCoordinates"] = this.gpsCoordinates;
        data["type"] = this.type;
        data["deviceTypeName"] = this.deviceTypeName;
        data["deviceTypeDescriptionId"] = this.deviceTypeDescriptionId;
        data["typeDescription"] = this.typeDescription ? this.typeDescription.toJSON() : <any>undefined;
        data["primaryConnectionNumber"] = this.primaryConnectionNumber;
        data["secondaryConnectionNumber"] = this.secondaryConnectionNumber;
        data["useSecondaryConnection"] = this.useSecondaryConnection;
        data["primaryConnectionType"] = this.primaryConnectionType;
        data["secondaryConnectionType"] = this.secondaryConnectionType;
        data["convertCoefficient"] = this.convertCoefficient;
        data["gasDayBegin"] = this.gasDayBegin;
        data["primaryDeviceDriverId"] = this.primaryDeviceDriverId;
        data["secondaryDeviceDriverId"] = this.secondaryDeviceDriverId;
        data["note"] = this.note;
        data["readProcessState"] = this.readProcessState;
        data["readProcessStateText"] = this.readProcessStateText;
        data["logCommunication"] = this.logCommunication;
        data["callRepeat"] = this.callRepeat;
        data["chromatographGuid"] = this.chromatographGuid;
        data["chromatographPeriod"] = this.chromatographPeriod;
        data["chromatograph"] = this.chromatograph;
        data["firmwareVersion"] = this.firmwareVersion;
        data["softwareVersion"] = this.softwareVersion;
        data["batteryCapacity"] = this.batteryCapacity;
        data["batteryVoltage"] = this.batteryVoltage;
        data["maxReadingTimeInMinutes"] = this.maxReadingTimeInMinutes;
        data["kind"] = this.kind;
        data["hasConnectedChromatograph"] = this.hasConnectedChromatograph;
        data["chromatographFieldName"] = this.chromatographFieldName;
        data["readProgress"] = this.readProgress;
        data["readProcessDescription"] = this.readProcessDescription;
        data["readConnectionDescription"] = this.readConnectionDescription;
        data["schedulerName"] = this.schedulerName;
        data["schedulerTime"] = this.schedulerTime ? this.schedulerTime.toISOString() : <any>undefined;
        data["manualReadingTime"] = this.manualReadingTime ? this.manualReadingTime.toISOString() : <any>undefined;
        data["fireAlarmOnReadingFailure"] = this.fireAlarmOnReadingFailure;
        data["readingFailureAlarmId"] = this.readingFailureAlarmId;
        data["consumptionPlaceName"] = this.consumptionPlaceName;
        data["readPriority"] = this.readPriority;
        data["configurationRequired"] = this.configurationRequired;
        data["parentDeviceGuid"] = this.parentDeviceGuid;
        data["childProperties"] = this.childProperties;
        data["serializedTags"] = this.serializedTags;
        data["serializedAlarms"] = this.serializedAlarms;
        data["loadDataFromChannel"] = this.loadDataFromChannel;
        data["negativeValuesEnabled"] = this.negativeValuesEnabled;
        data["primaryChannelGuid"] = this.primaryChannelGuid;
        data["secondaryChannelGuid"] = this.secondaryChannelGuid;
        data["sourceDataPeriod"] = this.sourceDataPeriod;
        data["hasNonstandardSourceDataPeriod"] = this.hasNonstandardSourceDataPeriod;
        data["afterReadingErrorWaitTimeout"] = this.afterReadingErrorWaitTimeout;
        data["valveAction"] = this.valveAction;
        data["valveState"] = this.valveState;
        data["readAllChannels"] = this.readAllChannels;
        data["readingFailure"] = this.readingFailure;
        data["readingDone"] = this.readingDone;
        data["checkNewDataTimeStamp"] = this.checkNewDataTimeStamp;
        data["newDataMaxTimeStampDivergence"] = this.newDataMaxTimeStampDivergence;
        data["isBackwardCallSupported"] = this.isBackwardCallSupported;
        data["archiveDataOverlay"] = this.archiveDataOverlay;
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["syncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["parent"] = [];
            for (let item of this.parent)
                data["parent"].push(item);
        }
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isDeleted"] = this.isDeleted;
        data["isEdited"] = this.isEdited;
        data["objectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        data["isInError"] = this.isInError;
        data["error"] = this.error;
        data["isDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IBaseDevice {
    batteryCapacityFieldNames?: string[] | undefined;
    batteryVoltageFieldNames?: string[] | undefined;
    itemId?: number | undefined;
    guid?: string | undefined;
    tags?: any[] | undefined;
    alarms?: any[] | undefined;
    alarmCount?: number | undefined;
    tagCount?: number | undefined;
    consumptionPlaceGuid?: string | undefined;
    serialNumber?: string | undefined;
    identificationNumber?: string | undefined;
    location?: string | undefined;
    gpsCoordinates?: string | undefined;
    type?: BaseDeviceType | undefined;
    deviceTypeName?: string | undefined;
    deviceTypeDescriptionId?: number | undefined;
    typeDescription?: DeviceTypeDescription | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    useSecondaryConnection?: boolean | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    convertCoefficient?: number | undefined;
    gasDayBegin?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    note?: string | undefined;
    readProcessState?: BaseDeviceReadProcessState | undefined;
    readProcessStateText?: string | undefined;
    logCommunication?: boolean | undefined;
    callRepeat?: number | undefined;
    chromatographGuid?: string | undefined;
    chromatographPeriod?: BaseDeviceChromatographPeriod | undefined;
    chromatograph?: string | undefined;
    firmwareVersion?: string | undefined;
    softwareVersion?: string | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    kind?: BaseDeviceKind | undefined;
    hasConnectedChromatograph?: boolean | undefined;
    chromatographFieldName?: string | undefined;
    readProgress?: number | undefined;
    readProcessDescription?: string | undefined;
    readConnectionDescription?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
    fireAlarmOnReadingFailure?: boolean | undefined;
    readingFailureAlarmId?: number | undefined;
    consumptionPlaceName?: string | undefined;
    readPriority?: number | undefined;
    configurationRequired?: boolean | undefined;
    parentDeviceGuid?: string | undefined;
    childProperties?: string | undefined;
    serializedTags?: string | undefined;
    serializedAlarms?: string | undefined;
    loadDataFromChannel?: number | undefined;
    negativeValuesEnabled?: boolean | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    sourceDataPeriod?: BaseDeviceSourceDataPeriod | undefined;
    hasNonstandardSourceDataPeriod?: boolean | undefined;
    afterReadingErrorWaitTimeout?: number | undefined;
    valveAction?: BaseDeviceValveAction | undefined;
    valveState?: BaseDeviceValveState | undefined;
    readAllChannels?: boolean | undefined;
    readingFailure?: boolean | undefined;
    readingDone?: boolean | undefined;
    checkNewDataTimeStamp?: boolean | undefined;
    newDataMaxTimeStampDivergence?: number | undefined;
    isBackwardCallSupported?: boolean | undefined;
    archiveDataOverlay?: number | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: BaseDeviceObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class DeviceTypeDescription implements IDeviceTypeDescription {
    itemId?: number | undefined;
    code?: number | undefined;
    textCode?: string | undefined;
    description?: string | undefined;
    type?: DeviceTypeDescriptionType | undefined;
    isRecounter?: boolean | undefined;
    readonly title?: string | undefined;
    readonly id?: number | undefined;
    tag?: any | undefined;
    readonly syncRoot?: any | undefined;
    parent?: any[] | undefined;
    readonly isDirty?: boolean | undefined;
    readonly isNew?: boolean | undefined;
    readonly isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    readonly objectState?: DeviceTypeDescriptionObjectState | undefined;
    readonly rules?: BusinessRule[] | undefined;
    readonly isValid?: boolean | undefined;
    readonly isInError?: boolean | undefined;
    readonly error?: string | undefined;
    readonly isDirtyHashCode?: boolean | undefined;

    constructor(data?: IDeviceTypeDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.code = _data["code"];
            this.textCode = _data["textCode"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.isRecounter = _data["isRecounter"];
            (<any>this).title = _data["title"];
            (<any>this).id = _data["id"];
            this.tag = _data["tag"];
            (<any>this).syncRoot = _data["syncRoot"];
            if (Array.isArray(_data["parent"])) {
                this.parent = [] as any;
                for (let item of _data["parent"])
                    this.parent!.push(item);
            }
            (<any>this).isDirty = _data["isDirty"];
            (<any>this).isNew = _data["isNew"];
            (<any>this).isDeleted = _data["isDeleted"];
            this.isEdited = _data["isEdited"];
            (<any>this).objectState = _data["objectState"];
            if (Array.isArray(_data["rules"])) {
                (<any>this).rules = [] as any;
                for (let item of _data["rules"])
                    (<any>this).rules!.push(BusinessRule.fromJS(item));
            }
            (<any>this).isValid = _data["isValid"];
            (<any>this).isInError = _data["isInError"];
            (<any>this).error = _data["error"];
            (<any>this).isDirtyHashCode = _data["isDirtyHashCode"];
        }
    }

    static fromJS(data: any): DeviceTypeDescription {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTypeDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["code"] = this.code;
        data["textCode"] = this.textCode;
        data["description"] = this.description;
        data["type"] = this.type;
        data["isRecounter"] = this.isRecounter;
        data["title"] = this.title;
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["syncRoot"] = this.syncRoot;
        if (Array.isArray(this.parent)) {
            data["parent"] = [];
            for (let item of this.parent)
                data["parent"].push(item);
        }
        data["isDirty"] = this.isDirty;
        data["isNew"] = this.isNew;
        data["isDeleted"] = this.isDeleted;
        data["isEdited"] = this.isEdited;
        data["objectState"] = this.objectState;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        data["isValid"] = this.isValid;
        data["isInError"] = this.isInError;
        data["error"] = this.error;
        data["isDirtyHashCode"] = this.isDirtyHashCode;
        return data;
    }
}

export interface IDeviceTypeDescription {
    itemId?: number | undefined;
    code?: number | undefined;
    textCode?: string | undefined;
    description?: string | undefined;
    type?: DeviceTypeDescriptionType | undefined;
    isRecounter?: boolean | undefined;
    title?: string | undefined;
    id?: number | undefined;
    tag?: any | undefined;
    syncRoot?: any | undefined;
    parent?: any[] | undefined;
    isDirty?: boolean | undefined;
    isNew?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isEdited?: boolean | undefined;
    objectState?: DeviceTypeDescriptionObjectState | undefined;
    rules?: BusinessRule[] | undefined;
    isValid?: boolean | undefined;
    isInError?: boolean | undefined;
    error?: string | undefined;
    isDirtyHashCode?: boolean | undefined;
}

export class AlarmPage implements IAlarmPage {
    pageItems?: Alarm[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IAlarmPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(Alarm.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AlarmPage {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IAlarmPage {
    pageItems?: Alarm[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Alarm implements IAlarm {
    id?: number | undefined;
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    timeWritten?: string | undefined;
    timeTerminated?: string | undefined;
    timeAcknowledged?: string | undefined;
    timeAnnotated?: string | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;

    constructor(data?: IAlarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.timeGenerated = _data["timeGenerated"];
            this.timeGeneratedRelative = _data["timeGeneratedRelative"];
            this.timeWritten = _data["timeWritten"];
            this.timeTerminated = _data["timeTerminated"];
            this.timeAcknowledged = _data["timeAcknowledged"];
            this.timeAnnotated = _data["timeAnnotated"];
            this.alarmID = _data["alarmID"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.acknowledgeUser = _data["acknowledgeUser"];
            this.annotationUser = _data["annotationUser"];
            this.device = _data["device"];
            this.tagName = _data["tagName"];
            this.tagValue = _data["tagValue"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.note = _data["note"];
            this.acknowledgementRequired = _data["acknowledgementRequired"];
            this.acknowledged = _data["acknowledged"];
            this.isActive = _data["isActive"];
            this.regionId = _data["regionId"];
            this.region = _data["region"];
        }
    }

    static fromJS(data: any): Alarm {
        data = typeof data === 'object' ? data : {};
        let result = new Alarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["timeGenerated"] = this.timeGenerated;
        data["timeGeneratedRelative"] = this.timeGeneratedRelative;
        data["timeWritten"] = this.timeWritten;
        data["timeTerminated"] = this.timeTerminated;
        data["timeAcknowledged"] = this.timeAcknowledged;
        data["timeAnnotated"] = this.timeAnnotated;
        data["alarmID"] = this.alarmID;
        data["source"] = this.source;
        data["category"] = this.category;
        data["acknowledgeUser"] = this.acknowledgeUser;
        data["annotationUser"] = this.annotationUser;
        data["device"] = this.device;
        data["tagName"] = this.tagName;
        data["tagValue"] = this.tagValue;
        data["message"] = this.message;
        data["data"] = this.data;
        data["note"] = this.note;
        data["acknowledgementRequired"] = this.acknowledgementRequired;
        data["acknowledged"] = this.acknowledged;
        data["isActive"] = this.isActive;
        data["regionId"] = this.regionId;
        data["region"] = this.region;
        return data;
    }
}

export interface IAlarm {
    id?: number | undefined;
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    timeWritten?: string | undefined;
    timeTerminated?: string | undefined;
    timeAcknowledged?: string | undefined;
    timeAnnotated?: string | undefined;
    alarmID?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    acknowledgeUser?: string | undefined;
    annotationUser?: string | undefined;
    device?: string | undefined;
    tagName?: string | undefined;
    tagValue?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    note?: string | undefined;
    acknowledgementRequired?: boolean | undefined;
    acknowledged?: boolean | undefined;
    isActive?: boolean | undefined;
    regionId?: number | undefined;
    region?: string | undefined;
}

export class AlarmsAnnotation implements IAlarmsAnnotation {
    alarmsIds?: number[] | undefined;
    note?: string | undefined;

    constructor(data?: IAlarmsAnnotation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["alarmsIds"])) {
                this.alarmsIds = [] as any;
                for (let item of _data["alarmsIds"])
                    this.alarmsIds!.push(item);
            }
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): AlarmsAnnotation {
        data = typeof data === 'object' ? data : {};
        let result = new AlarmsAnnotation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.alarmsIds)) {
            data["alarmsIds"] = [];
            for (let item of this.alarmsIds)
                data["alarmsIds"].push(item);
        }
        data["note"] = this.note;
        return data;
    }
}

export interface IAlarmsAnnotation {
    alarmsIds?: number[] | undefined;
    note?: string | undefined;
}

export class Login implements ILogin {
    name!: string;
    password!: string;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["password"] = this.password;
        return data;
    }
}

export interface ILogin {
    name: string;
    password: string;
}

export class ConnectedUserLite implements IConnectedUserLite {
    fullName?: string | undefined;
    logOnName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    comment?: string | undefined;
    lastAccessTimestamp?: string | undefined;
    lastAccessRelative?: string | undefined;
    logOnTimestamp?: string | undefined;
    lastClientVersion?: string | undefined;
    systemRole?: string | undefined;
    internetRole?: string | undefined;
    clientType?: string | undefined;
    clientTypeDescription?: string | undefined;
    isItMe?: boolean | undefined;
    encodedSessionId?: string | undefined;
    sessionId?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: IConnectedUserLite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.logOnName = _data["logOnName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.comment = _data["comment"];
            this.lastAccessTimestamp = _data["lastAccessTimestamp"];
            this.lastAccessRelative = _data["lastAccessRelative"];
            this.logOnTimestamp = _data["logOnTimestamp"];
            this.lastClientVersion = _data["lastClientVersion"];
            this.systemRole = _data["systemRole"];
            this.internetRole = _data["internetRole"];
            this.clientType = _data["clientType"];
            this.clientTypeDescription = _data["clientTypeDescription"];
            this.isItMe = _data["isItMe"];
            this.encodedSessionId = _data["encodedSessionId"];
            this.sessionId = _data["sessionId"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): ConnectedUserLite {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectedUserLite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["logOnName"] = this.logOnName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["comment"] = this.comment;
        data["lastAccessTimestamp"] = this.lastAccessTimestamp;
        data["lastAccessRelative"] = this.lastAccessRelative;
        data["logOnTimestamp"] = this.logOnTimestamp;
        data["lastClientVersion"] = this.lastClientVersion;
        data["systemRole"] = this.systemRole;
        data["internetRole"] = this.internetRole;
        data["clientType"] = this.clientType;
        data["clientTypeDescription"] = this.clientTypeDescription;
        data["isItMe"] = this.isItMe;
        data["encodedSessionId"] = this.encodedSessionId;
        data["sessionId"] = this.sessionId;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IConnectedUserLite {
    fullName?: string | undefined;
    logOnName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    comment?: string | undefined;
    lastAccessTimestamp?: string | undefined;
    lastAccessRelative?: string | undefined;
    logOnTimestamp?: string | undefined;
    lastClientVersion?: string | undefined;
    systemRole?: string | undefined;
    internetRole?: string | undefined;
    clientType?: string | undefined;
    clientTypeDescription?: string | undefined;
    isItMe?: boolean | undefined;
    encodedSessionId?: string | undefined;
    sessionId?: string | undefined;
    apiKey?: string | undefined;
}

export class CallLogs implements ICallLogs {
    items?: CallLogItem[] | undefined;
    count?: number | undefined;

    constructor(data?: ICallLogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CallLogItem.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CallLogs {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface ICallLogs {
    items?: CallLogItem[] | undefined;
    count?: number | undefined;
}

export class CallLogItem implements ICallLogItem {
    timestamp?: Date | undefined;
    data?: string | undefined;
    status?: string | undefined;
    dataType?: string | undefined;
    packet?: string | undefined;

    constructor(data?: ICallLogItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.data = _data["data"];
            this.status = _data["status"];
            this.dataType = _data["dataType"];
            this.packet = _data["packet"];
        }
    }

    static fromJS(data: any): CallLogItem {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["data"] = this.data;
        data["status"] = this.status;
        data["dataType"] = this.dataType;
        data["packet"] = this.packet;
        return data;
    }
}

export interface ICallLogItem {
    timestamp?: Date | undefined;
    data?: string | undefined;
    status?: string | undefined;
    dataType?: string | undefined;
    packet?: string | undefined;
}

export class ChartData implements IChartData {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    successRate?: { [key: string]: number; } | undefined;
    readingTimeDuration?: { [key: string]: number; } | undefined;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["ok"]) {
                this.ok = {} as any;
                for (let key in _data["ok"]) {
                    if (_data["ok"].hasOwnProperty(key))
                        (<any>this.ok)![key] = _data["ok"][key];
                }
            }
            if (_data["failures"]) {
                this.failures = {} as any;
                for (let key in _data["failures"]) {
                    if (_data["failures"].hasOwnProperty(key))
                        (<any>this.failures)![key] = _data["failures"][key];
                }
            }
            if (_data["successRate"]) {
                this.successRate = {} as any;
                for (let key in _data["successRate"]) {
                    if (_data["successRate"].hasOwnProperty(key))
                        (<any>this.successRate)![key] = _data["successRate"][key];
                }
            }
            if (_data["readingTimeDuration"]) {
                this.readingTimeDuration = {} as any;
                for (let key in _data["readingTimeDuration"]) {
                    if (_data["readingTimeDuration"].hasOwnProperty(key))
                        (<any>this.readingTimeDuration)![key] = _data["readingTimeDuration"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChartData {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ok) {
            data["ok"] = {};
            for (let key in this.ok) {
                if (this.ok.hasOwnProperty(key))
                    (<any>data["ok"])[key] = (<any>this.ok)[key];
            }
        }
        if (this.failures) {
            data["failures"] = {};
            for (let key in this.failures) {
                if (this.failures.hasOwnProperty(key))
                    (<any>data["failures"])[key] = (<any>this.failures)[key];
            }
        }
        if (this.successRate) {
            data["successRate"] = {};
            for (let key in this.successRate) {
                if (this.successRate.hasOwnProperty(key))
                    (<any>data["successRate"])[key] = (<any>this.successRate)[key];
            }
        }
        if (this.readingTimeDuration) {
            data["readingTimeDuration"] = {};
            for (let key in this.readingTimeDuration) {
                if (this.readingTimeDuration.hasOwnProperty(key))
                    (<any>data["readingTimeDuration"])[key] = (<any>this.readingTimeDuration)[key];
            }
        }
        return data;
    }
}

export interface IChartData {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    successRate?: { [key: string]: number; } | undefined;
    readingTimeDuration?: { [key: string]: number; } | undefined;
}

export class CallStatisticPage implements ICallStatisticPage {
    pageItems?: CallStatisticItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ICallStatisticPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(CallStatisticItem.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CallStatisticPage {
        data = typeof data === 'object' ? data : {};
        let result = new CallStatisticPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICallStatisticPage {
    pageItems?: CallStatisticItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class CallStatisticItem implements ICallStatisticItem {
    readingStart?: Date | undefined;
    callsTimeInSeconds?: number | undefined;
    requestStatus?: string | undefined;
    requestStatusDescription?: string | undefined;
    successfullyWrittenDeviceParams?: string | undefined;
    unsuccessfullyWrittenDeviceParams?: string | undefined;
    writeDeviceParamsStatusDescription?: string | undefined;

    constructor(data?: ICallStatisticItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.readingStart = _data["readingStart"] ? new Date(_data["readingStart"].toString()) : <any>undefined;
            this.callsTimeInSeconds = _data["callsTimeInSeconds"];
            this.requestStatus = _data["requestStatus"];
            this.requestStatusDescription = _data["requestStatusDescription"];
            this.successfullyWrittenDeviceParams = _data["successfullyWrittenDeviceParams"];
            this.unsuccessfullyWrittenDeviceParams = _data["unsuccessfullyWrittenDeviceParams"];
            this.writeDeviceParamsStatusDescription = _data["writeDeviceParamsStatusDescription"];
        }
    }

    static fromJS(data: any): CallStatisticItem {
        data = typeof data === 'object' ? data : {};
        let result = new CallStatisticItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["readingStart"] = this.readingStart ? this.readingStart.toISOString() : <any>undefined;
        data["callsTimeInSeconds"] = this.callsTimeInSeconds;
        data["requestStatus"] = this.requestStatus;
        data["requestStatusDescription"] = this.requestStatusDescription;
        data["successfullyWrittenDeviceParams"] = this.successfullyWrittenDeviceParams;
        data["unsuccessfullyWrittenDeviceParams"] = this.unsuccessfullyWrittenDeviceParams;
        data["writeDeviceParamsStatusDescription"] = this.writeDeviceParamsStatusDescription;
        return data;
    }
}

export interface ICallStatisticItem {
    readingStart?: Date | undefined;
    callsTimeInSeconds?: number | undefined;
    requestStatus?: string | undefined;
    requestStatusDescription?: string | undefined;
    successfullyWrittenDeviceParams?: string | undefined;
    unsuccessfullyWrittenDeviceParams?: string | undefined;
    writeDeviceParamsStatusDescription?: string | undefined;
}

export class CommunicationTestProgress implements ICommunicationTestProgress {
    guid?: string | undefined;
    description?: string | undefined;
    progress?: number | undefined;
    error?: boolean | undefined;
    deviceSerialNumber?: string | undefined;
    operatingAmount?: number | undefined;
    convertAmount?: number | undefined;

    constructor(data?: ICommunicationTestProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.description = _data["description"];
            this.progress = _data["progress"];
            this.error = _data["error"];
            this.deviceSerialNumber = _data["deviceSerialNumber"];
            this.operatingAmount = _data["operatingAmount"];
            this.convertAmount = _data["convertAmount"];
        }
    }

    static fromJS(data: any): CommunicationTestProgress {
        data = typeof data === 'object' ? data : {};
        let result = new CommunicationTestProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["description"] = this.description;
        data["progress"] = this.progress;
        data["error"] = this.error;
        data["deviceSerialNumber"] = this.deviceSerialNumber;
        data["operatingAmount"] = this.operatingAmount;
        data["convertAmount"] = this.convertAmount;
        return data;
    }
}

export interface ICommunicationTestProgress {
    guid?: string | undefined;
    description?: string | undefined;
    progress?: number | undefined;
    error?: boolean | undefined;
    deviceSerialNumber?: string | undefined;
    operatingAmount?: number | undefined;
    convertAmount?: number | undefined;
}

export class ChangePassword implements IChangePassword {
    oldPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePassword {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePassword {
    oldPassword: string;
    newPassword: string;
}

export class DashboardVariables implements IDashboardVariables {
    items?: DashboardVariable[] | undefined;
    count?: number | undefined;
    defaultFieldName?: string | undefined;

    constructor(data?: IDashboardVariables) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DashboardVariable.fromJS(item));
            }
            this.count = _data["count"];
            this.defaultFieldName = _data["defaultFieldName"];
        }
    }

    static fromJS(data: any): DashboardVariables {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardVariables();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["defaultFieldName"] = this.defaultFieldName;
        return data;
    }
}

export interface IDashboardVariables {
    items?: DashboardVariable[] | undefined;
    count?: number | undefined;
    defaultFieldName?: string | undefined;
}

export class DashboardVariable implements IDashboardVariable {
    name?: string | undefined;
    fieldName?: string | undefined;

    constructor(data?: IDashboardVariable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fieldName = _data["fieldName"];
        }
    }

    static fromJS(data: any): DashboardVariable {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardVariable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fieldName"] = this.fieldName;
        return data;
    }
}

export interface IDashboardVariable {
    name?: string | undefined;
    fieldName?: string | undefined;
}

export class DashboardMainDevices implements IDashboardMainDevices {
    items?: DashboardMainDevice[] | undefined;
    count?: number | undefined;

    constructor(data?: IDashboardMainDevices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DashboardMainDevice.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): DashboardMainDevices {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardMainDevices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IDashboardMainDevices {
    items?: DashboardMainDevice[] | undefined;
    count?: number | undefined;
}

export class DashboardMainDevice implements IDashboardMainDevice {
    mainDeviceGuid?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDashboardMainDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainDeviceGuid = _data["mainDeviceGuid"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DashboardMainDevice {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardMainDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainDeviceGuid"] = this.mainDeviceGuid;
        data["name"] = this.name;
        return data;
    }
}

export interface IDashboardMainDevice {
    mainDeviceGuid?: string | undefined;
    name?: string | undefined;
}

export class DashboardRoot implements IDashboardRoot {
    dashboardAreas?: DashboardArea[] | undefined;
    count?: number | undefined;
    mainDeviceTotal?: number | undefined;
    balanceTotal?: number | undefined;
    balanceTotalPercentage?: number | undefined;
    subAreaTotal?: number | undefined;
    subAreaTotalPercentage?: number | undefined;
    subAreaTotalTitle?: string | undefined;

    constructor(data?: IDashboardRoot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dashboardAreas"])) {
                this.dashboardAreas = [] as any;
                for (let item of _data["dashboardAreas"])
                    this.dashboardAreas!.push(DashboardArea.fromJS(item));
            }
            this.count = _data["count"];
            this.mainDeviceTotal = _data["mainDeviceTotal"];
            this.balanceTotal = _data["balanceTotal"];
            this.balanceTotalPercentage = _data["balanceTotalPercentage"];
            this.subAreaTotal = _data["subAreaTotal"];
            this.subAreaTotalPercentage = _data["subAreaTotalPercentage"];
            this.subAreaTotalTitle = _data["subAreaTotalTitle"];
        }
    }

    static fromJS(data: any): DashboardRoot {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardRoot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dashboardAreas)) {
            data["dashboardAreas"] = [];
            for (let item of this.dashboardAreas)
                data["dashboardAreas"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["mainDeviceTotal"] = this.mainDeviceTotal;
        data["balanceTotal"] = this.balanceTotal;
        data["balanceTotalPercentage"] = this.balanceTotalPercentage;
        data["subAreaTotal"] = this.subAreaTotal;
        data["subAreaTotalPercentage"] = this.subAreaTotalPercentage;
        data["subAreaTotalTitle"] = this.subAreaTotalTitle;
        return data;
    }
}

export interface IDashboardRoot {
    dashboardAreas?: DashboardArea[] | undefined;
    count?: number | undefined;
    mainDeviceTotal?: number | undefined;
    balanceTotal?: number | undefined;
    balanceTotalPercentage?: number | undefined;
    subAreaTotal?: number | undefined;
    subAreaTotalPercentage?: number | undefined;
    subAreaTotalTitle?: string | undefined;
}

export class DashboardArea implements IDashboardArea {
    mainDevice?: DashboardItem | undefined;
    regionId?: number | undefined;
    regionName?: string | undefined;
    areaItems?: DashboardAreaItem[] | undefined;
    areaBalance?: number | undefined;
    areaBalancePercentage?: number | undefined;
    areaBalancePercentageTitle?: string | undefined;

    constructor(data?: IDashboardArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainDevice = _data["mainDevice"] ? DashboardItem.fromJS(_data["mainDevice"]) : <any>undefined;
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            if (Array.isArray(_data["areaItems"])) {
                this.areaItems = [] as any;
                for (let item of _data["areaItems"])
                    this.areaItems!.push(DashboardAreaItem.fromJS(item));
            }
            this.areaBalance = _data["areaBalance"];
            this.areaBalancePercentage = _data["areaBalancePercentage"];
            this.areaBalancePercentageTitle = _data["areaBalancePercentageTitle"];
        }
    }

    static fromJS(data: any): DashboardArea {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainDevice"] = this.mainDevice ? this.mainDevice.toJSON() : <any>undefined;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        if (Array.isArray(this.areaItems)) {
            data["areaItems"] = [];
            for (let item of this.areaItems)
                data["areaItems"].push(item.toJSON());
        }
        data["areaBalance"] = this.areaBalance;
        data["areaBalancePercentage"] = this.areaBalancePercentage;
        data["areaBalancePercentageTitle"] = this.areaBalancePercentageTitle;
        return data;
    }
}

export interface IDashboardArea {
    mainDevice?: DashboardItem | undefined;
    regionId?: number | undefined;
    regionName?: string | undefined;
    areaItems?: DashboardAreaItem[] | undefined;
    areaBalance?: number | undefined;
    areaBalancePercentage?: number | undefined;
    areaBalancePercentageTitle?: string | undefined;
}

export class DashboardItem implements IDashboardItem {
    placeGuid?: string | undefined;
    name?: string | undefined;
    dealerIdentification?: string | undefined;
    value?: number | undefined;
    readStatus?: number | undefined;
    connectionMethod?: number | undefined;

    constructor(data?: IDashboardItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeGuid = _data["placeGuid"];
            this.name = _data["name"];
            this.dealerIdentification = _data["dealerIdentification"];
            this.value = _data["value"];
            this.readStatus = _data["readStatus"];
            this.connectionMethod = _data["connectionMethod"];
        }
    }

    static fromJS(data: any): DashboardItem {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeGuid"] = this.placeGuid;
        data["name"] = this.name;
        data["dealerIdentification"] = this.dealerIdentification;
        data["value"] = this.value;
        data["readStatus"] = this.readStatus;
        data["connectionMethod"] = this.connectionMethod;
        return data;
    }
}

export interface IDashboardItem {
    placeGuid?: string | undefined;
    name?: string | undefined;
    dealerIdentification?: string | undefined;
    value?: number | undefined;
    readStatus?: number | undefined;
    connectionMethod?: number | undefined;
}

export class DashboardAreaItem implements IDashboardAreaItem {
    name?: string | undefined;
    items?: DashboardItem[] | undefined;
    subTotal?: number | undefined;
    subTotalPercentage?: number | undefined;
    subTotalPercentageTitle?: string | undefined;

    constructor(data?: IDashboardAreaItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DashboardItem.fromJS(item));
            }
            this.subTotal = _data["subTotal"];
            this.subTotalPercentage = _data["subTotalPercentage"];
            this.subTotalPercentageTitle = _data["subTotalPercentageTitle"];
        }
    }

    static fromJS(data: any): DashboardAreaItem {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardAreaItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["subTotal"] = this.subTotal;
        data["subTotalPercentage"] = this.subTotalPercentage;
        data["subTotalPercentageTitle"] = this.subTotalPercentageTitle;
        return data;
    }
}

export interface IDashboardAreaItem {
    name?: string | undefined;
    items?: DashboardItem[] | undefined;
    subTotal?: number | undefined;
    subTotalPercentage?: number | undefined;
    subTotalPercentageTitle?: string | undefined;
}

export class DataExportFileParameters implements IDataExportFileParameters {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    leaveDateAsItIs?: boolean | undefined;
    placesIds?: number[] | undefined;
    profilesIds?: number[] | undefined;
    internetAveExportType?: string | undefined;
    exportType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    templateFile?: DataExportTemplateFile | undefined;
    deviceGroupName?: string | undefined;
    clientOutputFileName?: string | undefined;

    constructor(data?: IDataExportFileParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            this.leaveDateAsItIs = _data["leaveDateAsItIs"];
            if (Array.isArray(_data["placesIds"])) {
                this.placesIds = [] as any;
                for (let item of _data["placesIds"])
                    this.placesIds!.push(item);
            }
            if (Array.isArray(_data["profilesIds"])) {
                this.profilesIds = [] as any;
                for (let item of _data["profilesIds"])
                    this.profilesIds!.push(item);
            }
            this.internetAveExportType = _data["internetAveExportType"];
            this.exportType = _data["exportType"];
            this.truncateData = _data["truncateData"];
            this.withDaylightSavingTime = _data["withDaylightSavingTime"];
            this.templateFile = _data["templateFile"] ? DataExportTemplateFile.fromJS(_data["templateFile"]) : <any>undefined;
            this.deviceGroupName = _data["deviceGroupName"];
            this.clientOutputFileName = _data["clientOutputFileName"];
        }
    }

    static fromJS(data: any): DataExportFileParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportFileParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["leaveDateAsItIs"] = this.leaveDateAsItIs;
        if (Array.isArray(this.placesIds)) {
            data["placesIds"] = [];
            for (let item of this.placesIds)
                data["placesIds"].push(item);
        }
        if (Array.isArray(this.profilesIds)) {
            data["profilesIds"] = [];
            for (let item of this.profilesIds)
                data["profilesIds"].push(item);
        }
        data["internetAveExportType"] = this.internetAveExportType;
        data["exportType"] = this.exportType;
        data["truncateData"] = this.truncateData;
        data["withDaylightSavingTime"] = this.withDaylightSavingTime;
        data["templateFile"] = this.templateFile ? this.templateFile.toJSON() : <any>undefined;
        data["deviceGroupName"] = this.deviceGroupName;
        data["clientOutputFileName"] = this.clientOutputFileName;
        return data;
    }
}

export interface IDataExportFileParameters {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    leaveDateAsItIs?: boolean | undefined;
    placesIds?: number[] | undefined;
    profilesIds?: number[] | undefined;
    internetAveExportType?: string | undefined;
    exportType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    templateFile?: DataExportTemplateFile | undefined;
    deviceGroupName?: string | undefined;
    clientOutputFileName?: string | undefined;
}

export class DataExportTemplateFile implements IDataExportTemplateFile {
    fileName?: string | undefined;
    contentBase64?: string | undefined;

    constructor(data?: IDataExportTemplateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.contentBase64 = _data["contentBase64"];
        }
    }

    static fromJS(data: any): DataExportTemplateFile {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportTemplateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["contentBase64"] = this.contentBase64;
        return data;
    }
}

export interface IDataExportTemplateFile {
    fileName?: string | undefined;
    contentBase64?: string | undefined;
}

export class DataExportType implements IDataExportType {
    id?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    fileExtension?: string | undefined;

    constructor(data?: IDataExportType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.fileExtension = _data["fileExtension"];
        }
    }

    static fromJS(data: any): DataExportType {
        data = typeof data === 'object' ? data : {};
        let result = new DataExportType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["description"] = this.description;
        data["fileExtension"] = this.fileExtension;
        return data;
    }
}

export interface IDataExportType {
    id?: number | undefined;
    type?: string | undefined;
    description?: string | undefined;
    fileExtension?: string | undefined;
}

export class DataPumpLite implements IDataPumpLite {
    id?: number | undefined;
    eventLogSource?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    typeDescription?: string | undefined;
    enabled?: boolean | undefined;
    inError?: boolean | undefined;
    serverId?: number | undefined;
    regionId?: number | undefined;
    interval?: number | undefined;
    lastExecutionTime?: string | undefined;
    nextExecutionTime?: string | undefined;
    repeatInterval?: string | undefined;
    repeatIntervalDescription?: string | undefined;
    alarmOnErrorEnabled?: boolean | undefined;
    alarmIdOnError?: number | undefined;

    constructor(data?: IDataPumpLite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventLogSource = _data["eventLogSource"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.typeDescription = _data["typeDescription"];
            this.enabled = _data["enabled"];
            this.inError = _data["inError"];
            this.serverId = _data["serverId"];
            this.regionId = _data["regionId"];
            this.interval = _data["interval"];
            this.lastExecutionTime = _data["lastExecutionTime"];
            this.nextExecutionTime = _data["nextExecutionTime"];
            this.repeatInterval = _data["repeatInterval"];
            this.repeatIntervalDescription = _data["repeatIntervalDescription"];
            this.alarmOnErrorEnabled = _data["alarmOnErrorEnabled"];
            this.alarmIdOnError = _data["alarmIdOnError"];
        }
    }

    static fromJS(data: any): DataPumpLite {
        data = typeof data === 'object' ? data : {};
        let result = new DataPumpLite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventLogSource"] = this.eventLogSource;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["typeDescription"] = this.typeDescription;
        data["enabled"] = this.enabled;
        data["inError"] = this.inError;
        data["serverId"] = this.serverId;
        data["regionId"] = this.regionId;
        data["interval"] = this.interval;
        data["lastExecutionTime"] = this.lastExecutionTime;
        data["nextExecutionTime"] = this.nextExecutionTime;
        data["repeatInterval"] = this.repeatInterval;
        data["repeatIntervalDescription"] = this.repeatIntervalDescription;
        data["alarmOnErrorEnabled"] = this.alarmOnErrorEnabled;
        data["alarmIdOnError"] = this.alarmIdOnError;
        return data;
    }
}

export interface IDataPumpLite {
    id?: number | undefined;
    eventLogSource?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: string | undefined;
    typeDescription?: string | undefined;
    enabled?: boolean | undefined;
    inError?: boolean | undefined;
    serverId?: number | undefined;
    regionId?: number | undefined;
    interval?: number | undefined;
    lastExecutionTime?: string | undefined;
    nextExecutionTime?: string | undefined;
    repeatInterval?: string | undefined;
    repeatIntervalDescription?: string | undefined;
    alarmOnErrorEnabled?: boolean | undefined;
    alarmIdOnError?: number | undefined;
}

export class ChartData1 implements IChartData1 {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    sucessRate?: { [key: string]: number; } | undefined;

    constructor(data?: IChartData1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["ok"]) {
                this.ok = {} as any;
                for (let key in _data["ok"]) {
                    if (_data["ok"].hasOwnProperty(key))
                        (<any>this.ok)![key] = _data["ok"][key];
                }
            }
            if (_data["failures"]) {
                this.failures = {} as any;
                for (let key in _data["failures"]) {
                    if (_data["failures"].hasOwnProperty(key))
                        (<any>this.failures)![key] = _data["failures"][key];
                }
            }
            if (_data["sucessRate"]) {
                this.sucessRate = {} as any;
                for (let key in _data["sucessRate"]) {
                    if (_data["sucessRate"].hasOwnProperty(key))
                        (<any>this.sucessRate)![key] = _data["sucessRate"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChartData1 {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ok) {
            data["ok"] = {};
            for (let key in this.ok) {
                if (this.ok.hasOwnProperty(key))
                    (<any>data["ok"])[key] = (<any>this.ok)[key];
            }
        }
        if (this.failures) {
            data["failures"] = {};
            for (let key in this.failures) {
                if (this.failures.hasOwnProperty(key))
                    (<any>data["failures"])[key] = (<any>this.failures)[key];
            }
        }
        if (this.sucessRate) {
            data["sucessRate"] = {};
            for (let key in this.sucessRate) {
                if (this.sucessRate.hasOwnProperty(key))
                    (<any>data["sucessRate"])[key] = (<any>this.sucessRate)[key];
            }
        }
        return data;
    }
}

export interface IChartData1 {
    ok?: { [key: string]: number; } | undefined;
    failures?: { [key: string]: number; } | undefined;
    sucessRate?: { [key: string]: number; } | undefined;
}

export class ProfilePage implements IProfilePage {
    pageItems?: Profile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IProfilePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(Profile.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ProfilePage {
        data = typeof data === 'object' ? data : {};
        let result = new ProfilePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IProfilePage {
    pageItems?: Profile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Profile implements IProfile {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    created?: string | undefined;
    modified?: string | undefined;
    connectionType?: string | undefined;
    connectionTypeDescription?: string | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.regionId = _data["regionId"];
            this.created = _data["created"];
            this.modified = _data["modified"];
            this.connectionType = _data["connectionType"];
            this.connectionTypeDescription = _data["connectionTypeDescription"];
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["regionId"] = this.regionId;
        data["created"] = this.created;
        data["modified"] = this.modified;
        data["connectionType"] = this.connectionType;
        data["connectionTypeDescription"] = this.connectionTypeDescription;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        return data;
    }
}

export interface IProfile {
    id?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    created?: string | undefined;
    modified?: string | undefined;
    connectionType?: string | undefined;
    connectionTypeDescription?: string | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
}

export class DataPumpSummary implements IDataPumpSummary {
    systemEvents?: SystemEventPage | undefined;
    lastRunErrors?: number | undefined;
    lastRunSuccessfullySent?: number | undefined;
    lastRunTotal?: number | undefined;
    dataRangeErrors?: number | undefined;
    dataRangeSuccessfullySent?: number | undefined;
    dataRangeTotal?: number | undefined;
    dataRangeFrom?: string | undefined;
    dataRangeTo?: string | undefined;
    noSummaryDataAvailable?: boolean | undefined;
    lastRunSuccessRate?: number | undefined;
    dataRangeSuccessRate?: number | undefined;

    constructor(data?: IDataPumpSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemEvents = _data["systemEvents"] ? SystemEventPage.fromJS(_data["systemEvents"]) : <any>undefined;
            this.lastRunErrors = _data["lastRunErrors"];
            this.lastRunSuccessfullySent = _data["lastRunSuccessfullySent"];
            this.lastRunTotal = _data["lastRunTotal"];
            this.dataRangeErrors = _data["dataRangeErrors"];
            this.dataRangeSuccessfullySent = _data["dataRangeSuccessfullySent"];
            this.dataRangeTotal = _data["dataRangeTotal"];
            this.dataRangeFrom = _data["dataRangeFrom"];
            this.dataRangeTo = _data["dataRangeTo"];
            this.noSummaryDataAvailable = _data["noSummaryDataAvailable"];
            this.lastRunSuccessRate = _data["lastRunSuccessRate"];
            this.dataRangeSuccessRate = _data["dataRangeSuccessRate"];
        }
    }

    static fromJS(data: any): DataPumpSummary {
        data = typeof data === 'object' ? data : {};
        let result = new DataPumpSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemEvents"] = this.systemEvents ? this.systemEvents.toJSON() : <any>undefined;
        data["lastRunErrors"] = this.lastRunErrors;
        data["lastRunSuccessfullySent"] = this.lastRunSuccessfullySent;
        data["lastRunTotal"] = this.lastRunTotal;
        data["dataRangeErrors"] = this.dataRangeErrors;
        data["dataRangeSuccessfullySent"] = this.dataRangeSuccessfullySent;
        data["dataRangeTotal"] = this.dataRangeTotal;
        data["dataRangeFrom"] = this.dataRangeFrom;
        data["dataRangeTo"] = this.dataRangeTo;
        data["noSummaryDataAvailable"] = this.noSummaryDataAvailable;
        data["lastRunSuccessRate"] = this.lastRunSuccessRate;
        data["dataRangeSuccessRate"] = this.dataRangeSuccessRate;
        return data;
    }
}

export interface IDataPumpSummary {
    systemEvents?: SystemEventPage | undefined;
    lastRunErrors?: number | undefined;
    lastRunSuccessfullySent?: number | undefined;
    lastRunTotal?: number | undefined;
    dataRangeErrors?: number | undefined;
    dataRangeSuccessfullySent?: number | undefined;
    dataRangeTotal?: number | undefined;
    dataRangeFrom?: string | undefined;
    dataRangeTo?: string | undefined;
    noSummaryDataAvailable?: boolean | undefined;
    lastRunSuccessRate?: number | undefined;
    dataRangeSuccessRate?: number | undefined;
}

export class SystemEventPage implements ISystemEventPage {
    pageItems?: SystemEvent[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ISystemEventPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(SystemEvent.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SystemEventPage {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEventPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISystemEventPage {
    pageItems?: SystemEvent[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class SystemEvent implements ISystemEvent {
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    type?: string | undefined;
    entryType?: SystemEventEntryType | undefined;
    eventId?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    machine?: string | undefined;

    constructor(data?: ISystemEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeGenerated = _data["timeGenerated"];
            this.timeGeneratedRelative = _data["timeGeneratedRelative"];
            this.type = _data["type"];
            this.entryType = _data["entryType"];
            this.eventId = _data["eventId"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.user = _data["user"];
            this.machine = _data["machine"];
        }
    }

    static fromJS(data: any): SystemEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeGenerated"] = this.timeGenerated;
        data["timeGeneratedRelative"] = this.timeGeneratedRelative;
        data["type"] = this.type;
        data["entryType"] = this.entryType;
        data["eventId"] = this.eventId;
        data["source"] = this.source;
        data["category"] = this.category;
        data["message"] = this.message;
        data["data"] = this.data;
        data["user"] = this.user;
        data["machine"] = this.machine;
        return data;
    }
}

export interface ISystemEvent {
    timeGenerated?: string | undefined;
    timeGeneratedRelative?: string | undefined;
    type?: string | undefined;
    entryType?: SystemEventEntryType | undefined;
    eventId?: number | undefined;
    source?: string | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    machine?: string | undefined;
}

export class DeviceDataParameters implements IDeviceDataParameters {
    fieldNames?: string[] | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    timeFormat?: string | undefined;
    cultureName?: string | undefined;
    line?: string | undefined;
    group?: string | undefined;

    constructor(data?: IDeviceDataParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            this.dataType = _data["dataType"];
            this.truncateData = _data["truncateData"];
            this.withDaylightSavingTime = _data["withDaylightSavingTime"];
            this.timeFormat = _data["timeFormat"];
            this.cultureName = _data["cultureName"];
            this.line = _data["line"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): DeviceDataParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDataParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dataType"] = this.dataType;
        data["truncateData"] = this.truncateData;
        data["withDaylightSavingTime"] = this.withDaylightSavingTime;
        data["timeFormat"] = this.timeFormat;
        data["cultureName"] = this.cultureName;
        data["line"] = this.line;
        data["group"] = this.group;
        return data;
    }
}

export interface IDeviceDataParameters {
    fieldNames?: string[] | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: number | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    timeFormat?: string | undefined;
    cultureName?: string | undefined;
    line?: string | undefined;
    group?: string | undefined;
}

export class SerializableDataTableContainer implements ISerializableDataTableContainer {
    readonly tables?: DataTable[] | undefined;

    constructor(data?: ISerializableDataTableContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["tables"])
                    (<any>this).tables!.push(DataTable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SerializableDataTableContainer {
        data = typeof data === 'object' ? data : {};
        let result = new SerializableDataTableContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISerializableDataTableContainer {
    tables?: DataTable[] | undefined;
}

export class DataTable implements IDataTable {
    caseSensitive?: boolean | undefined;
    readonly isInitialized?: boolean | undefined;
    remotingFormat?: DataTableRemotingFormat | undefined;
    readonly childRelations?: any[] | undefined;
    readonly columns?: any[] | undefined;
    readonly constraints?: any[] | undefined;
    readonly dataSet?: DataSet | undefined;
    readonly defaultView?: any[] | undefined;
    displayExpression?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    readonly hasErrors?: boolean | undefined;
    locale?: string | undefined;
    minimumCapacity?: number | undefined;
    readonly parentRelations?: any[] | undefined;
    primaryKey?: DataColumn[] | undefined;
    readonly rows?: any[] | undefined;
    tableName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    site?: ISite | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseSensitive = _data["caseSensitive"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.remotingFormat = _data["remotingFormat"];
            if (Array.isArray(_data["childRelations"])) {
                (<any>this).childRelations = [] as any;
                for (let item of _data["childRelations"])
                    (<any>this).childRelations!.push(item);
            }
            if (Array.isArray(_data["columns"])) {
                (<any>this).columns = [] as any;
                for (let item of _data["columns"])
                    (<any>this).columns!.push(item);
            }
            if (Array.isArray(_data["constraints"])) {
                (<any>this).constraints = [] as any;
                for (let item of _data["constraints"])
                    (<any>this).constraints!.push(item);
            }
            (<any>this).dataSet = _data["dataSet"] ? DataSet.fromJS(_data["dataSet"]) : <any>undefined;
            if (Array.isArray(_data["defaultView"])) {
                (<any>this).defaultView = [] as any;
                for (let item of _data["defaultView"])
                    (<any>this).defaultView!.push(item);
            }
            this.displayExpression = _data["displayExpression"];
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            this.locale = _data["locale"];
            this.minimumCapacity = _data["minimumCapacity"];
            if (Array.isArray(_data["parentRelations"])) {
                (<any>this).parentRelations = [] as any;
                for (let item of _data["parentRelations"])
                    (<any>this).parentRelations!.push(item);
            }
            if (Array.isArray(_data["primaryKey"])) {
                this.primaryKey = [] as any;
                for (let item of _data["primaryKey"])
                    this.primaryKey!.push(DataColumn.fromJS(item));
            }
            if (Array.isArray(_data["rows"])) {
                (<any>this).rows = [] as any;
                for (let item of _data["rows"])
                    (<any>this).rows!.push(item);
            }
            this.tableName = _data["tableName"];
            this.namespace = _data["namespace"];
            this.prefix = _data["prefix"];
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            (<any>this).container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataTable {
        data = typeof data === 'object' ? data : {};
        let result = new DataTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseSensitive"] = this.caseSensitive;
        data["isInitialized"] = this.isInitialized;
        data["remotingFormat"] = this.remotingFormat;
        if (Array.isArray(this.childRelations)) {
            data["childRelations"] = [];
            for (let item of this.childRelations)
                data["childRelations"].push(item);
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.constraints)) {
            data["constraints"] = [];
            for (let item of this.constraints)
                data["constraints"].push(item);
        }
        data["dataSet"] = this.dataSet ? this.dataSet.toJSON() : <any>undefined;
        if (Array.isArray(this.defaultView)) {
            data["defaultView"] = [];
            for (let item of this.defaultView)
                data["defaultView"].push(item);
        }
        data["displayExpression"] = this.displayExpression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["locale"] = this.locale;
        data["minimumCapacity"] = this.minimumCapacity;
        if (Array.isArray(this.parentRelations)) {
            data["parentRelations"] = [];
            for (let item of this.parentRelations)
                data["parentRelations"].push(item);
        }
        if (Array.isArray(this.primaryKey)) {
            data["primaryKey"] = [];
            for (let item of this.primaryKey)
                data["primaryKey"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item);
        }
        data["tableName"] = this.tableName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }
}

export interface IDataTable {
    caseSensitive?: boolean | undefined;
    isInitialized?: boolean | undefined;
    remotingFormat?: DataTableRemotingFormat | undefined;
    childRelations?: any[] | undefined;
    columns?: any[] | undefined;
    constraints?: any[] | undefined;
    dataSet?: DataSet | undefined;
    defaultView?: any[] | undefined;
    displayExpression?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    hasErrors?: boolean | undefined;
    locale?: string | undefined;
    minimumCapacity?: number | undefined;
    parentRelations?: any[] | undefined;
    primaryKey?: DataColumn[] | undefined;
    rows?: any[] | undefined;
    tableName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    site?: ISite | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class DataSet implements IDataSet {
    remotingFormat?: DataSetRemotingFormat | undefined;
    schemaSerializationMode?: DataSetSchemaSerializationMode | undefined;
    caseSensitive?: boolean | undefined;
    readonly defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean | undefined;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    readonly hasErrors?: boolean | undefined;
    readonly isInitialized?: boolean | undefined;
    locale?: string | undefined;
    site?: ISite | undefined;
    readonly relations?: any[] | undefined;
    readonly tables?: any[] | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.remotingFormat = _data["remotingFormat"];
            this.schemaSerializationMode = _data["schemaSerializationMode"];
            this.caseSensitive = _data["caseSensitive"];
            if (Array.isArray(_data["defaultViewManager"])) {
                (<any>this).defaultViewManager = [] as any;
                for (let item of _data["defaultViewManager"])
                    (<any>this).defaultViewManager!.push(item);
            }
            this.enforceConstraints = _data["enforceConstraints"];
            this.dataSetName = _data["dataSetName"];
            this.namespace = _data["namespace"];
            this.prefix = _data["prefix"];
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["extendedProperties"][key];
                }
            }
            (<any>this).hasErrors = _data["hasErrors"];
            (<any>this).isInitialized = _data["isInitialized"];
            this.locale = _data["locale"];
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            if (Array.isArray(_data["relations"])) {
                (<any>this).relations = [] as any;
                for (let item of _data["relations"])
                    (<any>this).relations!.push(item);
            }
            if (Array.isArray(_data["tables"])) {
                (<any>this).tables = [] as any;
                for (let item of _data["tables"])
                    (<any>this).tables!.push(item);
            }
            (<any>this).container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataSet {
        data = typeof data === 'object' ? data : {};
        let result = new DataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remotingFormat"] = this.remotingFormat;
        data["schemaSerializationMode"] = this.schemaSerializationMode;
        data["caseSensitive"] = this.caseSensitive;
        if (Array.isArray(this.defaultViewManager)) {
            data["defaultViewManager"] = [];
            for (let item of this.defaultViewManager)
                data["defaultViewManager"].push(item);
        }
        data["enforceConstraints"] = this.enforceConstraints;
        data["dataSetName"] = this.dataSetName;
        data["namespace"] = this.namespace;
        data["prefix"] = this.prefix;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["hasErrors"] = this.hasErrors;
        data["isInitialized"] = this.isInitialized;
        data["locale"] = this.locale;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        if (Array.isArray(this.relations)) {
            data["relations"] = [];
            for (let item of this.relations)
                data["relations"].push(item);
        }
        if (Array.isArray(this.tables)) {
            data["tables"] = [];
            for (let item of this.tables)
                data["tables"].push(item);
        }
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }
}

export interface IDataSet {
    remotingFormat?: DataSetRemotingFormat | undefined;
    schemaSerializationMode?: DataSetSchemaSerializationMode | undefined;
    caseSensitive?: boolean | undefined;
    defaultViewManager?: any[] | undefined;
    enforceConstraints?: boolean | undefined;
    dataSetName?: string | undefined;
    namespace?: string | undefined;
    prefix?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    hasErrors?: boolean | undefined;
    isInitialized?: boolean | undefined;
    locale?: string | undefined;
    site?: ISite | undefined;
    relations?: any[] | undefined;
    tables?: any[] | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class DataColumn implements IDataColumn {
    allowDBNull?: boolean | undefined;
    autoIncrement?: boolean | undefined;
    autoIncrementSeed?: number | undefined;
    autoIncrementStep?: number | undefined;
    caption?: string | undefined;
    columnName?: string | undefined;
    prefix?: string | undefined;
    dataType?: string | undefined;
    dateTimeMode?: DataColumnDateTimeMode | undefined;
    defaultValue?: any | undefined;
    expression?: string | undefined;
    readonly extendedProperties?: { [key: string]: any; } | undefined;
    maxLength?: number | undefined;
    namespace?: string | undefined;
    readonly ordinal?: number | undefined;
    readOnly?: boolean | undefined;
    readonly table?: DataTable | undefined;
    unique?: boolean | undefined;
    columnMapping?: DataColumnColumnMapping | undefined;
    site?: ISite | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;

    constructor(data?: IDataColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowDBNull = _data["allowDBNull"];
            this.autoIncrement = _data["autoIncrement"];
            this.autoIncrementSeed = _data["autoIncrementSeed"];
            this.autoIncrementStep = _data["autoIncrementStep"];
            this.caption = _data["caption"];
            this.columnName = _data["columnName"];
            this.prefix = _data["prefix"];
            this.dataType = _data["dataType"];
            this.dateTimeMode = _data["dateTimeMode"];
            this.defaultValue = _data["defaultValue"];
            this.expression = _data["expression"];
            if (_data["extendedProperties"]) {
                (<any>this).extendedProperties = {} as any;
                for (let key in _data["extendedProperties"]) {
                    if (_data["extendedProperties"].hasOwnProperty(key))
                        (<any>(<any>this).extendedProperties)![key] = _data["extendedProperties"][key];
                }
            }
            this.maxLength = _data["maxLength"];
            this.namespace = _data["namespace"];
            (<any>this).ordinal = _data["ordinal"];
            this.readOnly = _data["readOnly"];
            (<any>this).table = _data["table"] ? DataTable.fromJS(_data["table"]) : <any>undefined;
            this.unique = _data["unique"];
            this.columnMapping = _data["columnMapping"];
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
            (<any>this).container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
        }
    }

    static fromJS(data: any): DataColumn {
        data = typeof data === 'object' ? data : {};
        let result = new DataColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowDBNull"] = this.allowDBNull;
        data["autoIncrement"] = this.autoIncrement;
        data["autoIncrementSeed"] = this.autoIncrementSeed;
        data["autoIncrementStep"] = this.autoIncrementStep;
        data["caption"] = this.caption;
        data["columnName"] = this.columnName;
        data["prefix"] = this.prefix;
        data["dataType"] = this.dataType;
        data["dateTimeMode"] = this.dateTimeMode;
        data["defaultValue"] = this.defaultValue;
        data["expression"] = this.expression;
        if (this.extendedProperties) {
            data["extendedProperties"] = {};
            for (let key in this.extendedProperties) {
                if (this.extendedProperties.hasOwnProperty(key))
                    (<any>data["extendedProperties"])[key] = (<any>this.extendedProperties)[key];
            }
        }
        data["maxLength"] = this.maxLength;
        data["namespace"] = this.namespace;
        data["ordinal"] = this.ordinal;
        data["readOnly"] = this.readOnly;
        data["table"] = this.table ? this.table.toJSON() : <any>undefined;
        data["unique"] = this.unique;
        data["columnMapping"] = this.columnMapping;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        return data;
    }
}

export interface IDataColumn {
    allowDBNull?: boolean | undefined;
    autoIncrement?: boolean | undefined;
    autoIncrementSeed?: number | undefined;
    autoIncrementStep?: number | undefined;
    caption?: string | undefined;
    columnName?: string | undefined;
    prefix?: string | undefined;
    dataType?: string | undefined;
    dateTimeMode?: DataColumnDateTimeMode | undefined;
    defaultValue?: any | undefined;
    expression?: string | undefined;
    extendedProperties?: { [key: string]: any; } | undefined;
    maxLength?: number | undefined;
    namespace?: string | undefined;
    ordinal?: number | undefined;
    readOnly?: boolean | undefined;
    table?: DataTable | undefined;
    unique?: boolean | undefined;
    columnMapping?: DataColumnColumnMapping | undefined;
    site?: ISite | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
}

export class ISite implements IISite {
    readonly component?: IComponent | undefined;
    readonly container?: IContainer | undefined;
    readonly designMode?: boolean | undefined;
    name?: string | undefined;

    constructor(data?: IISite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).component = _data["component"] ? IComponent.fromJS(_data["component"]) : <any>undefined;
            (<any>this).container = _data["container"] ? IContainer.fromJS(_data["container"]) : <any>undefined;
            (<any>this).designMode = _data["designMode"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ISite {
        data = typeof data === 'object' ? data : {};
        let result = new ISite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["designMode"] = this.designMode;
        data["name"] = this.name;
        return data;
    }
}

export interface IISite {
    component?: IComponent | undefined;
    container?: IContainer | undefined;
    designMode?: boolean | undefined;
    name?: string | undefined;
}

export class IContainer implements IIContainer {
    readonly components?: any[] | undefined;

    constructor(data?: IIContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["components"])
                    (<any>this).components!.push(item);
            }
        }
    }

    static fromJS(data: any): IContainer {
        data = typeof data === 'object' ? data : {};
        let result = new IContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item);
        }
        return data;
    }
}

export interface IIContainer {
    components?: any[] | undefined;
}

export class IComponent implements IIComponent {
    site?: ISite | undefined;

    constructor(data?: IIComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.site = _data["site"] ? ISite.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IComponent {
        data = typeof data === 'object' ? data : {};
        let result = new IComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIComponent {
    site?: ISite | undefined;
}

export class DeviceChartData implements IDeviceChartData {
    fieldNames?: string[] | undefined;
    timeFormat?: string | undefined;
    placeId?: number | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: DeviceChartDataDataType | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    culture?: string | undefined;
    line?: string | undefined;
    leaveDateAsItIs?: boolean | undefined;
    userAccess?: boolean | undefined;
    data?: any | undefined;
    sessionId?: string | undefined;

    constructor(data?: IDeviceChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            this.timeFormat = _data["timeFormat"];
            this.placeId = _data["placeId"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            this.dataType = _data["dataType"];
            this.truncateData = _data["truncateData"];
            this.withDaylightSavingTime = _data["withDaylightSavingTime"];
            this.culture = _data["culture"];
            this.line = _data["line"];
            this.leaveDateAsItIs = _data["leaveDateAsItIs"];
            this.userAccess = _data["userAccess"];
            this.data = _data["data"];
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): DeviceChartData {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        data["timeFormat"] = this.timeFormat;
        data["placeId"] = this.placeId;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        data["dataType"] = this.dataType;
        data["truncateData"] = this.truncateData;
        data["withDaylightSavingTime"] = this.withDaylightSavingTime;
        data["culture"] = this.culture;
        data["line"] = this.line;
        data["leaveDateAsItIs"] = this.leaveDateAsItIs;
        data["userAccess"] = this.userAccess;
        data["data"] = this.data;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface IDeviceChartData {
    fieldNames?: string[] | undefined;
    timeFormat?: string | undefined;
    placeId?: number | undefined;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    dataType?: DeviceChartDataDataType | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    culture?: string | undefined;
    line?: string | undefined;
    leaveDateAsItIs?: boolean | undefined;
    userAccess?: boolean | undefined;
    data?: any | undefined;
    sessionId?: string | undefined;
}

export class AveDroidDeviceData implements IAveDroidDeviceData {
    place?: Place | undefined;
    group?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;

    constructor(data?: IAveDroidDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.place = _data["place"] ? Place.fromJS(_data["place"]) : <any>undefined;
            this.group = _data["group"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): AveDroidDeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new AveDroidDeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["group"] = this.group;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

export interface IAveDroidDeviceData {
    place?: Place | undefined;
    group?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;
}

export class Place implements IPlace {
    id?: number | undefined;
    eic?: string | undefined;
    customerName?: string | undefined;
    placeName?: string | undefined;
    payerName?: string | undefined;
    payerId?: string | undefined;
    customerId?: string | undefined;
    placeId?: string | undefined;
    deviceLocation?: string | undefined;
    terminated?: boolean | undefined;
    region?: string | undefined;
    regionId?: number | undefined;
    connectionMethod?: string | undefined;
    purchaseCategory?: string | undefined;
    convertCoefficient?: number | undefined;
    deviceType?: string | undefined;
    identificationNumber?: string | undefined;
    lastData?: string | undefined;
    deviceSerialNumber?: string | undefined;
    placeStreet?: string | undefined;
    payerStreet?: string | undefined;
    placeCity?: string | undefined;
    payerCity?: string | undefined;
    placeZipCode?: string | undefined;
    payerZipCode?: string | undefined;
    dealer?: string | undefined;
    readingCategory?: string | undefined;
    validatedBy?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validationNote?: string | undefined;
    gps?: string | undefined;
    device?: number | undefined;
    readRequestStatus?: number | undefined;
    readDescription?: string | undefined;
    note?: string | undefined;
    group?: string | undefined;
    workplace?: string | undefined;
    hasTimeWindows?: boolean | undefined;
    hasBattery?: boolean | undefined;
    hasGasComposition?: boolean | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    dailyData?: boolean | undefined;
    scadaId?: string | undefined;
    parentDevice?: string | undefined;

    constructor(data?: IPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eic = _data["eic"];
            this.customerName = _data["customerName"];
            this.placeName = _data["placeName"];
            this.payerName = _data["payerName"];
            this.payerId = _data["payerId"];
            this.customerId = _data["customerId"];
            this.placeId = _data["placeId"];
            this.deviceLocation = _data["deviceLocation"];
            this.terminated = _data["terminated"];
            this.region = _data["region"];
            this.regionId = _data["regionId"];
            this.connectionMethod = _data["connectionMethod"];
            this.purchaseCategory = _data["purchaseCategory"];
            this.convertCoefficient = _data["convertCoefficient"];
            this.deviceType = _data["deviceType"];
            this.identificationNumber = _data["identificationNumber"];
            this.lastData = _data["lastData"];
            this.deviceSerialNumber = _data["deviceSerialNumber"];
            this.placeStreet = _data["placeStreet"];
            this.payerStreet = _data["payerStreet"];
            this.placeCity = _data["placeCity"];
            this.payerCity = _data["payerCity"];
            this.placeZipCode = _data["placeZipCode"];
            this.payerZipCode = _data["payerZipCode"];
            this.dealer = _data["dealer"];
            this.readingCategory = _data["readingCategory"];
            this.validatedBy = _data["validatedBy"];
            this.validatedTill = _data["validatedTill"] ? new Date(_data["validatedTill"].toString()) : <any>undefined;
            this.isDataValidated = _data["isDataValidated"];
            this.validationNote = _data["validationNote"];
            this.gps = _data["gps"];
            this.device = _data["device"];
            this.readRequestStatus = _data["readRequestStatus"];
            this.readDescription = _data["readDescription"];
            this.note = _data["note"];
            this.group = _data["group"];
            this.workplace = _data["workplace"];
            this.hasTimeWindows = _data["hasTimeWindows"];
            this.hasBattery = _data["hasBattery"];
            this.hasGasComposition = _data["hasGasComposition"];
            this.batteryCapacity = _data["batteryCapacity"];
            this.batteryVoltage = _data["batteryVoltage"];
            this.dailyData = _data["dailyData"];
            this.scadaId = _data["scadaId"];
            this.parentDevice = _data["parentDevice"];
        }
    }

    static fromJS(data: any): Place {
        data = typeof data === 'object' ? data : {};
        let result = new Place();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eic"] = this.eic;
        data["customerName"] = this.customerName;
        data["placeName"] = this.placeName;
        data["payerName"] = this.payerName;
        data["payerId"] = this.payerId;
        data["customerId"] = this.customerId;
        data["placeId"] = this.placeId;
        data["deviceLocation"] = this.deviceLocation;
        data["terminated"] = this.terminated;
        data["region"] = this.region;
        data["regionId"] = this.regionId;
        data["connectionMethod"] = this.connectionMethod;
        data["purchaseCategory"] = this.purchaseCategory;
        data["convertCoefficient"] = this.convertCoefficient;
        data["deviceType"] = this.deviceType;
        data["identificationNumber"] = this.identificationNumber;
        data["lastData"] = this.lastData;
        data["deviceSerialNumber"] = this.deviceSerialNumber;
        data["placeStreet"] = this.placeStreet;
        data["payerStreet"] = this.payerStreet;
        data["placeCity"] = this.placeCity;
        data["payerCity"] = this.payerCity;
        data["placeZipCode"] = this.placeZipCode;
        data["payerZipCode"] = this.payerZipCode;
        data["dealer"] = this.dealer;
        data["readingCategory"] = this.readingCategory;
        data["validatedBy"] = this.validatedBy;
        data["validatedTill"] = this.validatedTill ? this.validatedTill.toISOString() : <any>undefined;
        data["isDataValidated"] = this.isDataValidated;
        data["validationNote"] = this.validationNote;
        data["gps"] = this.gps;
        data["device"] = this.device;
        data["readRequestStatus"] = this.readRequestStatus;
        data["readDescription"] = this.readDescription;
        data["note"] = this.note;
        data["group"] = this.group;
        data["workplace"] = this.workplace;
        data["hasTimeWindows"] = this.hasTimeWindows;
        data["hasBattery"] = this.hasBattery;
        data["hasGasComposition"] = this.hasGasComposition;
        data["batteryCapacity"] = this.batteryCapacity;
        data["batteryVoltage"] = this.batteryVoltage;
        data["dailyData"] = this.dailyData;
        data["scadaId"] = this.scadaId;
        data["parentDevice"] = this.parentDevice;
        return data;
    }
}

export interface IPlace {
    id?: number | undefined;
    eic?: string | undefined;
    customerName?: string | undefined;
    placeName?: string | undefined;
    payerName?: string | undefined;
    payerId?: string | undefined;
    customerId?: string | undefined;
    placeId?: string | undefined;
    deviceLocation?: string | undefined;
    terminated?: boolean | undefined;
    region?: string | undefined;
    regionId?: number | undefined;
    connectionMethod?: string | undefined;
    purchaseCategory?: string | undefined;
    convertCoefficient?: number | undefined;
    deviceType?: string | undefined;
    identificationNumber?: string | undefined;
    lastData?: string | undefined;
    deviceSerialNumber?: string | undefined;
    placeStreet?: string | undefined;
    payerStreet?: string | undefined;
    placeCity?: string | undefined;
    payerCity?: string | undefined;
    placeZipCode?: string | undefined;
    payerZipCode?: string | undefined;
    dealer?: string | undefined;
    readingCategory?: string | undefined;
    validatedBy?: string | undefined;
    validatedTill?: Date | undefined;
    isDataValidated?: boolean | undefined;
    validationNote?: string | undefined;
    gps?: string | undefined;
    device?: number | undefined;
    readRequestStatus?: number | undefined;
    readDescription?: string | undefined;
    note?: string | undefined;
    group?: string | undefined;
    workplace?: string | undefined;
    hasTimeWindows?: boolean | undefined;
    hasBattery?: boolean | undefined;
    hasGasComposition?: boolean | undefined;
    batteryCapacity?: number | undefined;
    batteryVoltage?: number | undefined;
    dailyData?: boolean | undefined;
    scadaId?: string | undefined;
    parentDevice?: string | undefined;
}

export class MiniWebClientDeviceData implements IMiniWebClientDeviceData {
    place?: Place | undefined;
    line?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;

    constructor(data?: IMiniWebClientDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.place = _data["place"] ? Place.fromJS(_data["place"]) : <any>undefined;
            this.line = _data["line"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
            if (Array.isArray(_data["fieldNames"])) {
                this.fieldNames = [] as any;
                for (let item of _data["fieldNames"])
                    this.fieldNames!.push(item);
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): MiniWebClientDeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new MiniWebClientDeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["place"] = this.place ? this.place.toJSON() : <any>undefined;
        data["line"] = this.line;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        if (Array.isArray(this.fieldNames)) {
            data["fieldNames"] = [];
            for (let item of this.fieldNames)
                data["fieldNames"].push(item);
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data;
    }
}

export interface IMiniWebClientDeviceData {
    place?: Place | undefined;
    line?: string | undefined;
    columns?: string[] | undefined;
    fieldNames?: string[] | undefined;
    data?: string[][] | undefined;
}

export class DataValidationRequest implements IDataValidationRequest {
    placesId!: number[];
    till?: Date | undefined;
    note?: string | undefined;

    constructor(data?: IDataValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.placesId = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["placesId"])) {
                this.placesId = [] as any;
                for (let item of _data["placesId"])
                    this.placesId!.push(item);
            }
            this.till = _data["till"] ? new Date(_data["till"].toString()) : <any>undefined;
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): DataValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.placesId)) {
            data["placesId"] = [];
            for (let item of this.placesId)
                data["placesId"].push(item);
        }
        data["till"] = this.till ? this.till.toISOString() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface IDataValidationRequest {
    placesId: number[];
    till?: Date | undefined;
    note?: string | undefined;
}

export class Dealer implements IDealer {
    id?: number | undefined;
    name?: string | undefined;
    identificationCode?: string | undefined;
    identificationCodeHash?: number | undefined;
    color?: string | undefined;

    constructor(data?: IDealer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.identificationCode = _data["identificationCode"];
            this.identificationCodeHash = _data["identificationCodeHash"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): Dealer {
        data = typeof data === 'object' ? data : {};
        let result = new Dealer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["identificationCode"] = this.identificationCode;
        data["identificationCodeHash"] = this.identificationCodeHash;
        data["color"] = this.color;
        return data;
    }
}

export interface IDealer {
    id?: number | undefined;
    name?: string | undefined;
    identificationCode?: string | undefined;
    identificationCodeHash?: number | undefined;
    color?: string | undefined;
}

export class DriverCommunicationChannel implements IDriverCommunicationChannel {
    id?: number | undefined;
    channelGuid?: string | undefined;
    channelName?: string | undefined;
    channelType?: DriverCommunicationChannelChannelType | undefined;
    channelState?: DriverCommunicationChannelChannelState | undefined;
    isBlocked?: boolean | undefined;
    isInError?: boolean | undefined;
    productivityPercentage?: number | undefined;
    total?: number | undefined;
    ok?: number | undefined;
    errors?: number | undefined;

    constructor(data?: IDriverCommunicationChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.channelGuid = _data["channelGuid"];
            this.channelName = _data["channelName"];
            this.channelType = _data["channelType"];
            this.channelState = _data["channelState"];
            this.isBlocked = _data["isBlocked"];
            this.isInError = _data["isInError"];
            this.productivityPercentage = _data["productivityPercentage"];
            this.total = _data["total"];
            this.ok = _data["ok"];
            this.errors = _data["errors"];
        }
    }

    static fromJS(data: any): DriverCommunicationChannel {
        data = typeof data === 'object' ? data : {};
        let result = new DriverCommunicationChannel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["channelGuid"] = this.channelGuid;
        data["channelName"] = this.channelName;
        data["channelType"] = this.channelType;
        data["channelState"] = this.channelState;
        data["isBlocked"] = this.isBlocked;
        data["isInError"] = this.isInError;
        data["productivityPercentage"] = this.productivityPercentage;
        data["total"] = this.total;
        data["ok"] = this.ok;
        data["errors"] = this.errors;
        return data;
    }
}

export interface IDriverCommunicationChannel {
    id?: number | undefined;
    channelGuid?: string | undefined;
    channelName?: string | undefined;
    channelType?: DriverCommunicationChannelChannelType | undefined;
    channelState?: DriverCommunicationChannelChannelState | undefined;
    isBlocked?: boolean | undefined;
    isInError?: boolean | undefined;
    productivityPercentage?: number | undefined;
    total?: number | undefined;
    ok?: number | undefined;
    errors?: number | undefined;
}

export class CallLogsPage implements ICallLogsPage {
    pageItems?: CallLogItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ICallLogsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(CallLogItem.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CallLogsPage {
        data = typeof data === 'object' ? data : {};
        let result = new CallLogsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ICallLogsPage {
    pageItems?: CallLogItem[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class DeviceTagItem implements IDeviceTagItem {
    id?: number | undefined;
    dataType?: string | undefined;
    dataCharacter?: string | undefined;
    dataCharacterDescription?: string | undefined;
    aggregationType?: string | undefined;
    aggregationTypeDescription?: string | undefined;
    period?: string | undefined;
    periodDescription?: string | undefined;
    address?: number | undefined;
    decimalPlaceCount?: number | undefined;
    convertCoefficient?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    units?: string | undefined;
    group?: string | undefined;
    nameWithUnits?: string | undefined;
    fieldName?: string | undefined;
    diffTagFieldName?: string | undefined;
    visualPosition?: number | undefined;
    lowCriticalLimit?: number | undefined;
    highCriticalLimit?: number | undefined;
    lowWarningLimit?: number | undefined;
    highWarningLimit?: number | undefined;
    isLowCriticalLimitEnabled?: boolean | undefined;
    isHighCriticalLimitEnabled?: boolean | undefined;
    isLowWarningLimitEnabled?: boolean | undefined;
    isHighWarningLimitEnabled?: boolean | undefined;
    enabled?: boolean | undefined;
    visible?: boolean | undefined;
    isComputed?: boolean | undefined;
    isReadOnly?: boolean | undefined;
    computedVariableAsText?: string | undefined;
    isNumber?: boolean | undefined;
    constantValue?: string | undefined;

    constructor(data?: IDeviceTagItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dataType = _data["dataType"];
            this.dataCharacter = _data["dataCharacter"];
            this.dataCharacterDescription = _data["dataCharacterDescription"];
            this.aggregationType = _data["aggregationType"];
            this.aggregationTypeDescription = _data["aggregationTypeDescription"];
            this.period = _data["period"];
            this.periodDescription = _data["periodDescription"];
            this.address = _data["address"];
            this.decimalPlaceCount = _data["decimalPlaceCount"];
            this.convertCoefficient = _data["convertCoefficient"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.units = _data["units"];
            this.group = _data["group"];
            this.nameWithUnits = _data["nameWithUnits"];
            this.fieldName = _data["fieldName"];
            this.diffTagFieldName = _data["diffTagFieldName"];
            this.visualPosition = _data["visualPosition"];
            this.lowCriticalLimit = _data["lowCriticalLimit"];
            this.highCriticalLimit = _data["highCriticalLimit"];
            this.lowWarningLimit = _data["lowWarningLimit"];
            this.highWarningLimit = _data["highWarningLimit"];
            this.isLowCriticalLimitEnabled = _data["isLowCriticalLimitEnabled"];
            this.isHighCriticalLimitEnabled = _data["isHighCriticalLimitEnabled"];
            this.isLowWarningLimitEnabled = _data["isLowWarningLimitEnabled"];
            this.isHighWarningLimitEnabled = _data["isHighWarningLimitEnabled"];
            this.enabled = _data["enabled"];
            this.visible = _data["visible"];
            this.isComputed = _data["isComputed"];
            this.isReadOnly = _data["isReadOnly"];
            this.computedVariableAsText = _data["computedVariableAsText"];
            this.isNumber = _data["isNumber"];
            this.constantValue = _data["constantValue"];
        }
    }

    static fromJS(data: any): DeviceTagItem {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTagItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dataType"] = this.dataType;
        data["dataCharacter"] = this.dataCharacter;
        data["dataCharacterDescription"] = this.dataCharacterDescription;
        data["aggregationType"] = this.aggregationType;
        data["aggregationTypeDescription"] = this.aggregationTypeDescription;
        data["period"] = this.period;
        data["periodDescription"] = this.periodDescription;
        data["address"] = this.address;
        data["decimalPlaceCount"] = this.decimalPlaceCount;
        data["convertCoefficient"] = this.convertCoefficient;
        data["name"] = this.name;
        data["description"] = this.description;
        data["units"] = this.units;
        data["group"] = this.group;
        data["nameWithUnits"] = this.nameWithUnits;
        data["fieldName"] = this.fieldName;
        data["diffTagFieldName"] = this.diffTagFieldName;
        data["visualPosition"] = this.visualPosition;
        data["lowCriticalLimit"] = this.lowCriticalLimit;
        data["highCriticalLimit"] = this.highCriticalLimit;
        data["lowWarningLimit"] = this.lowWarningLimit;
        data["highWarningLimit"] = this.highWarningLimit;
        data["isLowCriticalLimitEnabled"] = this.isLowCriticalLimitEnabled;
        data["isHighCriticalLimitEnabled"] = this.isHighCriticalLimitEnabled;
        data["isLowWarningLimitEnabled"] = this.isLowWarningLimitEnabled;
        data["isHighWarningLimitEnabled"] = this.isHighWarningLimitEnabled;
        data["enabled"] = this.enabled;
        data["visible"] = this.visible;
        data["isComputed"] = this.isComputed;
        data["isReadOnly"] = this.isReadOnly;
        data["computedVariableAsText"] = this.computedVariableAsText;
        data["isNumber"] = this.isNumber;
        data["constantValue"] = this.constantValue;
        return data;
    }
}

export interface IDeviceTagItem {
    id?: number | undefined;
    dataType?: string | undefined;
    dataCharacter?: string | undefined;
    dataCharacterDescription?: string | undefined;
    aggregationType?: string | undefined;
    aggregationTypeDescription?: string | undefined;
    period?: string | undefined;
    periodDescription?: string | undefined;
    address?: number | undefined;
    decimalPlaceCount?: number | undefined;
    convertCoefficient?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    units?: string | undefined;
    group?: string | undefined;
    nameWithUnits?: string | undefined;
    fieldName?: string | undefined;
    diffTagFieldName?: string | undefined;
    visualPosition?: number | undefined;
    lowCriticalLimit?: number | undefined;
    highCriticalLimit?: number | undefined;
    lowWarningLimit?: number | undefined;
    highWarningLimit?: number | undefined;
    isLowCriticalLimitEnabled?: boolean | undefined;
    isHighCriticalLimitEnabled?: boolean | undefined;
    isLowWarningLimitEnabled?: boolean | undefined;
    isHighWarningLimitEnabled?: boolean | undefined;
    enabled?: boolean | undefined;
    visible?: boolean | undefined;
    isComputed?: boolean | undefined;
    isReadOnly?: boolean | undefined;
    computedVariableAsText?: string | undefined;
    isNumber?: boolean | undefined;
    constantValue?: string | undefined;
}

export class DeviceAlarmItem implements IDeviceAlarmItem {
    id?: number | undefined;
    tagId?: number | undefined;
    tagFieldName?: string | undefined;
    alarmId?: number | undefined;
    category?: string | undefined;
    text?: string | undefined;
    enabled?: boolean | undefined;
    acknowledgementRequired?: boolean | undefined;
    condition?: DeviceAlarmItemCondition | undefined;
    conditionDescription?: string | undefined;
    rangeFrom?: number | undefined;
    rangeTo?: number | undefined;

    constructor(data?: IDeviceAlarmItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tagId = _data["tagId"];
            this.tagFieldName = _data["tagFieldName"];
            this.alarmId = _data["alarmId"];
            this.category = _data["category"];
            this.text = _data["text"];
            this.enabled = _data["enabled"];
            this.acknowledgementRequired = _data["acknowledgementRequired"];
            this.condition = _data["condition"];
            this.conditionDescription = _data["conditionDescription"];
            this.rangeFrom = _data["rangeFrom"];
            this.rangeTo = _data["rangeTo"];
        }
    }

    static fromJS(data: any): DeviceAlarmItem {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAlarmItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tagId"] = this.tagId;
        data["tagFieldName"] = this.tagFieldName;
        data["alarmId"] = this.alarmId;
        data["category"] = this.category;
        data["text"] = this.text;
        data["enabled"] = this.enabled;
        data["acknowledgementRequired"] = this.acknowledgementRequired;
        data["condition"] = this.condition;
        data["conditionDescription"] = this.conditionDescription;
        data["rangeFrom"] = this.rangeFrom;
        data["rangeTo"] = this.rangeTo;
        return data;
    }
}

export interface IDeviceAlarmItem {
    id?: number | undefined;
    tagId?: number | undefined;
    tagFieldName?: string | undefined;
    alarmId?: number | undefined;
    category?: string | undefined;
    text?: string | undefined;
    enabled?: boolean | undefined;
    acknowledgementRequired?: boolean | undefined;
    condition?: DeviceAlarmItemCondition | undefined;
    conditionDescription?: string | undefined;
    rangeFrom?: number | undefined;
    rangeTo?: number | undefined;
}

export class ConnectionType implements IConnectionType {
    id?: number | undefined;
    description?: string | undefined;

    constructor(data?: IConnectionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ConnectionType {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data;
    }
}

export interface IConnectionType {
    id?: number | undefined;
    description?: string | undefined;
}

export class DeviceParameters implements IDeviceParameters {
    baseParameters?: DeviceParameter[] | undefined;
    extendedParameters?: DeviceParameter[] | undefined;

    constructor(data?: IDeviceParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["baseParameters"])) {
                this.baseParameters = [] as any;
                for (let item of _data["baseParameters"])
                    this.baseParameters!.push(DeviceParameter.fromJS(item));
            }
            if (Array.isArray(_data["extendedParameters"])) {
                this.extendedParameters = [] as any;
                for (let item of _data["extendedParameters"])
                    this.extendedParameters!.push(DeviceParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.baseParameters)) {
            data["baseParameters"] = [];
            for (let item of this.baseParameters)
                data["baseParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.extendedParameters)) {
            data["extendedParameters"] = [];
            for (let item of this.extendedParameters)
                data["extendedParameters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDeviceParameters {
    baseParameters?: DeviceParameter[] | undefined;
    extendedParameters?: DeviceParameter[] | undefined;
}

export class DeviceParameter implements IDeviceParameter {
    fieldName?: string | undefined;
    description?: string | undefined;
    dataType?: string | undefined;
    value?: string | undefined;
    isReadOnly?: boolean | undefined;

    constructor(data?: IDeviceParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.value = _data["value"];
            this.isReadOnly = _data["isReadOnly"];
        }
    }

    static fromJS(data: any): DeviceParameter {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["value"] = this.value;
        data["isReadOnly"] = this.isReadOnly;
        return data;
    }
}

export interface IDeviceParameter {
    fieldName?: string | undefined;
    description?: string | undefined;
    dataType?: string | undefined;
    value?: string | undefined;
    isReadOnly?: boolean | undefined;
}

export class BatteryStatus implements IBatteryStatus {
    batteryLevel?: number | undefined;
    batteryVoltage?: number | undefined;
    timestamp?: Date | undefined;
    levelHistory?: { [key: string]: number; } | undefined;
    voltageHistory?: { [key: string]: number; } | undefined;

    constructor(data?: IBatteryStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.batteryLevel = _data["batteryLevel"];
            this.batteryVoltage = _data["batteryVoltage"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (_data["levelHistory"]) {
                this.levelHistory = {} as any;
                for (let key in _data["levelHistory"]) {
                    if (_data["levelHistory"].hasOwnProperty(key))
                        (<any>this.levelHistory)![key] = _data["levelHistory"][key];
                }
            }
            if (_data["voltageHistory"]) {
                this.voltageHistory = {} as any;
                for (let key in _data["voltageHistory"]) {
                    if (_data["voltageHistory"].hasOwnProperty(key))
                        (<any>this.voltageHistory)![key] = _data["voltageHistory"][key];
                }
            }
        }
    }

    static fromJS(data: any): BatteryStatus {
        data = typeof data === 'object' ? data : {};
        let result = new BatteryStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batteryLevel"] = this.batteryLevel;
        data["batteryVoltage"] = this.batteryVoltage;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (this.levelHistory) {
            data["levelHistory"] = {};
            for (let key in this.levelHistory) {
                if (this.levelHistory.hasOwnProperty(key))
                    (<any>data["levelHistory"])[key] = (<any>this.levelHistory)[key];
            }
        }
        if (this.voltageHistory) {
            data["voltageHistory"] = {};
            for (let key in this.voltageHistory) {
                if (this.voltageHistory.hasOwnProperty(key))
                    (<any>data["voltageHistory"])[key] = (<any>this.voltageHistory)[key];
            }
        }
        return data;
    }
}

export interface IBatteryStatus {
    batteryLevel?: number | undefined;
    batteryVoltage?: number | undefined;
    timestamp?: Date | undefined;
    levelHistory?: { [key: string]: number; } | undefined;
    voltageHistory?: { [key: string]: number; } | undefined;
}

export class LastReadingInfo implements ILastReadingInfo {
    lastReadingTimestamp?: Date | undefined;
    lastDataTimestamp?: Date | undefined;
    result?: string | undefined;
    errorText?: string | undefined;
    usedConnection?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;

    constructor(data?: ILastReadingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastReadingTimestamp = _data["lastReadingTimestamp"] ? new Date(_data["lastReadingTimestamp"].toString()) : <any>undefined;
            this.lastDataTimestamp = _data["lastDataTimestamp"] ? new Date(_data["lastDataTimestamp"].toString()) : <any>undefined;
            this.result = _data["result"];
            this.errorText = _data["errorText"];
            this.usedConnection = _data["usedConnection"];
            this.schedulerName = _data["schedulerName"];
            this.schedulerTime = _data["schedulerTime"] ? new Date(_data["schedulerTime"].toString()) : <any>undefined;
            this.manualReadingTime = _data["manualReadingTime"] ? new Date(_data["manualReadingTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LastReadingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LastReadingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastReadingTimestamp"] = this.lastReadingTimestamp ? this.lastReadingTimestamp.toISOString() : <any>undefined;
        data["lastDataTimestamp"] = this.lastDataTimestamp ? this.lastDataTimestamp.toISOString() : <any>undefined;
        data["result"] = this.result;
        data["errorText"] = this.errorText;
        data["usedConnection"] = this.usedConnection;
        data["schedulerName"] = this.schedulerName;
        data["schedulerTime"] = this.schedulerTime ? this.schedulerTime.toISOString() : <any>undefined;
        data["manualReadingTime"] = this.manualReadingTime ? this.manualReadingTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILastReadingInfo {
    lastReadingTimestamp?: Date | undefined;
    lastDataTimestamp?: Date | undefined;
    result?: string | undefined;
    errorText?: string | undefined;
    usedConnection?: string | undefined;
    schedulerName?: string | undefined;
    schedulerTime?: Date | undefined;
    manualReadingTime?: Date | undefined;
}

export class TimeWindows implements ITimeWindows {
    callWindows?: TimeWindowRow[] | undefined;
    serviceWindows?: TimeWindowRow[] | undefined;
    callWindowExecutionTimes?: Date[] | undefined;
    serviceWindowExecutionTimes?: TimeWindow[] | undefined;

    constructor(data?: ITimeWindows) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["callWindows"])) {
                this.callWindows = [] as any;
                for (let item of _data["callWindows"])
                    this.callWindows!.push(TimeWindowRow.fromJS(item));
            }
            if (Array.isArray(_data["serviceWindows"])) {
                this.serviceWindows = [] as any;
                for (let item of _data["serviceWindows"])
                    this.serviceWindows!.push(TimeWindowRow.fromJS(item));
            }
            if (Array.isArray(_data["callWindowExecutionTimes"])) {
                this.callWindowExecutionTimes = [] as any;
                for (let item of _data["callWindowExecutionTimes"])
                    this.callWindowExecutionTimes!.push(new Date(item));
            }
            if (Array.isArray(_data["serviceWindowExecutionTimes"])) {
                this.serviceWindowExecutionTimes = [] as any;
                for (let item of _data["serviceWindowExecutionTimes"])
                    this.serviceWindowExecutionTimes!.push(TimeWindow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeWindows {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindows();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.callWindows)) {
            data["callWindows"] = [];
            for (let item of this.callWindows)
                data["callWindows"].push(item.toJSON());
        }
        if (Array.isArray(this.serviceWindows)) {
            data["serviceWindows"] = [];
            for (let item of this.serviceWindows)
                data["serviceWindows"].push(item.toJSON());
        }
        if (Array.isArray(this.callWindowExecutionTimes)) {
            data["callWindowExecutionTimes"] = [];
            for (let item of this.callWindowExecutionTimes)
                data["callWindowExecutionTimes"].push(item.toISOString());
        }
        if (Array.isArray(this.serviceWindowExecutionTimes)) {
            data["serviceWindowExecutionTimes"] = [];
            for (let item of this.serviceWindowExecutionTimes)
                data["serviceWindowExecutionTimes"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITimeWindows {
    callWindows?: TimeWindowRow[] | undefined;
    serviceWindows?: TimeWindowRow[] | undefined;
    callWindowExecutionTimes?: Date[] | undefined;
    serviceWindowExecutionTimes?: TimeWindow[] | undefined;
}

export class TimeWindowRow implements ITimeWindowRow {
    enabled?: boolean | undefined;
    type?: string | undefined;
    periodicity?: string | undefined;
    days?: string | undefined;
    dayNumber?: number | undefined;
    hour?: number | undefined;
    minute?: number | undefined;
    second?: number | undefined;
    serviceWindowDurationInSeconds?: number | undefined;

    constructor(data?: ITimeWindowRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.type = _data["type"];
            this.periodicity = _data["periodicity"];
            this.days = _data["days"];
            this.dayNumber = _data["dayNumber"];
            this.hour = _data["hour"];
            this.minute = _data["minute"];
            this.second = _data["second"];
            this.serviceWindowDurationInSeconds = _data["serviceWindowDurationInSeconds"];
        }
    }

    static fromJS(data: any): TimeWindowRow {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindowRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["type"] = this.type;
        data["periodicity"] = this.periodicity;
        data["days"] = this.days;
        data["dayNumber"] = this.dayNumber;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        data["serviceWindowDurationInSeconds"] = this.serviceWindowDurationInSeconds;
        return data;
    }
}

export interface ITimeWindowRow {
    enabled?: boolean | undefined;
    type?: string | undefined;
    periodicity?: string | undefined;
    days?: string | undefined;
    dayNumber?: number | undefined;
    hour?: number | undefined;
    minute?: number | undefined;
    second?: number | undefined;
    serviceWindowDurationInSeconds?: number | undefined;
}

export class TimeWindow implements ITimeWindow {
    executionTime?: Date | undefined;
    duration?: string | undefined;

    constructor(data?: ITimeWindow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): TimeWindow {
        data = typeof data === 'object' ? data : {};
        let result = new TimeWindow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        return data;
    }
}

export interface ITimeWindow {
    executionTime?: Date | undefined;
    duration?: string | undefined;
}

export class DeviceRuntimeParameters implements IDeviceRuntimeParameters {
    items?: DeviceRuntimeParameter[] | undefined;
    count?: number | undefined;

    constructor(data?: IDeviceRuntimeParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceRuntimeParameter.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): DeviceRuntimeParameters {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuntimeParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IDeviceRuntimeParameters {
    items?: DeviceRuntimeParameter[] | undefined;
    count?: number | undefined;
}

export class DeviceRuntimeParameter implements IDeviceRuntimeParameter {
    placeId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    category?: string | undefined;
    subCategory?: string | undefined;
    readonly valueAsObject?: any | undefined;

    constructor(data?: IDeviceRuntimeParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeId = _data["placeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
            this.category = _data["category"];
            this.subCategory = _data["subCategory"];
            (<any>this).valueAsObject = _data["valueAsObject"];
        }
    }

    static fromJS(data: any): DeviceRuntimeParameter {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRuntimeParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeId"] = this.placeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        data["category"] = this.category;
        data["subCategory"] = this.subCategory;
        data["valueAsObject"] = this.valueAsObject;
        return data;
    }
}

export interface IDeviceRuntimeParameter {
    placeId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
    category?: string | undefined;
    subCategory?: string | undefined;
    valueAsObject?: any | undefined;
}

export class ReadingParameters implements IReadingParameters {
    callRepeat?: number | undefined;
    priority?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    useSecondaryConnection?: boolean | undefined;
    logCommunication?: boolean | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    address1?: number | undefined;
    address2?: number | undefined;

    constructor(data?: IReadingParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.callRepeat = _data["callRepeat"];
            this.priority = _data["priority"];
            this.maxReadingTimeInMinutes = _data["maxReadingTimeInMinutes"];
            this.useSecondaryConnection = _data["useSecondaryConnection"];
            this.logCommunication = _data["logCommunication"];
            this.primaryConnectionNumber = _data["primaryConnectionNumber"];
            this.secondaryConnectionNumber = _data["secondaryConnectionNumber"];
            this.primaryConnectionType = _data["primaryConnectionType"];
            this.secondaryConnectionType = _data["secondaryConnectionType"];
            this.primaryDeviceDriverId = _data["primaryDeviceDriverId"];
            this.secondaryDeviceDriverId = _data["secondaryDeviceDriverId"];
            this.primaryChannelGuid = _data["primaryChannelGuid"];
            this.secondaryChannelGuid = _data["secondaryChannelGuid"];
            this.address1 = _data["address1"];
            this.address2 = _data["address2"];
        }
    }

    static fromJS(data: any): ReadingParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ReadingParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callRepeat"] = this.callRepeat;
        data["priority"] = this.priority;
        data["maxReadingTimeInMinutes"] = this.maxReadingTimeInMinutes;
        data["useSecondaryConnection"] = this.useSecondaryConnection;
        data["logCommunication"] = this.logCommunication;
        data["primaryConnectionNumber"] = this.primaryConnectionNumber;
        data["secondaryConnectionNumber"] = this.secondaryConnectionNumber;
        data["primaryConnectionType"] = this.primaryConnectionType;
        data["secondaryConnectionType"] = this.secondaryConnectionType;
        data["primaryDeviceDriverId"] = this.primaryDeviceDriverId;
        data["secondaryDeviceDriverId"] = this.secondaryDeviceDriverId;
        data["primaryChannelGuid"] = this.primaryChannelGuid;
        data["secondaryChannelGuid"] = this.secondaryChannelGuid;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        return data;
    }
}

export interface IReadingParameters {
    callRepeat?: number | undefined;
    priority?: number | undefined;
    maxReadingTimeInMinutes?: number | undefined;
    useSecondaryConnection?: boolean | undefined;
    logCommunication?: boolean | undefined;
    primaryConnectionNumber?: string | undefined;
    secondaryConnectionNumber?: string | undefined;
    primaryConnectionType?: number | undefined;
    secondaryConnectionType?: number | undefined;
    primaryDeviceDriverId?: number | undefined;
    secondaryDeviceDriverId?: number | undefined;
    primaryChannelGuid?: string | undefined;
    secondaryChannelGuid?: string | undefined;
    address1?: number | undefined;
    address2?: number | undefined;
}

export class GasComposition implements IGasComposition {
    settings?: GasConversionParameters | undefined;

    constructor(data?: IGasComposition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settings = _data["settings"] ? GasConversionParameters.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GasComposition {
        data = typeof data === 'object' ? data : {};
        let result = new GasComposition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGasComposition {
    settings?: GasConversionParameters | undefined;
}

export class GasConversionParameters implements IGasConversionParameters {
    compressibilityType?: GasConversionParametersCompressibilityType | undefined;
    cO2?: number | undefined;
    n2?: number | undefined;
    superior?: number | undefined;
    realDensity?: number | undefined;
    h2?: number | undefined;
    h2S?: number | undefined;
    he?: number | undefined;
    h2O?: number | undefined;
    o2?: number | undefined;
    ar?: number | undefined;
    co?: number | undefined;
    c1H4?: number | undefined;
    c2H6?: number | undefined;
    c3H8?: number | undefined;
    iC4H10?: number | undefined;
    nC4H10?: number | undefined;
    iC5H12?: number | undefined;
    nC5H12?: number | undefined;
    c6H14?: number | undefined;
    c7H16?: number | undefined;
    c8H18?: number | undefined;
    c9H20?: number | undefined;
    c10H22?: number | undefined;
    neoC5?: number | undefined;
    c6plus?: number | undefined;
    k1?: number | undefined;
    agA892DCTolerance?: number | undefined;
    readonly compressibilityTypeDescription?: string | undefined;

    constructor(data?: IGasConversionParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.compressibilityType = _data["compressibilityType"];
            this.cO2 = _data["cO2"];
            this.n2 = _data["n2"];
            this.superior = _data["superior"];
            this.realDensity = _data["realDensity"];
            this.h2 = _data["h2"];
            this.h2S = _data["h2S"];
            this.he = _data["he"];
            this.h2O = _data["h2O"];
            this.o2 = _data["o2"];
            this.ar = _data["ar"];
            this.co = _data["co"];
            this.c1H4 = _data["c1H4"];
            this.c2H6 = _data["c2H6"];
            this.c3H8 = _data["c3H8"];
            this.iC4H10 = _data["iC4H10"];
            this.nC4H10 = _data["nC4H10"];
            this.iC5H12 = _data["iC5H12"];
            this.nC5H12 = _data["nC5H12"];
            this.c6H14 = _data["c6H14"];
            this.c7H16 = _data["c7H16"];
            this.c8H18 = _data["c8H18"];
            this.c9H20 = _data["c9H20"];
            this.c10H22 = _data["c10H22"];
            this.neoC5 = _data["neoC5"];
            this.c6plus = _data["c6plus"];
            this.k1 = _data["k1"];
            this.agA892DCTolerance = _data["agA892DCTolerance"];
            (<any>this).compressibilityTypeDescription = _data["compressibilityTypeDescription"];
        }
    }

    static fromJS(data: any): GasConversionParameters {
        data = typeof data === 'object' ? data : {};
        let result = new GasConversionParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["compressibilityType"] = this.compressibilityType;
        data["cO2"] = this.cO2;
        data["n2"] = this.n2;
        data["superior"] = this.superior;
        data["realDensity"] = this.realDensity;
        data["h2"] = this.h2;
        data["h2S"] = this.h2S;
        data["he"] = this.he;
        data["h2O"] = this.h2O;
        data["o2"] = this.o2;
        data["ar"] = this.ar;
        data["co"] = this.co;
        data["c1H4"] = this.c1H4;
        data["c2H6"] = this.c2H6;
        data["c3H8"] = this.c3H8;
        data["iC4H10"] = this.iC4H10;
        data["nC4H10"] = this.nC4H10;
        data["iC5H12"] = this.iC5H12;
        data["nC5H12"] = this.nC5H12;
        data["c6H14"] = this.c6H14;
        data["c7H16"] = this.c7H16;
        data["c8H18"] = this.c8H18;
        data["c9H20"] = this.c9H20;
        data["c10H22"] = this.c10H22;
        data["neoC5"] = this.neoC5;
        data["c6plus"] = this.c6plus;
        data["k1"] = this.k1;
        data["agA892DCTolerance"] = this.agA892DCTolerance;
        data["compressibilityTypeDescription"] = this.compressibilityTypeDescription;
        return data;
    }
}

export interface IGasConversionParameters {
    compressibilityType?: GasConversionParametersCompressibilityType | undefined;
    cO2?: number | undefined;
    n2?: number | undefined;
    superior?: number | undefined;
    realDensity?: number | undefined;
    h2?: number | undefined;
    h2S?: number | undefined;
    he?: number | undefined;
    h2O?: number | undefined;
    o2?: number | undefined;
    ar?: number | undefined;
    co?: number | undefined;
    c1H4?: number | undefined;
    c2H6?: number | undefined;
    c3H8?: number | undefined;
    iC4H10?: number | undefined;
    nC4H10?: number | undefined;
    iC5H12?: number | undefined;
    nC5H12?: number | undefined;
    c6H14?: number | undefined;
    c7H16?: number | undefined;
    c8H18?: number | undefined;
    c9H20?: number | undefined;
    c10H22?: number | undefined;
    neoC5?: number | undefined;
    c6plus?: number | undefined;
    k1?: number | undefined;
    agA892DCTolerance?: number | undefined;
    compressibilityTypeDescription?: string | undefined;
}

export class ServerInfos implements IServerInfos {
    items?: ServerInfo[] | undefined;
    count?: number | undefined;

    constructor(data?: IServerInfos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServerInfo.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ServerInfos {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInfos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IServerInfos {
    items?: ServerInfo[] | undefined;
    count?: number | undefined;
}

export class ServerInfo implements IServerInfo {
    id?: number | undefined;
    ip?: string | undefined;
    lastRegistered?: string | undefined;
    name?: string | undefined;
    online?: boolean | undefined;
    port?: number | undefined;
    regionId?: number | undefined;
    type?: string | undefined;
    version?: string | undefined;
    memoryUsage?: number | undefined;
    diskUsage?: number | undefined;
    cpuUsage?: number | undefined;
    usageAge?: string | undefined;

    constructor(data?: IServerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ip = _data["ip"];
            this.lastRegistered = _data["lastRegistered"];
            this.name = _data["name"];
            this.online = _data["online"];
            this.port = _data["port"];
            this.regionId = _data["regionId"];
            this.type = _data["type"];
            this.version = _data["version"];
            this.memoryUsage = _data["memoryUsage"];
            this.diskUsage = _data["diskUsage"];
            this.cpuUsage = _data["cpuUsage"];
            this.usageAge = _data["usageAge"];
        }
    }

    static fromJS(data: any): ServerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ip"] = this.ip;
        data["lastRegistered"] = this.lastRegistered;
        data["name"] = this.name;
        data["online"] = this.online;
        data["port"] = this.port;
        data["regionId"] = this.regionId;
        data["type"] = this.type;
        data["version"] = this.version;
        data["memoryUsage"] = this.memoryUsage;
        data["diskUsage"] = this.diskUsage;
        data["cpuUsage"] = this.cpuUsage;
        data["usageAge"] = this.usageAge;
        return data;
    }
}

export interface IServerInfo {
    id?: number | undefined;
    ip?: string | undefined;
    lastRegistered?: string | undefined;
    name?: string | undefined;
    online?: boolean | undefined;
    port?: number | undefined;
    regionId?: number | undefined;
    type?: string | undefined;
    version?: string | undefined;
    memoryUsage?: number | undefined;
    diskUsage?: number | undefined;
    cpuUsage?: number | undefined;
    usageAge?: string | undefined;
}

export class ServerMonitoringItems implements IServerMonitoringItems {
    items?: ServerMonitoringItem[] | undefined;
    count?: number | undefined;

    constructor(data?: IServerMonitoringItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ServerMonitoringItem.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ServerMonitoringItems {
        data = typeof data === 'object' ? data : {};
        let result = new ServerMonitoringItems();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IServerMonitoringItems {
    items?: ServerMonitoringItem[] | undefined;
    count?: number | undefined;
}

export class ServerMonitoringItem implements IServerMonitoringItem {
    timestamp?: Date | undefined;
    serverId?: number | undefined;
    data?: string | undefined;

    constructor(data?: IServerMonitoringItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.serverId = _data["serverId"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ServerMonitoringItem {
        data = typeof data === 'object' ? data : {};
        let result = new ServerMonitoringItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["serverId"] = this.serverId;
        data["data"] = this.data;
        return data;
    }
}

export interface IServerMonitoringItem {
    timestamp?: Date | undefined;
    serverId?: number | undefined;
    data?: string | undefined;
}

export class ChartData_1 implements IChartData_1 {
    timestamp?: Date | undefined;
    value?: any | undefined;

    constructor(data?: IChartData_1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ChartData_1 {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData_1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

export interface IChartData_1 {
    timestamp?: Date | undefined;
    value?: any | undefined;
}

export class Page_1 implements IPage_1 {
    items?: ExportScheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPage_1) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExportScheduler.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): Page_1 {
        data = typeof data === 'object' ? data : {};
        let result = new Page_1();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPage_1 {
    items?: ExportScheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ExportScheduler implements IExportScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    firstExecutionTime?: Date | undefined;
    lastExecutionTime?: Date | undefined;
    enabled?: boolean | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;
    modified?: Date | undefined;
    modifiedBy?: string | undefined;
    profilesIds?: number[] | undefined;
    periodicallyConditionType?: ExportSchedulerPeriodicallyConditionType | undefined;
    periodicallyConditionCount?: number | undefined;
    exportProperties?: ExportProperties | undefined;
    days?: string | undefined;
    serializedExportProperties?: string | undefined;
    readonly nextExecutionTime?: Date | undefined;

    constructor(data?: IExportScheduler) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.regionId = _data["regionId"];
            this.firstExecutionTime = _data["firstExecutionTime"] ? new Date(_data["firstExecutionTime"].toString()) : <any>undefined;
            this.lastExecutionTime = _data["lastExecutionTime"] ? new Date(_data["lastExecutionTime"].toString()) : <any>undefined;
            this.enabled = _data["enabled"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
            this.modifiedBy = _data["modifiedBy"];
            if (Array.isArray(_data["profilesIds"])) {
                this.profilesIds = [] as any;
                for (let item of _data["profilesIds"])
                    this.profilesIds!.push(item);
            }
            this.periodicallyConditionType = _data["periodicallyConditionType"];
            this.periodicallyConditionCount = _data["periodicallyConditionCount"];
            this.exportProperties = _data["exportProperties"] ? ExportProperties.fromJS(_data["exportProperties"]) : <any>undefined;
            this.days = _data["days"];
            this.serializedExportProperties = _data["serializedExportProperties"];
            (<any>this).nextExecutionTime = _data["nextExecutionTime"] ? new Date(_data["nextExecutionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportScheduler {
        data = typeof data === 'object' ? data : {};
        let result = new ExportScheduler();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["description"] = this.description;
        data["regionId"] = this.regionId;
        data["firstExecutionTime"] = this.firstExecutionTime ? this.firstExecutionTime.toISOString() : <any>undefined;
        data["lastExecutionTime"] = this.lastExecutionTime ? this.lastExecutionTime.toISOString() : <any>undefined;
        data["enabled"] = this.enabled;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["modifiedBy"] = this.modifiedBy;
        if (Array.isArray(this.profilesIds)) {
            data["profilesIds"] = [];
            for (let item of this.profilesIds)
                data["profilesIds"].push(item);
        }
        data["periodicallyConditionType"] = this.periodicallyConditionType;
        data["periodicallyConditionCount"] = this.periodicallyConditionCount;
        data["exportProperties"] = this.exportProperties ? this.exportProperties.toJSON() : <any>undefined;
        data["days"] = this.days;
        data["serializedExportProperties"] = this.serializedExportProperties;
        data["nextExecutionTime"] = this.nextExecutionTime ? this.nextExecutionTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IExportScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    regionId?: number | undefined;
    firstExecutionTime?: Date | undefined;
    lastExecutionTime?: Date | undefined;
    enabled?: boolean | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;
    modified?: Date | undefined;
    modifiedBy?: string | undefined;
    profilesIds?: number[] | undefined;
    periodicallyConditionType?: ExportSchedulerPeriodicallyConditionType | undefined;
    periodicallyConditionCount?: number | undefined;
    exportProperties?: ExportProperties | undefined;
    days?: string | undefined;
    serializedExportProperties?: string | undefined;
    nextExecutionTime?: Date | undefined;
}

export class ExportProperties implements IExportProperties {
    name?: string | undefined;
    exportType?: number | undefined;
    timeRange?: ExportPropertiesTimeRange | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    sendEmail?: boolean | undefined;
    emails?: string | undefined;
    subDirectory?: string | undefined;
    rootPath?: string | undefined;
    customTemplateFileName?: string | undefined;
    cultureName?: string | undefined;
    exportFileFormat?: number | undefined;
    previousDaysCount?: number | undefined;
    exportPerFile?: boolean | undefined;
    emailCc?: string | undefined;
    emailBcc?: string | undefined;
    emailSubject?: string | undefined;
    isPofRequired?: boolean | undefined;
    pofProfileId?: number | undefined;

    constructor(data?: IExportProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.exportType = _data["exportType"];
            this.timeRange = _data["timeRange"];
            this.truncateData = _data["truncateData"];
            this.withDaylightSavingTime = _data["withDaylightSavingTime"];
            this.sendEmail = _data["sendEmail"];
            this.emails = _data["emails"];
            this.subDirectory = _data["subDirectory"];
            this.rootPath = _data["rootPath"];
            this.customTemplateFileName = _data["customTemplateFileName"];
            this.cultureName = _data["cultureName"];
            this.exportFileFormat = _data["exportFileFormat"];
            this.previousDaysCount = _data["previousDaysCount"];
            this.exportPerFile = _data["exportPerFile"];
            this.emailCc = _data["emailCc"];
            this.emailBcc = _data["emailBcc"];
            this.emailSubject = _data["emailSubject"];
            this.isPofRequired = _data["isPofRequired"];
            this.pofProfileId = _data["pofProfileId"];
        }
    }

    static fromJS(data: any): ExportProperties {
        data = typeof data === 'object' ? data : {};
        let result = new ExportProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["exportType"] = this.exportType;
        data["timeRange"] = this.timeRange;
        data["truncateData"] = this.truncateData;
        data["withDaylightSavingTime"] = this.withDaylightSavingTime;
        data["sendEmail"] = this.sendEmail;
        data["emails"] = this.emails;
        data["subDirectory"] = this.subDirectory;
        data["rootPath"] = this.rootPath;
        data["customTemplateFileName"] = this.customTemplateFileName;
        data["cultureName"] = this.cultureName;
        data["exportFileFormat"] = this.exportFileFormat;
        data["previousDaysCount"] = this.previousDaysCount;
        data["exportPerFile"] = this.exportPerFile;
        data["emailCc"] = this.emailCc;
        data["emailBcc"] = this.emailBcc;
        data["emailSubject"] = this.emailSubject;
        data["isPofRequired"] = this.isPofRequired;
        data["pofProfileId"] = this.pofProfileId;
        return data;
    }
}

export interface IExportProperties {
    name?: string | undefined;
    exportType?: number | undefined;
    timeRange?: ExportPropertiesTimeRange | undefined;
    truncateData?: boolean | undefined;
    withDaylightSavingTime?: boolean | undefined;
    sendEmail?: boolean | undefined;
    emails?: string | undefined;
    subDirectory?: string | undefined;
    rootPath?: string | undefined;
    customTemplateFileName?: string | undefined;
    cultureName?: string | undefined;
    exportFileFormat?: number | undefined;
    previousDaysCount?: number | undefined;
    exportPerFile?: boolean | undefined;
    emailCc?: string | undefined;
    emailBcc?: string | undefined;
    emailSubject?: string | undefined;
    isPofRequired?: boolean | undefined;
    pofProfileId?: number | undefined;
}

export class Page_11 implements IPage_11 {
    items?: ExportFile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPage_11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExportFile.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): Page_11 {
        data = typeof data === 'object' ? data : {};
        let result = new Page_11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPage_11 {
    items?: ExportFile[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ExportFile implements IExportFile {
    name?: string | undefined;
    sizeInKb?: number | undefined;
    type?: string | undefined;
    created?: Date | undefined;

    constructor(data?: IExportFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sizeInKb = _data["sizeInKb"];
            this.type = _data["type"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportFile {
        data = typeof data === 'object' ? data : {};
        let result = new ExportFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sizeInKb"] = this.sizeInKb;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IExportFile {
    name?: string | undefined;
    sizeInKb?: number | undefined;
    type?: string | undefined;
    created?: Date | undefined;
}

export class KeyValueCommandResponse implements IKeyValueCommandResponse {
    collection?: string | undefined;
    keyValues?: { [key: string]: string; } | undefined;

    constructor(data?: IKeyValueCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collection = _data["collection"];
            if (_data["keyValues"]) {
                this.keyValues = {} as any;
                for (let key in _data["keyValues"]) {
                    if (_data["keyValues"].hasOwnProperty(key))
                        (<any>this.keyValues)![key] = _data["keyValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): KeyValueCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValueCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collection"] = this.collection;
        if (this.keyValues) {
            data["keyValues"] = {};
            for (let key in this.keyValues) {
                if (this.keyValues.hasOwnProperty(key))
                    (<any>data["keyValues"])[key] = (<any>this.keyValues)[key];
            }
        }
        return data;
    }
}

export interface IKeyValueCommandResponse {
    collection?: string | undefined;
    keyValues?: { [key: string]: string; } | undefined;
}

export class KeyValuePair_2 implements IKeyValuePair_2 {
    readonly key?: string | undefined;
    readonly value?: string | undefined;

    constructor(data?: IKeyValuePair_2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["key"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePair_2 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePair_2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePair_2 {
    key?: string | undefined;
    value?: string | undefined;
}

export class PlacePage implements IPlacePage {
    pageItems?: Place[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IPlacePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(Place.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PlacePage {
        data = typeof data === 'object' ? data : {};
        let result = new PlacePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IPlacePage {
    pageItems?: Place[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ReadRequestPage implements IReadRequestPage {
    pageItems?: ReadRequest[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: IReadRequestPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(ReadRequest.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadRequestPage {
        data = typeof data === 'object' ? data : {};
        let result = new ReadRequestPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IReadRequestPage {
    pageItems?: ReadRequest[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class ReadRequest implements IReadRequest {
    guid?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    placeId?: string | undefined;
    deviceDriverId?: number | undefined;
    regionId?: number | undefined;
    progress?: number | undefined;
    status?: ReadRequestStatus | undefined;
    statusDescription?: string | undefined;
    failureSource?: ReadRequestFailureSource | undefined;
    failureSourceDescription?: string | undefined;
    failureCode?: number | undefined;
    failureDescription?: string | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    closed?: string | undefined;
    lastAccessTime?: string | undefined;
    connectionDescription?: string | undefined;
    group?: string | undefined;
    connectionNumber?: string | undefined;
    connectionType?: string | undefined;
    deviceType?: string | undefined;

    constructor(data?: IReadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.placeId = _data["placeId"];
            this.deviceDriverId = _data["deviceDriverId"];
            this.regionId = _data["regionId"];
            this.progress = _data["progress"];
            this.status = _data["status"];
            this.statusDescription = _data["statusDescription"];
            this.failureSource = _data["failureSource"];
            this.failureSourceDescription = _data["failureSourceDescription"];
            this.failureCode = _data["failureCode"];
            this.failureDescription = _data["failureDescription"];
            this.created = _data["created"];
            this.createdBy = _data["createdBy"];
            this.closed = _data["closed"];
            this.lastAccessTime = _data["lastAccessTime"];
            this.connectionDescription = _data["connectionDescription"];
            this.group = _data["group"];
            this.connectionNumber = _data["connectionNumber"];
            this.connectionType = _data["connectionType"];
            this.deviceType = _data["deviceType"];
        }
    }

    static fromJS(data: any): ReadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["title"] = this.title;
        data["note"] = this.note;
        data["placeId"] = this.placeId;
        data["deviceDriverId"] = this.deviceDriverId;
        data["regionId"] = this.regionId;
        data["progress"] = this.progress;
        data["status"] = this.status;
        data["statusDescription"] = this.statusDescription;
        data["failureSource"] = this.failureSource;
        data["failureSourceDescription"] = this.failureSourceDescription;
        data["failureCode"] = this.failureCode;
        data["failureDescription"] = this.failureDescription;
        data["created"] = this.created;
        data["createdBy"] = this.createdBy;
        data["closed"] = this.closed;
        data["lastAccessTime"] = this.lastAccessTime;
        data["connectionDescription"] = this.connectionDescription;
        data["group"] = this.group;
        data["connectionNumber"] = this.connectionNumber;
        data["connectionType"] = this.connectionType;
        data["deviceType"] = this.deviceType;
        return data;
    }
}

export interface IReadRequest {
    guid?: string | undefined;
    title?: string | undefined;
    note?: string | undefined;
    placeId?: string | undefined;
    deviceDriverId?: number | undefined;
    regionId?: number | undefined;
    progress?: number | undefined;
    status?: ReadRequestStatus | undefined;
    statusDescription?: string | undefined;
    failureSource?: ReadRequestFailureSource | undefined;
    failureSourceDescription?: string | undefined;
    failureCode?: number | undefined;
    failureDescription?: string | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    closed?: string | undefined;
    lastAccessTime?: string | undefined;
    connectionDescription?: string | undefined;
    group?: string | undefined;
    connectionNumber?: string | undefined;
    connectionType?: string | undefined;
    deviceType?: string | undefined;
}

export class SchedulerPage implements ISchedulerPage {
    pageItems?: Scheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;

    constructor(data?: ISchedulerPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pageItems"])) {
                this.pageItems = [] as any;
                for (let item of _data["pageItems"])
                    this.pageItems!.push(Scheduler.fromJS(item));
            }
            this.count = _data["count"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SchedulerPage {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulerPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pageItems)) {
            data["pageItems"] = [];
            for (let item of this.pageItems)
                data["pageItems"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface ISchedulerPage {
    pageItems?: Scheduler[] | undefined;
    count?: number | undefined;
    totalCount?: number | undefined;
}

export class Scheduler implements IScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    enabled?: boolean | undefined;
    regionId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    firstReadingTime?: string | undefined;
    lastReadingTime?: string | undefined;
    lastReadingRelativeTime?: string | undefined;
    lastReadingTimeDescription?: string | undefined;
    nextReadingTime?: string | undefined;
    readStateOption?: string | undefined;
    useDeviceDriver?: boolean | undefined;
    connectionOption?: string | undefined;
    deviceDriverId?: number | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    modified?: string | undefined;
    modifiedBy?: string | undefined;
    isLimitedReadWriteOperation?: boolean | undefined;
    readWriteOperationType?: number | undefined;
    readDevicesInTimeWindows?: boolean | undefined;

    constructor(data?: IScheduler) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guid = _data["guid"];
            this.enabled = _data["enabled"];
            this.regionId = _data["regionId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.firstReadingTime = _data["firstReadingTime"];
            this.lastReadingTime = _data["lastReadingTime"];
            this.lastReadingRelativeTime = _data["lastReadingRelativeTime"];
            this.lastReadingTimeDescription = _data["lastReadingTimeDescription"];
            this.nextReadingTime = _data["nextReadingTime"];
            this.readStateOption = _data["readStateOption"];
            this.useDeviceDriver = _data["useDeviceDriver"];
            this.connectionOption = _data["connectionOption"];
            this.deviceDriverId = _data["deviceDriverId"];
            this.created = _data["created"];
            this.createdBy = _data["createdBy"];
            this.modified = _data["modified"];
            this.modifiedBy = _data["modifiedBy"];
            this.isLimitedReadWriteOperation = _data["isLimitedReadWriteOperation"];
            this.readWriteOperationType = _data["readWriteOperationType"];
            this.readDevicesInTimeWindows = _data["readDevicesInTimeWindows"];
        }
    }

    static fromJS(data: any): Scheduler {
        data = typeof data === 'object' ? data : {};
        let result = new Scheduler();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["enabled"] = this.enabled;
        data["regionId"] = this.regionId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["firstReadingTime"] = this.firstReadingTime;
        data["lastReadingTime"] = this.lastReadingTime;
        data["lastReadingRelativeTime"] = this.lastReadingRelativeTime;
        data["lastReadingTimeDescription"] = this.lastReadingTimeDescription;
        data["nextReadingTime"] = this.nextReadingTime;
        data["readStateOption"] = this.readStateOption;
        data["useDeviceDriver"] = this.useDeviceDriver;
        data["connectionOption"] = this.connectionOption;
        data["deviceDriverId"] = this.deviceDriverId;
        data["created"] = this.created;
        data["createdBy"] = this.createdBy;
        data["modified"] = this.modified;
        data["modifiedBy"] = this.modifiedBy;
        data["isLimitedReadWriteOperation"] = this.isLimitedReadWriteOperation;
        data["readWriteOperationType"] = this.readWriteOperationType;
        data["readDevicesInTimeWindows"] = this.readDevicesInTimeWindows;
        return data;
    }
}

export interface IScheduler {
    id?: number | undefined;
    guid?: string | undefined;
    enabled?: boolean | undefined;
    regionId?: number | undefined;
    name?: string | undefined;
    description?: string | undefined;
    firstReadingTime?: string | undefined;
    lastReadingTime?: string | undefined;
    lastReadingRelativeTime?: string | undefined;
    lastReadingTimeDescription?: string | undefined;
    nextReadingTime?: string | undefined;
    readStateOption?: string | undefined;
    useDeviceDriver?: boolean | undefined;
    connectionOption?: string | undefined;
    deviceDriverId?: number | undefined;
    created?: string | undefined;
    createdBy?: string | undefined;
    modified?: string | undefined;
    modifiedBy?: string | undefined;
    isLimitedReadWriteOperation?: boolean | undefined;
    readWriteOperationType?: number | undefined;
    readDevicesInTimeWindows?: boolean | undefined;
}

export class SystemInfo implements ISystemInfo {
    devicesCount?: number | undefined;
    devicesReadingCompleted?: number | undefined;
    devicesFailures?: number | undefined;
    devicesReadingInProgress?: number | undefined;
    serversCount?: number | undefined;
    serversOnline?: number | undefined;
    serversOffline?: number | undefined;
    usersOnline?: number | undefined;
    activeAlarms?: number | undefined;
    errors?: number | undefined;
    commandsPerMinute?: number | undefined;
    masterDataRowCount?: number | undefined;
    operatingDataRowCount?: number | undefined;
    dataPumpCount?: number | undefined;
    dataPumpsInError?: number | undefined;
    overallReadingSuccessRate?: number[] | undefined;
    readingSuccessRate?: number | undefined;

    constructor(data?: ISystemInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.devicesCount = _data["devicesCount"];
            this.devicesReadingCompleted = _data["devicesReadingCompleted"];
            this.devicesFailures = _data["devicesFailures"];
            this.devicesReadingInProgress = _data["devicesReadingInProgress"];
            this.serversCount = _data["serversCount"];
            this.serversOnline = _data["serversOnline"];
            this.serversOffline = _data["serversOffline"];
            this.usersOnline = _data["usersOnline"];
            this.activeAlarms = _data["activeAlarms"];
            this.errors = _data["errors"];
            this.commandsPerMinute = _data["commandsPerMinute"];
            this.masterDataRowCount = _data["masterDataRowCount"];
            this.operatingDataRowCount = _data["operatingDataRowCount"];
            this.dataPumpCount = _data["dataPumpCount"];
            this.dataPumpsInError = _data["dataPumpsInError"];
            if (Array.isArray(_data["overallReadingSuccessRate"])) {
                this.overallReadingSuccessRate = [] as any;
                for (let item of _data["overallReadingSuccessRate"])
                    this.overallReadingSuccessRate!.push(item);
            }
            this.readingSuccessRate = _data["readingSuccessRate"];
        }
    }

    static fromJS(data: any): SystemInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["devicesCount"] = this.devicesCount;
        data["devicesReadingCompleted"] = this.devicesReadingCompleted;
        data["devicesFailures"] = this.devicesFailures;
        data["devicesReadingInProgress"] = this.devicesReadingInProgress;
        data["serversCount"] = this.serversCount;
        data["serversOnline"] = this.serversOnline;
        data["serversOffline"] = this.serversOffline;
        data["usersOnline"] = this.usersOnline;
        data["activeAlarms"] = this.activeAlarms;
        data["errors"] = this.errors;
        data["commandsPerMinute"] = this.commandsPerMinute;
        data["masterDataRowCount"] = this.masterDataRowCount;
        data["operatingDataRowCount"] = this.operatingDataRowCount;
        data["dataPumpCount"] = this.dataPumpCount;
        data["dataPumpsInError"] = this.dataPumpsInError;
        if (Array.isArray(this.overallReadingSuccessRate)) {
            data["overallReadingSuccessRate"] = [];
            for (let item of this.overallReadingSuccessRate)
                data["overallReadingSuccessRate"].push(item);
        }
        data["readingSuccessRate"] = this.readingSuccessRate;
        return data;
    }
}

export interface ISystemInfo {
    devicesCount?: number | undefined;
    devicesReadingCompleted?: number | undefined;
    devicesFailures?: number | undefined;
    devicesReadingInProgress?: number | undefined;
    serversCount?: number | undefined;
    serversOnline?: number | undefined;
    serversOffline?: number | undefined;
    usersOnline?: number | undefined;
    activeAlarms?: number | undefined;
    errors?: number | undefined;
    commandsPerMinute?: number | undefined;
    masterDataRowCount?: number | undefined;
    operatingDataRowCount?: number | undefined;
    dataPumpCount?: number | undefined;
    dataPumpsInError?: number | undefined;
    overallReadingSuccessRate?: number[] | undefined;
    readingSuccessRate?: number | undefined;
}

export class ServerRegion implements IServerRegion {
    id?: number | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    dealerIdentification?: string | undefined;

    constructor(data?: IServerRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            this.dealerIdentification = _data["dealerIdentification"];
        }
    }

    static fromJS(data: any): ServerRegion {
        data = typeof data === 'object' ? data : {};
        let result = new ServerRegion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        data["dealerIdentification"] = this.dealerIdentification;
        return data;
    }
}

export interface IServerRegion {
    id?: number | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    dealerIdentification?: string | undefined;
}

export class ServerVersion implements IServerVersion {
    version?: string | undefined;

    constructor(data?: IServerVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): ServerVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ServerVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        return data;
    }
}

export interface IServerVersion {
    version?: string | undefined;
}

export class ServerTime implements IServerTime {
    now?: Date | undefined;
    utcNow?: Date | undefined;

    constructor(data?: IServerTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.now = _data["now"] ? new Date(_data["now"].toString()) : <any>undefined;
            this.utcNow = _data["utcNow"] ? new Date(_data["utcNow"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerTime {
        data = typeof data === 'object' ? data : {};
        let result = new ServerTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["now"] = this.now ? this.now.toISOString() : <any>undefined;
        data["utcNow"] = this.utcNow ? this.utcNow.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServerTime {
    now?: Date | undefined;
    utcNow?: Date | undefined;
}

export class SystemEventLog implements ISystemEventLog {
    eventType?: SystemEventLogEventType | undefined;
    eventId?: number | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;

    constructor(data?: ISystemEventLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventType = _data["eventType"];
            this.eventId = _data["eventId"];
            this.category = _data["category"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): SystemEventLog {
        data = typeof data === 'object' ? data : {};
        let result = new SystemEventLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventType"] = this.eventType;
        data["eventId"] = this.eventId;
        data["category"] = this.category;
        data["message"] = this.message;
        data["data"] = this.data;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ISystemEventLog {
    eventType?: SystemEventLogEventType | undefined;
    eventId?: number | undefined;
    category?: string | undefined;
    message?: string | undefined;
    data?: string | undefined;
    userName?: string | undefined;
}

export class SessionIds implements ISessionIds {
    sessionIds?: string[] | undefined;

    constructor(data?: ISessionIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sessionIds"])) {
                this.sessionIds = [] as any;
                for (let item of _data["sessionIds"])
                    this.sessionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SessionIds {
        data = typeof data === 'object' ? data : {};
        let result = new SessionIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sessionIds)) {
            data["sessionIds"] = [];
            for (let item of this.sessionIds)
                data["sessionIds"].push(item);
        }
        return data;
    }
}

export interface ISessionIds {
    sessionIds?: string[] | undefined;
}

export enum DataRange {
    LastHour = "LastHour",
    LastSixHour = "LastSixHour",
    Last24Hour = "Last24Hour",
    Today = "Today",
    Yesterday = "Yesterday",
    Last3Days = "Last3Days",
}

export enum DataRange2 {
    LastHour = "LastHour",
    LastSixHour = "LastSixHour",
    Last24Hour = "Last24Hour",
    Today = "Today",
    Yesterday = "Yesterday",
    Last3Days = "Last3Days",
}

export enum ConnectionOption {
    Default = "Default",
    UseSecondaryConnectionOnly = "UseSecondaryConnectionOnly",
    UsePrimaryConnectionOnly = "UsePrimaryConnectionOnly",
}

export enum ReadWriteOperationType {
    ReadActualValues = "ReadActualValues",
    ReadArchive = "ReadArchive",
    ReadGasComposition = "ReadGasComposition",
    WriteGasComposition = "WriteGasComposition",
    WriteTimeForSynchronisation = "WriteTimeForSynchronisation",
}

export enum AlarmEntryObjectState {
    Unchanged = "Unchanged",
    New = "New",
    Deleted = "Deleted",
    Modified = "Modified",
    PendingSave = "PendingSave",
}

export enum ConsumptionPlaceObjectState {
    Unchanged = "Unchanged",
    New = "New",
    Deleted = "Deleted",
    Modified = "Modified",
    PendingSave = "PendingSave",
}

export enum CustomerObjectState {
    Unchanged = "Unchanged",
    New = "New",
    Deleted = "Deleted",
    Modified = "Modified",
    PendingSave = "PendingSave",
}

export enum BaseDeviceType {
    Unknown = "Unknown",
    Other = "Other",
    Datcom = "Datcom",
    Elcor94 = "Elcor94",
    Elcor2 = "Elcor2",
    ElsterEK84 = "ElsterEK84",
    ElsterEK86 = "ElsterEK86",
    ElsterEK88 = "ElsterEK88",
    MicroElcor = "MicroElcor",
    ElsterEK260 = "ElsterEK260",
    Solartron = "Solartron",
    MicroElcor2 = "MicroElcor2",
    Datcom2 = "Datcom2",
    DatcomAMR = "DatcomAMR",
    VirtualDevice = "VirtualDevice",
    RNDC = "RNDC",
    DMTZ = "DMTZ",
    Ctr = "Ctr",
    MaxiElcor = "MaxiElcor",
    FloBoss = "FloBoss",
    Daniel2350 = "Daniel2350",
    Daniel2350A = "Daniel2350A",
    MiniElcor = "MiniElcor",
    MacMatIIe = "MacMatIIe",
    ElsterM2000 = "ElsterM2000",
    ModbusDevice = "ModbusDevice",
    ModbusDataLogger = "ModbusDataLogger",
    NanoElcor = "NanoElcor",
    PicoElcor = "PicoElcor",
    MidiElcor = "MidiElcor",
    MiniDatcom = "MiniDatcom",
    MaxiDatcom = "MaxiDatcom",
    MidiDatcom = "MidiDatcom",
    Corus = "Corus",
    CommonCMK02 = "CommonCMK02",
    Omni3000 = "Omni3000",
    Flowsic500 = "Flowsic500",
    ElsterEK220 = "ElsterEK220",
    ModbusSysDevice = "ModbusSysDevice",
    ModbusRmsDevice = "ModbusRmsDevice",
    ModbusBolgeDevice = "ModbusBolgeDevice",
    GazModemIIDevice = "GazModemIIDevice",
    ModbusDnpDriver = "ModbusDnpDriver",
    MBusDevice = "MBusDevice",
    EmhDizF = "EmhDizF",
    ElsterEK280 = "ElsterEK280",
    PicoDatcom = "PicoDatcom",
    ModemTS = "ModemTS",
    Dlms = "Dlms",
    ZZ044 = "ZZ044",
    GeniusSlim = "GeniusSlim",
    G4EUS2 = "G4EUS2",
    IoT = "IoT",
    ElsterBKG4 = "ElsterBKG4",
    Elcor = "Elcor",
    ElcorPlus = "ElcorPlus",
    MeterEG4EVO = "MeterEG4EVO",
    SchneiderIEM3000 = "SchneiderIEM3000",
    GazModem3Device = "GazModem3Device",
    Datcom3 = "Datcom3",
    DatcomPlus = "DatcomPlus",
    Mpdr = "Mpdr",
    MacBAT5 = "MacBAT5",
    MacR6 = "MacR6",
    MacR6Z0P = "MacR6Z0P",
    MacR6P = "MacR6P",
    ShitekUGMG4 = "ShitekUGMG4",
    MetrixWTG4SG = "MetrixWTG4SG",
    LandisGyrE650 = "LandisGyrE650",
    ApulseX3F5 = "ApulseX3F5",
    PulseAtexX2 = "PulseAtexX2",
    PulseX3 = "PulseX3",
    FiorentiniRSE = "FiorentiniRSE",
    MeteRSitG = "MeteRSitG",
    SchrackEIZ = "SchrackEIZ",
    ElcorLite = "ElcorLite",
    MacR6N = "MacR6N",
    IEC104 = "IEC104",
    DatcomLite = "DatcomLite",
    MacMatIV = "MacMatIV",
    BlSigAmr1 = "BlSigAmr1",
    Escom = "Escom",
    ModbusVicorDevice = "ModbusVicorDevice",
    ModbusMicroZDevice = "ModbusMicroZDevice",
    MacR6IoT = "MacR6IoT",
    HoneywellEI7 = "HoneywellEI7",
    FiorentiniRSEIoT = "FiorentiniRSEIoT",
    PicoElcor2 = "PicoElcor2",
    AMTB2C = "AMTB2C",
    FloBoss1200 = "FloBoss1200",
    SagemcomES4EVO = "SagemcomES4EVO",
    ProdigiIoT = "ProdigiIoT",
    CorusEvoPlus = "CorusEvoPlus",
}

export enum BaseDeviceReadProcessState {
    Unknown = "Unknown",
    NotAssigned = "NotAssigned",
    AssignedToDeviceServer = "AssignedToDeviceServer",
    AssignedToDriver = "AssignedToDriver",
    DataReading = "DataReading",
    ReadingDone = "ReadingDone",
    ReadingPartiallyDone = "ReadingPartiallyDone",
    Failure = "Failure",
    DuplicateRequest = "DuplicateRequest",
    Connecting = "Connecting",
    WaitingForAssociatedCalls = "WaitingForAssociatedCalls",
}

export enum BaseDeviceChromatographPeriod {
    Hour = "Hour",
    Day = "Day",
    Month = "Month",
}

export enum BaseDeviceKind {
    Recounter = "Recounter",
    Chromatograph = "Chromatograph",
}

export enum BaseDeviceSourceDataPeriod {
    Hour = "Hour",
    Day = "Day",
    Minutes = "Minutes",
    Day_NonstandardStorageTime = "Day_NonstandardStorageTime",
}

export enum BaseDeviceValveAction {
    None = "None",
    Close = "Close",
    Open = "Open",
}

export enum BaseDeviceValveState {
    Unknown = "Unknown",
    Open = "Open",
    Closed = "Closed",
}

export enum BaseDeviceObjectState {
    Unchanged = "Unchanged",
    New = "New",
    Deleted = "Deleted",
    Modified = "Modified",
    PendingSave = "PendingSave",
}

export enum DeviceTypeDescriptionType {
    Unknown = "Unknown",
    Other = "Other",
    Datcom = "Datcom",
    Elcor94 = "Elcor94",
    Elcor2 = "Elcor2",
    ElsterEK84 = "ElsterEK84",
    ElsterEK86 = "ElsterEK86",
    ElsterEK88 = "ElsterEK88",
    MicroElcor = "MicroElcor",
    ElsterEK260 = "ElsterEK260",
    Solartron = "Solartron",
    MicroElcor2 = "MicroElcor2",
    Datcom2 = "Datcom2",
    DatcomAMR = "DatcomAMR",
    VirtualDevice = "VirtualDevice",
    RNDC = "RNDC",
    DMTZ = "DMTZ",
    Ctr = "Ctr",
    MaxiElcor = "MaxiElcor",
    FloBoss = "FloBoss",
    Daniel2350 = "Daniel2350",
    Daniel2350A = "Daniel2350A",
    MiniElcor = "MiniElcor",
    MacMatIIe = "MacMatIIe",
    ElsterM2000 = "ElsterM2000",
    ModbusDevice = "ModbusDevice",
    ModbusDataLogger = "ModbusDataLogger",
    NanoElcor = "NanoElcor",
    PicoElcor = "PicoElcor",
    MidiElcor = "MidiElcor",
    MiniDatcom = "MiniDatcom",
    MaxiDatcom = "MaxiDatcom",
    MidiDatcom = "MidiDatcom",
    Corus = "Corus",
    CommonCMK02 = "CommonCMK02",
    Omni3000 = "Omni3000",
    Flowsic500 = "Flowsic500",
    ElsterEK220 = "ElsterEK220",
    ModbusSysDevice = "ModbusSysDevice",
    ModbusRmsDevice = "ModbusRmsDevice",
    ModbusBolgeDevice = "ModbusBolgeDevice",
    GazModemIIDevice = "GazModemIIDevice",
    ModbusDnpDriver = "ModbusDnpDriver",
    MBusDevice = "MBusDevice",
    EmhDizF = "EmhDizF",
    ElsterEK280 = "ElsterEK280",
    PicoDatcom = "PicoDatcom",
    ModemTS = "ModemTS",
    Dlms = "Dlms",
    ZZ044 = "ZZ044",
    GeniusSlim = "GeniusSlim",
    G4EUS2 = "G4EUS2",
    IoT = "IoT",
    ElsterBKG4 = "ElsterBKG4",
    Elcor = "Elcor",
    ElcorPlus = "ElcorPlus",
    MeterEG4EVO = "MeterEG4EVO",
    SchneiderIEM3000 = "SchneiderIEM3000",
    GazModem3Device = "GazModem3Device",
    Datcom3 = "Datcom3",
    DatcomPlus = "DatcomPlus",
    Mpdr = "Mpdr",
    MacBAT5 = "MacBAT5",
    MacR6 = "MacR6",
    MacR6Z0P = "MacR6Z0P",
    MacR6P = "MacR6P",
    ShitekUGMG4 = "ShitekUGMG4",
    MetrixWTG4SG = "MetrixWTG4SG",
    LandisGyrE650 = "LandisGyrE650",
    ApulseX3F5 = "ApulseX3F5",
    PulseAtexX2 = "PulseAtexX2",
    PulseX3 = "PulseX3",
    FiorentiniRSE = "FiorentiniRSE",
    MeteRSitG = "MeteRSitG",
    SchrackEIZ = "SchrackEIZ",
    ElcorLite = "ElcorLite",
    MacR6N = "MacR6N",
    IEC104 = "IEC104",
    DatcomLite = "DatcomLite",
    MacMatIV = "MacMatIV",
    BlSigAmr1 = "BlSigAmr1",
    Escom = "Escom",
    ModbusVicorDevice = "ModbusVicorDevice",
    ModbusMicroZDevice = "ModbusMicroZDevice",
    MacR6IoT = "MacR6IoT",
    HoneywellEI7 = "HoneywellEI7",
    FiorentiniRSEIoT = "FiorentiniRSEIoT",
    PicoElcor2 = "PicoElcor2",
    AMTB2C = "AMTB2C",
    FloBoss1200 = "FloBoss1200",
    SagemcomES4EVO = "SagemcomES4EVO",
    ProdigiIoT = "ProdigiIoT",
    CorusEvoPlus = "CorusEvoPlus",
}

export enum DeviceTypeDescriptionObjectState {
    Unchanged = "Unchanged",
    New = "New",
    Deleted = "Deleted",
    Modified = "Modified",
    PendingSave = "PendingSave",
}

export enum SystemEventEntryType {
    Error = "Error",
    FailureAudit = "FailureAudit",
    Information = "Information",
    SuccessAudit = "SuccessAudit",
    Warning = "Warning",
}

export enum DataTableRemotingFormat {
    Xml = "Xml",
    Binary = "Binary",
}

export enum DataSetRemotingFormat {
    Xml = "Xml",
    Binary = "Binary",
}

export enum DataSetSchemaSerializationMode {
    IncludeSchema = "IncludeSchema",
    ExcludeSchema = "ExcludeSchema",
}

export enum DataColumnDateTimeMode {
    Local = "Local",
    Unspecified = "Unspecified",
    UnspecifiedLocal = "UnspecifiedLocal",
    Utc = "Utc",
}

export enum DataColumnColumnMapping {
    Element = "Element",
    Attribute = "Attribute",
    SimpleContent = "SimpleContent",
    Hidden = "Hidden",
}

export enum DeviceChartDataDataType {
    RawData = "RawData",
    HourlyData = "HourlyData",
    DailyData = "DailyData",
    MonthlyData = "MonthlyData",
    ActualData = "ActualData",
}

export enum DriverCommunicationChannelChannelType {
    Unknown = "Unknown",
    Direct = "Direct",
    Modem = "Modem",
    TCP = "TCP",
    IPModem = "IPModem",
    ModemListening = "ModemListening",
    TcpListening = "TcpListening",
    Sms = "Sms",
    Http = "Http",
    IpModemListening = "IpModemListening",
    Virtual = "Virtual",
    SmsGateway = "SmsGateway",
    MultiTcpListeningMaster = "MultiTcpListeningMaster",
    MultiTcpListeningSlave = "MultiTcpListeningSlave",
    UDP = "UDP",
    EguRegistration = "EguRegistration",
    EguSlave = "EguSlave",
    EguMaster = "EguMaster",
    UdpListeningMaster = "UdpListeningMaster",
    UdpListeningSlave = "UdpListeningSlave",
}

export enum DriverCommunicationChannelChannelState {
    CommunicationStopped = "CommunicationStopped",
    CommunicationInProgress = "CommunicationInProgress",
    ReceivingCallback = "ReceivingCallback",
}

export enum DeviceAlarmItemCondition {
    AnyDataChange = "AnyDataChange",
    IncrementDataChange = "IncrementDataChange",
    DecrementDataChange = "DecrementDataChange",
    LeadingEdge = "LeadingEdge",
    TrailingEdge = "TrailingEdge",
    HighCriticalLimit = "HighCriticalLimit",
    HighWarningLimit = "HighWarningLimit",
    LowWarningLimit = "LowWarningLimit",
    LowCriticalLimit = "LowCriticalLimit",
    ValueInRange = "ValueInRange",
    ValueOutOfRange = "ValueOutOfRange",
}

export enum GasConversionParametersCompressibilityType {
    None = "None",
    AGANX19 = "AGANX19",
    SGERG88 = "SGERG88",
    AGANX19MOD = "AGANX19MOD",
    AGA8G1 = "AGA8G1",
    AGA8G2 = "AGA8G2",
    AGA892DC = "AGA892DC",
    GOSTNX19MOD = "GOSTNX19MOD",
    GOST30319_2 = "GOST30319_2",
    GOST30319_3 = "GOST30319_3",
}

export enum ExportSchedulerPeriodicallyConditionType {
    Minutely = "Minutely",
    Hourly = "Hourly",
    Daily = "Daily",
    Weekly = "Weekly",
    Mounthly = "Mounthly",
}

export enum ExportPropertiesTimeRange {
    PreviousHour = "PreviousHour",
    PreviousDay = "PreviousDay",
    PreviousWeek = "PreviousWeek",
    PreviousMonth = "PreviousMonth",
    CurrentMonth = "CurrentMonth",
    PreviousDays = "PreviousDays",
    PreviousDays_CurrentDayIncluded = "PreviousDays_CurrentDayIncluded",
    PreviousHours = "PreviousHours",
    CurrentMonth_WithLastDayFromPreviousMonth = "CurrentMonth_WithLastDayFromPreviousMonth",
    CurrentMonth_CurrentDayExcluded = "CurrentMonth_CurrentDayExcluded",
    CurrentYear = "CurrentYear",
    PreviousYear = "PreviousYear",
    PreviousYears = "PreviousYears",
    PreviousYears_CurrentYearIncluded = "PreviousYears_CurrentYearIncluded",
}

export enum ReadRequestStatus {
    Unknown = "Unknown",
    NotAssigned = "NotAssigned",
    AssignedToDeviceServer = "AssignedToDeviceServer",
    AssignedToDriver = "AssignedToDriver",
    DataReading = "DataReading",
    ReadingDone = "ReadingDone",
    ReadingPartiallyDone = "ReadingPartiallyDone",
    Failure = "Failure",
    DuplicateRequest = "DuplicateRequest",
    Connecting = "Connecting",
    WaitingForAssociatedCalls = "WaitingForAssociatedCalls",
}

export enum ReadRequestFailureSource {
    Unknown = "Unknown",
    DeviceServer = "DeviceServer",
    NativeDriver = "NativeDriver",
    DataProcessing = "DataProcessing",
    CentralServer = "CentralServer",
    DataStorageServer = "DataStorageServer",
}

export enum SystemEventLogEventType {
    Error = "Error",
    FailureAudit = "FailureAudit",
    Information = "Information",
    SuccessAudit = "SuccessAudit",
    Warning = "Warning",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}